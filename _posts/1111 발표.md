serach_bar.js

```javascript
function mapDispatchToProps(dispatch) {
    return bindActionCreators({fetchWeather}, dispatch);
}
```

이 searchbar의 목적은 액션 생성자인 FETCH_WEATHER 을 검색바 컨테이너에 연결하는 것입니다.

그래서 mapDispatchToProps 라는 함수를 정의하구요.

이 안에 bindActionCreators 를 반환하고, 그안의 요소로 ETCH_WEATHER 을 넣고,  두번째 요소로는 별도의 괄호로 dispatch를 전달합니다.

이제 이건 액션 생성자로서, 호출될 때마다 dispatch와 함께 액션이 반환이 됩니다.

그럼 이 액션이 미들웨어로 흘러가 리덕스 어플리케이션안의 리듀서로 들어가게 됩니다.



```javascript
export default connect(null, mapDispatchToProps)(SearchBar);
```

그리고 export 를 해주어야 하는데

이 전달하는 것이 null인 이유는 이 함수를 전달할때, 컨테이너에 전달하는

mapDispatchToProps 가 두번째 요소로 들어가기 때문에 첫번째 요소로 null을 넣어줬습니다.

이 첫번째 요소가 null인 것은 리덕스가 스테이트를 유지하고 있다고 하는데 간단하게 컨테이너가 이에 대해 신경쓸 필요 없다는 뜻입니다. 

그니까 여기에 어떤 스테이트도 필요없다~ 라는 뜻입니다.

export를 해주었으니 위에 class는 export default 지워줘야합니다.



```javascript
    onFormSubmit(event) { // 만든 액션 생성자를 호출
        event.preventDefault();

        // 유저가 주어진 도시를 검색하려고 시도 (실제 도시 전달)
        this.props.fetchWeather(this.state.term);
        // 검색이 끝나면 초기화
        this.setState({term: ''});
    }
```

이제 만든 액션 생성자를 호출해주어야하는데 onFormSubmit로 호출을 해줍니다.

주석으로 써놓앗긴한데 '실제 도시를 전달'해서 유저가 주어진 도시를 검색하려고 시도하는 코드를 써주고 

편의를 위해서 검색이 끝나면 그 input 창을 초기화 해줍니다.

근데 이렇게만 쓰고 실행하면 Cannot read property 오류 발생하거든요

여기 JSX 엘리먼트나 DOM 엘리먼트를 전달하는 콜백이 있을때, 이를 컨텍스트로 바인딩을 해야합니다.



```javascript
constructor(props) {
    super(props);

    this.state = { term: ''};
    // 바인딩 필요
    this.onInputChange = this.onInputChange.bind(this);
    this.onFormSubmit = this.onFormSubmit.bind(this);
}
```

그래서 이와 같이 onFormSubmit 도 바인딩 해주면! 잘 굴러갑니다.



--------------

지금 필요한 것은 적절한 데이터로 도시의 리스트를 렌더링하는 새 컴포넌트를 만들어줍니다.

도시 리스트를 렌더링하는 것이 목적이라서 리덕스 스테이트로 접근이 필요하고 모든 데이터에 접근하도록 할겁니다. 그래서 컨테이너에 weather_list라는 코드를 만들어줍니다.


mapStateToProps 함수를 정의해서 날씨 데이터를 가져와 컨테이너로 넣을 거에요.

그러니까 mapStateToProps는 이렇게 오브젝트를 반환해주면 되겠져!

```javascript
import React, {Component} from 'react';
import { connect } from 'react-redux';

export default class WeatherList extends Component {
    render() {
        return (
            <table className="table table-hover">
                <thead>
                <tr> // 헤더 부분
                    <th>City</th>
                    <th>Temperature</th>
                    <th>Pressure</th>
                    <th}>Humidity</th>
                </tr>
                </thead>
                <tbody>
                {this.props.weather.map(this.renderWeather)}
                </tbody>
            </table>
        )
    }
}

function mapStateToProps( { weather }) {
    return{ weather };
    // es6로 진행한다면..
    // // {weather} === { weather: weather}
}

```

/*
마지막으로 필요한 것은 실제로 컴포넌트와 함수를 mapStateToProps로 연결하는 것인데요.
맨 밑에 export해주고 export해줬으니까 class앞에 export default도 지워줍니다.
*/

```javascript
import React, {Component} from 'react';
import { connect } from 'react-redux';

// export default 지우기
class WeatherList extends Component {
    render() {
        return (
            <table className="table table-hover">
                <thead>
                <tr> // 헤더 부분
                    <th>City</th>
                    <th>Temperature</th>
                    <th>Pressure</th>
                    <th}>Humidity</th>
                </tr>
                </thead>
                <tbody>
                {this.props.weather.map(this.renderWeather)}
                </tbody>
            </table>
        )
    }
}

function mapStateToProps( { weather }) {
    return{ weather };
}

export default connect(mapStateToProps)(WeatherList);

```

저희는 각 행에 하나의 도시를 가리키도록 할 겁니다. 

그래서 이 행들의 리스트를 만들어야 했어요.

저희 데이터 모양을 보면 이렇게

날씨 안에 도시랑 온도 습도 등등의 정보들이 list로 들어가 있습니다.

![image-20211111164331627](C:\Users\shimc\AppData\Roaming\Typora\typora-user-images\image-20211111164331627.png)

그에 대한 list를 JS 코드로 호출해줍니다.

이건 JS 기초니까.. 그냥 함수를 불러오는 코드입니다.



```javascript
class WeatherList extends Component {
    render() {
        return (
            <table className="table table-hover">
                <thead>
                <tr>
                    <th}>City</th>
                    <th>Temperature (k)</th>
                    <th>Pressure (hPa)</th>
                    <th>Humidity (%)</th>
                </tr>
                </thead>
                <tbody>
                // JS로 함수 호출
                {this.props.weather.map(this.renderWeather)}
                </tbody>
            </table>
        )
    }
}
```

 cityData는 this.props.weather 요소는 각 호출의 첫번째 요소로 특정한 도시의 데이터나 이를 담고 있는 오브젝트라서 이걸 불러온다고 생각하면 될거같아요.

```javascript
    renderWeather(cityData) { 
        // 중복제거를 위한 상수 처리
        const name = cityData.city.name;

        return(
            <tr key={name}>
                <td>{name}</td>
            </tr>
        );
    }
```



https://www.npmjs.com/package/react-sparklines

Sparkline인데요 링크를 들어가면 쓰는 방법이 아주 상세하게 나와있습니다.

어.. 데이터정보, 가로, 세로, 이런거 써주면 됩니다.

자세하게 쓰는 법이 나와있어서 이런건 그냥 검색합니다.

![image-20211111165037575](C:\Users\shimc\AppData\Roaming\Typora\typora-user-images\image-20211111165037575.png)

사이트에 나와있는대로 Sparklines 를 import 해주고 data를 불러와줍니다.

이건 크게 어렵지 않았어요.

```javascript
import React, {Component} from 'react';
import { connect } from 'react-redux';
import { Spartlines, SparklinesLine } from 'react-sparklines'

class WeatherList extends Component {
    renderWeather(cityData) {
        const name = cityData.city.name;
        const temps =  cityData.list.map(weather => weather.main.temp);

        return(
            <tr key={name}>
                <td>{name}</td>
				<td>
            		<Sparklines height={120} width={180} data={temps}>
                        <SparklinesLine color="red" />
                    </Sparklines>
            	</td> 
            </tr>
        );
    }
```

근데 이 SparkLine 코드를 분리된 컴포넌트로 리팩토링할건데

왜냐면 이 Sparklines를 그 표로 구성된 칸마다 복붙해서 넣게 될거니까 계속 재사용하게 됩니다.

그래서 이걸 독립된 컴포넌트를 만듭니다.

그럼 이것도 앞에서 정했던 것처럼 컨테이너 혹은 컴포넌트인지 결정해야합니다.



여기 함수 안에서 모든 데이터를 생성하는데요. 항상 차트 안으로 데이터를 전달하니까 새로운 차트 컴포넌트는 리덕스와 통신할 필요가 없습니다.

왜냐하면, 여기서 받는 데이터는 부모로부터 데이터를 받기 때문이에요

그래서, 이를 컴포넌트로 만듭니다.



그리고 또 고민할게 함수형으로 만들거냐 클래스형으로 만들거냐를 고민하게 됩니다.

이 경우에, 차트 안에 어떤 state 도 사용하지 않고 그냥 props가 들어오면, 컴포넌트를 리렌더링하는것이니까 함수형 컴포넌트로 만들어줍니다.



새 파일인 chart.js 를 만들게요.

chart.js

```javascript
import _ from 'lodash';
import React from "react";
import { Sparklines, SparklinesLine, SparklinesReferenceLine } from 'react-sparklines';

function average(data){
    return _.round(_.sum(data)/data.length);
}

export default (props) => {
    return (
        <div>
            <Sparklines height={120} width={180} data={props.data}>
                <SparklinesLine color={props.color} />
                <SparklinesReferenceLine type="avg" />
            </Sparklines>
            <div>{average(props.data)} {props.units}</div>
        </div>
    );
}
```

