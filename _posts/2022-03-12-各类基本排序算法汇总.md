---
layout:     post   				    # 使用的布局（不需要改）
title:      各类基本排序算法汇总		# 标题 
subtitle:   冒泡、选择、插入、快速、归并、桶 #副标题
date:       2022-03-12 				# 时间
author:     谢玄xx 						# 作者
header-img: img/westlake1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 哈希表
    - 排序算法
---

# 冒泡排序

## 排序思路

从数组第一个元素出发，和第二个元素作比较。如果第一个元素较大，就将其与第二个元素交换位置。遍历数组，那么最大的元素将出现在数组的最右侧，完成一遍排序；第二遍从数组第一个元素开始，执行相同的操作，这次遍历终点为 n - 1 ，以此类推。遍历终点为第二个数组元素后，停止遍历，排序算法完成。


## 代码如下：


# 选择排序

## 排序思路

假设第一个元素为数组中最小的元素，从第二个元素开始遍历数组，找出剩余元素中最小的元素。找到这个元素后，将其与第一个元素比较，把更小的那个元素放在数组的第一位。之后以此类推。遍历终点为第 n - 1个元素后，停止遍历，选择排序算法完成。

## 代码如下：

```CPP
int select_sort(vector<int> &arr)
{
	int min_value = 0;
	int min_pos = 0;
	for(int i = 0; i < arr.size(); i++)
	{
	    min_value = arr[i];
	    min_pos = i;
	    for(int j = i + 1; j < arr.size(); j++)
	    {
		if(arr[j] < min_value)
		{
		    min_value = arr[j];
		    min_pos = j;
		}
	    }
	}
	if(arr[i] > min_value)
	{
	    arr[min_pos] = arr[i];
	    arr[i] = min_value;
	}
}
void main() {
	vector<int> s;
	vector.push_back(3);
	vector.push_back(5);
	vector.push_back(2);
	vector.push_back(7);
	vector.push_back(1);
	vector.push_back(4);
	select_sort(s);
	for(vector<int> :: iterator it = arr.begin(); it != arr.end(); it++)
	{
		cout << *it << endl;
	}
	//return 0;
}
```


# 堆排序

## 排序思路

* 从
* 建堆的时间复杂度为O(n),排序的时间复杂度为O(nlogn)，因此堆排序的总体时间复杂度为O(nlogn)，空间复杂度为O(n)。      


## 代码如下：
```cpp
#include <iostream>
#include <vector>
using namespace std;
//vector<int> &arr好像不行，但arr[]就可以
//先维护一个大顶堆,维护的时间复杂度为O(logN)
void heapify(int arr[], int n, int i)
{
	int largestNode = i;//将一个节点视为它和两个孩子的三者最大值
	int lchild = 2 * i + 1;	//左右孩子下标随之确定
	int rchild = 2 * i + 2;
	if (lchild < n && arr[lchild] > arr[largestNode])//如果左孩子没超出节点，且左孩子值大于i节点的值，就把最大值下标给左孩子
	{
		largestNode = lchild;
	}
	if (rchild < n && arr[rchild] > arr[largestNode])//右孩子同理
	{
		largestNode = rchild;
	}
	if (largestNode != i)//把上面的下标兑现，和节点交换位置。这是自下而上的递归，所以继续heapify.
	{
		swap(arr[largestNode], arr[i]);
		heapify(arr, n, largestNode);//请注意递归条件——从这个最大节点开始遍历。
	}

}

void heap_sort(int arr[], int n)
{
	//堆排序分为建堆和排序两步
	//首先建堆,从最后一个非叶子节点i开始，自下而上建堆
	for (int i = n / 2 - 1; i >= 0; i--) //这里n是数组长度，所以最后一个节点下标为n-1,因此它的双亲节点为(n-1-1)/2
	{
		heapify(arr, n, i);//思考一下动态建堆过程，搞明白
	}

	//接下来开始排序
	for (int j = n - 1; j > 0; j--)
	{
		swap(arr[j], arr[0]); //把大顶堆的顶和最后一个元素交换位置
		heapify(arr, j, 0); //然后继续维护这个新的大顶堆
	}
}



int main()
{
	int arr[] = {5,6,3,4,1,7,2};
	for (int i = 0; i < 7; i++)
	{
		cout << arr[i] << endl;
	}

	heap_sort(arr, 7);
	for (int i = 0; i < 7; i++)
	{
		cout << arr[i] << endl;
	}
}
```

# 快速排序

## 排序思路

* 快速排序的思路为：先选定一个基准值，其所在下标为pivot；将所有小于这个基准值的元素移到pivot左边，将所有大于这个基准值的元素移到pivot右边。之后对pivot左侧和右侧的元素分别执行递归，最终可以得到一个升序排列的数组。
* 时间复杂度为O(nlogn),最坏情况为O(n)      由于没有引入额外的空间数组，因此空间复杂度为O(1)。


## 代码如下：

```CPP
#include <iostream>
#include <vector>
using namespace std;

void quick_sort(vector<int> &nums, int left, int right)
{
	int pivot = left;
	if(left > right) return;
	for(int i  = left; i < right; i++)
	{
		if(nums[i] < nums[right])
		{
			swap(nums[i],nums[pivot]);
			pivot++;
		}
	}
	swap(nums[pivot], nums[right]);
	quick_sort(nums, left, pivot - 1);
	quick_sort(nums, pivot + 1, right);
}



int main()
{
	vector<int> vec = {4,5,3,6,2,5,1};
	for(int i = 0; i < vec.size(); i++)
	{
		cout << vec[i] << " ";
	}
	cout << endl;
	cout << " ---------- " << endl;
	quick_sort(vec, 0, 6);
	for(int i = 0; i < vec.size(); i++)
	{
		cout << vec[i] << " ";
	}	
   return 0;
}

```

