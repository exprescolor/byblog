---
layout:     post   				    # 使用的布局（不需要改）
title:      静态\常量成员变量&函数				# 标题 
subtitle:   面向对象程序设计 #副标题
date:       2022-04-11 				# 时间
author:     谢玄xx						# 作者
header-img: img/sea3.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 面向对象
    - 八股
---

# 静态成员：在说明前面加上**static**关键字的成员。

```CPP

```
## 静态成员变量与普通成员变量的区别

* 普通成员变量在类中被定义后，不同对象的变量值不同；
* 静态成员变量被定义后，不同对象的值都是这个变量值。
* 静态成员变量本质上来说是**全局变量**。哪怕一个对象都不存在，类的静态成员变量也是存在的。它不依附于对象的存在而存在。(独立！)

* **请注意！** sizeof()运算符不会计算静态成员变量！！

原因：静态成员变量static是放在所有对象外面的变量，为所有对象共享。

```CPP
class CMyclass
{
    int n;
    static int s;
};
// sizeof(CMyclass) = 4 而不是8！
```
## 静态成员函数与普通成员函数的区别

* 普通成员函数必须具体作用于某个对象(在主函数中的调用方法： 对象名.成员函数名  or  指针->成员函数名  or 引用.成员函数名)
* 而静态成员函数并不具体作用于一个对象(渣男行为)。
* 因此，静态成员**无需对象**即可访问。
* 静态成员函数本质上来说是**全局函数**

# 如何访问静态成员

## 类名::成员名

```CPP
CMyclass :: Print();
```

## 对象名.成员名(和普通成员函数一样)

```CPP
CMyclass c1;
c1.Print();
```
* 请注意，虽然写的是c1.函数名，但这个函数并不属于c1对象，也并不作用于c1对象。

## 指针->成员名(和普通成员函数一样)

```CPP
CMyclass *p1 = &c2;
p1->Print();
```
* 请注意，虽然写的是p1->函数名，但这个函数并不仅仅作用于p1所指向的那个对象c2。

## 引用.成员名

```CPP
CMyclass &p2 = &c3;
int n = p2.Print();
```
* 同样地，Print()函数不仅仅属于p2所引用的那个对象c2，而是CMyclass类所有对象共享。

# 静态成员实例分析

```CPP
#include <iostream>
using namespace std;

class CRectangle
{
private:
	int w, h;
	static int nTotalArea;
	static int nTotalNumber;
public:
	CRectangle(int w_, int h_);
	~CRectangle();
	static void PrintTotal();
};

CRectangle :: CRectangle(int w_, int h_)
{
	w = w_;
	h = h_;
	nTotalNumber++;
	nTotalArea += w * h;
}
CRectangle::~CRectangle()
{
	nTotalNumber--;
	nTotalArea -= w * h;
}

void CRectangle::PrintTotal()
{
	cout << nTotalNumber << "," << nTotalArea << endl;
}

//必须在定义类的文件中，对静态成员变量进行声明&初始化
//否则编译通过，生成.obj不通过
int CRectangle::nTotalNumber = 0;
int CRectangle::nTotalArea = 0;

int main()
{
	CRectangle r1(3, 3), r2(2, 2);
	//cout << CRectangle::nTotalNumber;	//不能这么写，nTotalNumber私有
	CRectangle::PrintTotal();
	r1.PrintTotal();//这一行的效果和上一行相同
	return 0;
}

//输出结果：
//2,13
//2,13
```
* 值得注意的是，上述程序具有严重的安全隐患。
* 在使用CRectangle类时，有时会调用缺省的拷贝构造函数，生成**临时的隐藏CRectangle对象**。
* 有一些CRectangle的对象，不会通过我们写的这个构造函数来初始化(?!?!)，而是通过拷贝构造函数来初始化。
* 什么时候会调用拷贝构造函数呢？
1. 调用一个以CRectangle类对象作为参数函数时(本例中没有，但类成员函数可以添加啊。一不小心添加了这种函数就有可能出问题)
2. 调用一个以CRectangle类对象作为返回值的函数时(具体请参考：[构造函数与析构函数相关知识点](https://github.com/xie96808/xie96808.github.io/blob/master/_posts/2022-04-05-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.md))
* 这些对象在初始化的时候没有走我们预设的路线，nTotalNumber和nTotalArea不会如期增加；但消亡的时候却只能使用我们自己定义的析构函数。因此nTotalNumber和nTotalArea会“无端”减少，从而造成输出错误！
* 解决方法：把拷贝构造函数也写了，问题不就解决了嘛：）

```CPP
//在上述程序中加入本拷贝构造函数
CRectangle :: CRectangle(CRectangle & r)
{
	w = r.w;
	h = r.h;
	nTotalNumber++;
	nTotalArea += w * h;
}
```


# Speacial Reminder

* 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。在static函数中，它们不带普通函数一起玩。
* 因此上述程序中，若调用PrintTotal()函数，则不能直接打印w或h，因为这两兄弟是普通的成员变量，不是静态成员变量，不能访问。
换一种方式理解：如果使用CRectangle::PrintTotal()调用这个函数，那就说不清这个w和h到底是哪个变量的边长和面积，那么当然不能访问。


# 常量成员函数

```CPP
class Sample
{
public:
	int value;
	void GetValue() const;
	void func() {};
	Sample() {}
};

void Sample :: GetValue() const
{
	value = 0;		//不能这么写！
	func();			//也不能这么写！
}

int main()
{
	const Sample o;		//定义了常量对象o
	o.value = 100;		//报错！常量对象不可以被修改！
	o.func();		//报错，常量对象上不可以执行non-常量成员函数
	o.GetValue();		//可以，常量对象上执行常量成员函数
	return 0;
}
```
