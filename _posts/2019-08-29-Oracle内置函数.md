---
layout:     post 
title:      Oracle内置函数
subtitle:   简单的了解Oracle内置函数
date:       2019-08-29 
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                              
    - Oracle
    - Java
---

# Oracle内置函数
------
### 单记录字符函数

#### INSTR(<c1>,<c2>[,<l>[,<j>]])
- 在一个字符串中搜索指定的字符，返回发现指定的字符的位置
- c1：被搜索的字符串
- c2：希望搜索的字符串
- l：搜索的开始位置，缺省是1
- j：第j次出现，缺省是1
- `SELECT INSTR('Oracle Training','ra',1,2) "Instring" FORM DUAL;`

#### LENGTH(<c>)
- 返回字符串c的长度
- `SELECT LENGTH('Oracle Training') FROM DUAL;`

#### LOWER(<c>)
- 返回字符串并将所有字符变为小写
- `SELECT LOWER ('Oracle Training') FROM DUAL;`

#### UPPER(<c>)
- 返回所有字符串并将所有字符转换为大写
- `SELECT UPPER('Oracle Training') FORM DUAL;`

#### LAPD(String1，Length[,String2])
- 在字符串Stirng1的左边填充字符串String2，填充后的长度为Length。String2的参数可选，若String2的参数不填，则在String1的左侧补空格
- `SELECT LAPD ('abcde',10,'x') FROM DUAL;`——结果为xxxxxabcde

#### RPAD(String1,Length[,String2])
- 在字符串String1的右边填充字符串String2，填充后的长度为Length，String2的参数可选，若String2参数不填，则在String1的右侧补空格
- `SELECT RPAD('abcde',10,x) FROM DUAL;`——结果为abcdexxxxx

#### LTRIM(String1 [,String2])
- 删除String1左边出现的任何String2字符，保证String1的第一个字符不能出现在String2字符串中。String2的参数可选，不String2不填，则将String1的左侧所有空白字符去掉。
- `SELECT LTRIM('MISS LIU','M IS') RESULT FROM DUAL;`——结果为LIU

#### RTRIM(String1[,String2])
- 删除String1右边出现的任何String2字符，保证String1的最后一个字符不能出现在String2字符串中。String2的参数可选，若String2的参数不填，则将String1的右侧所有空格删去
- `SELECT RTRIM('Mississippi','ip') test,RTRIM('Mississippi','sip') test2 FROM DUAL;`——结果为test1：Mississ     test2：M

#### Substr(String,start[,Count])
- 对字符串或（字段），从start字符开始，连续取count个字符并返回结果，如果没有指定count则一只取到结尾
- `SELECT substr('Miss Lis Mis',6,3) RESULT FROM DUAL;`——结果为Lis

#### Replace('String1'[,'String2','Stirng3'])
- String1：希望被替换的字符串或变量
- String2：被替换字符串
- String3：要替换字符串
- `SELECT REPLACE('Oracle','Or','Mir') "Example" FORM DUAL;`——结果为Miracle

#### CEIL(<n>)
- 返回大于或等于给出数字的最小整数，即向上取整
- `SELECT CEIL(3.141598) FROM DUAL;`——结果为4

#### FLOOR(<n>)
- 返回小于或等于给出数字的最大整数，即向下取整
- `SELECT FLOOR(3.141598) FROM DUAL;`———结果为3

#### MOD(<n1>,<n2>)
- 返回整数n1除以n2之后的余数
- `SELECT MOD(10,3)FORM DUAL;`——结果为1

#### ROUND(VALUE,PRECISION)
- 按照precision指定的精度对value进行四舍五入
- `SELECT ROUND(3.14159,2)FROM DUAL;`——结果为3.14

------
### 单记录日期函数

#### ADD_MONTHS(<d>,<l>)
- 增加月份或减去月份，在d日期的基础上，增加l（l可为负数）个月之后的时间
- `SELECT to_char(add_months(to_date('2019-01-01','yyyy-mm-dd'),2),'yyyy-mm-dd') from dual;`——结果为2019-03-01
- `SELECT to_cahr(add_month(to_date('2019-03-01','yyyy-mm-dd'),-2),'yyyy-mm-dd')from dual;`——结果为2019-01-01

#### LAST_DAY(date)
- 返回日期date所在月的最后一天
- `SELECT to_char(last_day(to_date('2019-02-01','yyyy-mm-dd')),'yyyy-mm-dd')from dual;`——结果为2019-02-28

#### MONTHS_BETWEEN(date2,date1)
- 返回date2-date1的月数（可以是小数）
- `SELECT months_between(to_date('2014-02-01','yyyy-mm-dd'),to_date('2014-04-01','yyyy-mm-dd'))from dual;`——结果为2

#### SYSDATE
- 返回系统的当前时间
- `SELECT to_cahr(sysdate,'yyyy-mm-dd')from dual;`

#### TRUNC(<date>,[,<fmt>])
- 按照给出的fmt要求将日期截断
- `SELECT to_char(trunc(sysdate,'dd'),'yyyy-mm-dd')from dual;`——结果为2019-08-29
- `SELECT to_char(trunc(sysdate,'mm'),'yyyy-mm-dd')from dual;`——结果为2019-08-01
- `SELECT to_char(trunc(sysdate,'yy'),'yyyy-mm-dd')from dual;`——结果为2019-01-01

------
### 单记录转换函数

#### TO_CHAR(date,'format')
- 根据format格式将日期date转换为对象格式的字符串

#### TO_CHAR(<n>)
- 将数字n转换为字符串

#### TO_NUMBER(<c>)
- 将字符串c转换为数字

#### TO_DATE(string,'format')
- 根据format格式将指定格式的字符串string转换为date类型

### 单记录函数小结
- 单记录函数可以用在查询结果中
- 单记录函数可以用在where条件中
- `SELECT to_char(emp_birthday,'yyyy-mm-dd')from emp;`
- `SELECT * from whrer emp_birthday >=to_date('1980-01-01','yyyy-mm-dd') and emp_birthday < to_day('1990-01-01','yyyy-mm-dd');`

------
### 组函数

#### AVG([{DISTINCT|ALL}])
- 求平均值，ALL表示对所有求平均值，DISTINCT只对不同的求平均值，相同只取一个

#### MAX([{DISTINCT|ALL}])
- 求最大值，ALL表示对所有求最大值，DISTINCT只对不同的求最大值，相同只取一个

#### MIN([{DISTINCT|ALL}])
- 求最小值，ALL表示对所有求最小值，DISTINCT只对不同的求最小值，相同只取一个

------
#### 带group by的计算

- 可以用group by来实现对一组数进行分组统计
- 例：统计每个部门的员工数和工资总额
- `select dept.dept_no,count(*),sum(sal.sal) from dept,emp,sal where dept.dept_no=emp.emp_dept_no and emp.emp_no=sal.emp_no group by dept.dept_no;`

#### Having的用法
- 在分组group by中，一般不管统计的结果是多少都要全部显示，我们可以在group by前或后加having子句来限制结果的统计
- 例：统计员工数超过5个人的部门员工数和工资总额
-  `select dept.dept_no,count(*),sum(sal.sal) from dept,emp,sal where dept.dept_no=emp.emp_dept_no and emp.emp_no=sal.emp_no group by dept.dept_no having count(*) > 5;`

#### 查询结果的排序

- 使用order by进行查询结果的排序，order by语句应位于查询语句的结尾
- 例：按照部门编号和工资升序排列
- `select dept.dept_no,emp.emp_no,sal.sal from emp,dept,sal where emp.emp_dept_no=dept.dept_no and emp.emp_no=sal.emp_no order by dept.dept_no,sal.sal;`
- 按照部门编号升序，工资降序排序
- order by dept.dept_no,sal.sal des;