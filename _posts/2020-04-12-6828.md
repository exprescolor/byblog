---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab4-partA(1)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-12 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

#Lab 4: Preemptive Multitasking

在这个实验中，我们将在多个同时活动的用户模式环境中实现先发制人的多任务处理。

在第A部分中，我们将向jos添加多处理器支持、实现循环调度并添加基本的环境管理系统调用(创建和破坏环境的调用以及分配/映射内存的调用)。

在第B部分中，我们将实现一个类unix的fork()，它允许用户模式环境创建自身的副本。

最后，在第C部分中，我们将添加对进程间通信(IPC)的支持，允许不同的用户模式环境显式地相互通信和同步。我们还将添加对硬件时钟中断和抢占的支持。

在切换分支时，我遇到了一个问题：

```
s-seven@sseven-virtual-machine:~/lab$ git pull
error: 您尚未结束您的合并（存在 MERGE_HEAD）。
提示：请在合并前先提交您的修改。
fatal: 因为存在未完成的合并而退出。
```

搜索相关问题后输入`rm .git/MERGE_HEAD`解决这个

```
git checkout -b lab4 origin/lab4
error: 您对下列文件的本地修改将被检出操作覆盖：
	kern/env.c
	kern/pmap.c
	kern/syscall.c
	kern/trap.c
	kern/trapentry.S
	lib/printfmt.c
请在切换分支前提交或贮藏您的修改。
终止中
```

原来我这些没有提交，

```
s-seven@sseven-virtual-machine:~/lab$ git stash
保存工作目录和索引状态 WIP on lab3: a9d7717 Lab 3
```

保存一下就好了

悲伤的是，微博图床不能用了。。。

然后发现多了下面的内容：

| `kern/cpu.h`      | Kernel-private definitions for multiprocessor support        |
| ----------------- | ------------------------------------------------------------ |
| `kern/mpconfig.c` | Code to read the multiprocessor configuration                |
| `kern/lapic.c`    | Kernel code driving the local APIC unit in each processor    |
| `kern/mpentry.S`  | Assembly-language entry code for non-boot CPUs               |
| `kern/spinlock.h` | Kernel-private definitions for spin locks, including the big kernel lock |
| `kern/spinlock.c` | Kernel code implementing spin locks                          |
| `kern/sched.c`    | Code skeleton of the scheduler that you are about to implement |

## Part A: 多处理器支持和多任务协作

​		在本实验的第一部分中，我们将首先扩展JOS，使其在多处理器系统上运行，然后实现一些新的JOS内核系统调用，以允许用户级环境创建额外的新环境。我们还将实现协作循环调度，允许内核在当前环境自动放弃CPU(或退出)时从一个环境切换到另一个环境。在C部分的后面部分，您将实现抢占式调度，它允许内核在经过一段时间之后，即使环境不合作，也可以从环境中重新获得对CPU的控制。

### Multiprocessor Support

​		我们将使JOS支持“对称多处理”(SMP)，这是一种多处理器模型，其中所有cpu都可以对系统资源(如内存和I/O总线)进行等效访问。虽然SMP中的所有cpu在功能上都是相同的，但在引导过程中它们可以分为两种类型:引导处理器(bootstrap processor, BSP)负责初始化系统和引导操作系统;只有在操作系统启动并运行之后，BSP才会激活应用程序处理器(APs)。哪个处理器是BSP是由硬件和BIOS决定的。到目前为止，您所有现有的JOS代码都是在BSP上运行的。

​		在SMP系统中，每个CPU都有一个相应的本地APIC (LAPIC)单元。LAPIC单位负责在整个系统中提供中断。LAPIC还为其连接的CPU提供唯一的标识符。在本实验室，我们利用了LAPIC单元的以下基本功能(以kern/ LAPIC .c表示):

- 读取LAPIC标识符(APIC ID)来告诉我们的代码当前在哪个CPU上运行(参见cpunum())。

- 将启动处理器间中断(IPI)从BSP发送到APs以打开其他cpu(参见lapic_startap())。

- 在第C部分中，我们对LAPIC的内置计时器进行编程，以触发时钟中断来支持先发制人的多任务处理(参见apic_init())。

处理器使用内存映射I/O (MMIO)访问它的LAPIC。在MMIO中，物理内存的一部分被硬连接到一些I/O设备的寄存器，因此通常用于访问内存的加载/存储指令也可以用于访问设备寄存器。我们已经看到了物理地址0xA0000处的一个IO漏洞(我们使用它来写入VGA显示缓冲区)。LAPIC位于一个从物理地址0xFE000000开始的洞中(32MB短于4GB)，因此对于我们使用通常的KERNBASE直接映射访问它太高了。JOS虚拟内存映射在MMIOBASE留下了4MB的空白，所以我们有地方来映射这样的设备。由于后来的实验引入了更多的MMIO区域，我们将编写一个简单的函数来从这个区域分配空间并将设备内存映射到它。

### 练习1

在kern/pmap.c中实现mmio_map_region。要了解如何使用它，请查看kern/lapic.c中lapic_init的开头。在运行mmio_map_region测试之前，您还必须进行下一个练习。

所以我们先看一看kern/lapic.c中的lapic_init（）：

```c
void
lapic_init(void)
{
	if (!lapicaddr)
		return;

	// lapicaddr是LAPIC的4K MMIO区域的物理地址。将它映射到虚拟内存中，以便我们可以访问它。
	lapic = mmio_map_region(lapicaddr, 4096);

	// APIC;设置伪中断向量。
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));

	// 定时器从lapic[TICR]开始以总线频率重复地倒数，然后发出一个中断。如果我们更关心精确的计时，TICR将使用外部时间源进行校准。
	lapicw(TDCR, X1);
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
	lapicw(TICR, 10000000); 

	// 让BSP的LINT0处于启用状态，这样它就可以从8259A芯片获得中断。
	// 根据Intel MP规范，BIOS应该在虚拟线模式下初始化BSP的本地APIC，其中8259A的INTR实际上连接到BSP的LINTIN0。在这种模式下，我们不需要对IOAPIC进行编程。
	if (thiscpu != bootcpu)
		lapicw(LINT0, MASKED);

	// 在所有cpu上禁用NMI (LINT1)
	lapicw(LINT1, MASKED);

	// 在提供中断项的计算机上禁用性能计数器溢出中断。
	if (((lapic[VER]>>16) & 0xFF) >= 4)
		lapicw(PCINT, MASKED);

	// 将错误中断映射到IRQ_ERROR。
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);

	// 清除错误状态寄存器(需要连续写操作)。
	lapicw(ESR, 0);
	lapicw(ESR, 0);

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
	lapicw(ICRLO, BCAST | INIT | LEVEL);
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
```

mmio_map_region实现了分配空间并映射设备内存。

在lapic_init的开始，调用了mmio_map_region(lapicaddr, 4096)映射了4k的MMIO区域的物理空间到内存，然后我们实现这个函数，参考boot_map_region：

```c
void *
mmio_map_region(physaddr_t pa, size_t size)
{
	// 从哪里开始下一个区域。最初，这是MMIO区域的开始。因为它是静态的，所以在调用mmio_map_region之间会保留它的值(就像boot_alloc中的nextfree一样)。
	static uintptr_t base = MMIOBASE;

	// 保留从基址开始的虚拟内存大小字节，并将物理页[pa,pa+size]映射到虚拟地址[base,base+size]。因为这是设备内存而不是普通的DRAM，你必须告诉CPU缓存访问这个内存是不安全的。幸运的是，页表为此提供了位;除了PTE_W之外，只需使用PTE_PCD|PTE_PWT (cache-disable和write-through)创建映射
	// 确保将size四舍五入为PGSIZE的倍数，并处理该保留是否会溢出MMIOLIM。
	size_t begin = ROUNDDOWN(pa, PGSIZE), end = ROUNDUP(pa + size, PGSIZE);
    size_t map_size = end - begin;
    if (base + map_size >= MMIOLIM) {
        panic("overflow MMIOLIM");
    }    
    boot_map_region(kern_pgdir, base, map_size, pa, PTE_PCD|PTE_PWT|PTE_W);
    uintptr_t result = base;
    base += map_size;
    return (void *)result;
}
```

我们现在还不能进行测试，要做完下一个练习才行。

，