---
layout:     post   				    # 使用的布局（不需要改）
title:      哈希表系列问题集合				# 标题 
subtitle:   题目类型:Midium #副标题
date:       2022-03-15 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea7.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 哈希表
---

首先定义unordered_map<int, int> pairs;

# 哈希表各函数的定义

* 使用count，返回的是**被查找元素的个数**。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值**只能是0或1**。
* 使用find，返回的是**被查找元素的位置**，没有则返回pairs.end()。
* 在for()循环中，pairs[nums[i]]++用于统计各元素出现的**频次**，而pairs[nums[i]] = i则用于把各个元素放入哈希表！
* 在统计频次时，直接用pairs[nums[i]]即可。如果用pairs.count(nums[i])可能会有问题。

# LC20: 匹配的括号


## 解题思路

## 代码如下
```CPP
bool isValid(string s)
{
    int n= s.size();
    if(n % 2 == 1)
    {
        return false;
    }
    
    unordered_map<char, char> pairs = {
                                        {')', '('}, 
                                        {']', '['}, 
                                        {'}', '{'}}; //注意闭合括号在前
    stack<char> stk;   //新建一个栈，用于存储当前需要比对的括号
    for(char ch:s) //遍历字符串，变量为ch
    {
        if(pairs.count(ch))//count找到的是value值，也即开始括号。
        {
            if(stk.empty() || stk.top() != pairs[ch])
            {
                return false;
            }
            stk.pop();
        }
        else
        {
            stk.push(ch);
        }
    }
    return stk.empty();
}

```

# LC387: 字符串中的第一个唯一字符

## 解题思路

自从掌握了哈希表的用法后，这类问题统一使用哈希表解决，速度飞快！

## 代码如下

```CPP
int firstUniqChar(string s) {
    unordered_map<char, int> pairs;
    //我的想法：先用哈希表存储元素
    for(int i = 0; i < s.size(); i++) {
        pairs[s[i]]++;
    }
    //然后直接找出现频率=1的字符。
    for(int i = 0; i < s.size(); i++) {
        if(pairs[s[i]] == 1) {
            return i;
        }
    }        
    return -1;

}
```

# LC128: 最长连续序列

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

## 解题思路

* 看到此类问题联想到哈希表unordered_set。先把所有元素存入不重复元素哈希表中，然后进行连续子序列查找。
* 首先确定查找元素前一个元素是否存在。不存在才可进行下一步查找。定义一个变量x，每次遍历后把这个x+1，用于统计连续序列的长度(x - num),然后将其和结果值res取最大值即可。

## 代码如下

```CPP
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> pair(nums.begin(), nums.end());//C++11新特性可以这么写
    int res = 0;
    //遍历哈希表中元素。如果没有前一个元素，就从当前元素开始计数
    for(auto &num : pair) {
        if(!pair.count(num - 1)) {
            int x = num + 1;
            while(pair.count(x)) {
                x++;
            }
            res = max(res, x - num);
        }
    }
    return res;
}
```
