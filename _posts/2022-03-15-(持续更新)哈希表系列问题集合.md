---
layout:     post   				    # 使用的布局（不需要改）
title:      哈希表系列问题集合				# 标题 
subtitle:   题目类型:Midium #副标题
date:       2022-03-15 				# 时间
author:     谢玄xx 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 哈希表
---

首先定义unordered_map<int, int> pairs;

# 哈希表各函数的定义

* 使用count，返回的是**被查找元素的个数**。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值**只能是0或1**。
* 使用find，返回的是**被查找元素的位置**，没有则返回pairs.end()。
* 在for()循环中，pairs[nums[i]]++用于统计各元素出现的**频次**，而pairs[nums[i]] = i则用于把各个元素放入哈希表！

# 问题一：匹配的括号


## 解题思路

## 代码如下
```CPP
bool isValid(string s)
{
    int n= s.size();
    if(n % 2 == 1)
    {
        return false;
    }
    
    unordered_map<char, char> pairs = {
                                        {')', '('}, 
                                        {']', '['}, 
                                        {'}', '{'}}; //注意闭合括号在前
    stack<char> stk;   //新建一个栈，用于存储当前需要比对的括号
    for(char ch:s) //遍历字符串，变量为ch
    {
        if(pairs.count(ch))//count找到的是value值，也即开始括号。
        {
            if(stk.empty() || stk.top() != pairs[ch])
            {
                return false;
            }
            stk.pop();
        }
        else
        {
            stk.push(ch);
        }
    }
    return stk.empty();
}

```

# 问题二：LC387. 字符串中的第一个唯一字符

## 解题思路

自从掌握了哈希表的用法后，这类问题统一使用哈希表解决，速度飞快！

## 代码如下

```CPP
int firstUniqChar(string s) {
    unordered_map<char, int> pairs;
    //我的想法：先用哈希表存储元素
    for(int i = 0; i < s.size(); i++) {
        pairs[s[i]]++;
    }
    //然后直接找出现频率=1的字符。
    for(int i = 0; i < s.size(); i++) {
        if(pairs[s[i]] == 1) {
            return i;
        }
    }        
    return -1;

}
```
