---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab4-partA(2)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-13 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

###Application Processor Bootstrap

​		在启动APs之前，BSP应该首先收集关于多处理器系统的信息，例如cpu的总数、它们的APIC id和LAPIC单元的MMIO地址。kern/mpconfig.c中的mp_init()函数通过读取驻留在BIOS内存区域中的MP配置表来检索这些信息。

​		boot_aps()函数(在kern/init.c中)驱动AP引导进程。APs以实际模式启动，与boot/boot.S中的bootloader启动方式非常相似。因此，boot_aps()将AP条目代码(kern/mpentry.S)复制到一个在实际模式中可寻址的内存位置。与引导加载程序不同，我们可以控制AP从哪里开始执行代码;我们将条目代码复制到0x7000 (MPENTRY_PADDR)，但是任何未使用的、页面对齐的物理地址低于640KB都可以工作。

​		在此之后，boot_aps()将启动后的IPIs发送到相应AP的LAPIC单元，并将初始CS:IP地址(在我们的示例中，AP应该在这个地址上开始运行其条目代码(MPENTRY_PADDR)，从而逐个激活AP。输入码在kern/mpentry。S与boot/boot.S非常相似。经过一些简单的设置之后，它将AP置于启用分页的保护模式，然后调用C设置例程mp_main()(也在kern/init.c中)。boot_aps()等待AP在其结构CpuInfo的cpu_status字段中发出CPU_STARTED标志的信号，然后继续唤醒下一个标记。

### 练习2

在kern/init中读取boot_aps()和mp_main()。和汇编代码的kern/mpentry.S。确保您了解在APs引导期间的控制流传输。然后在kern/pmap.c中修改page_init()的实现，以避免将MPENTRY_PADDR页面添加到空闲列表中，这样我们就可以安全地复制并运行该物理地址上的AP引导代码。

将空闲基存的上限修改为MPENTRY_PADDR:

```
void
page_init(void)
{
	size_t i;
	for (i = 1; i < MPENTRY_PADDR/PGSIZE; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
```

