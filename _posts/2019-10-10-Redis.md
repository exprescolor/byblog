---
layout:     post 
title:      Redis教程
subtitle:   Redis
date:       2019-10-10
author:     张鹏
header-img: img/post-bg-keybord.jpg
catalog: true   
tags:                         
    - Redis
---

#### 什么是Redis

- Redis是一个开源的使用ANSI C编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言API。
- 换句话说，Redis就像是一个HashMap，不过不是在JVM中运行，而是以一个独立进程的形式运行
- 一般来说，Redis会被当作缓存使用。因为他比数据库快（Mysql）。所以常用的数据，可以考虑放在Redis中，这样就提高了性能。

#### Redis安装运行

- 解压缩即可安装
- 进入到解压路径，在地址栏输入cmd即可在当前路径下操作命令行
   - 启动Redis服务端、启动Redis客户端
   - redis-server.exe、redis-cli.exe
   - ![启动结果](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20092030.png)
   - 简单使用
      - 客户端输入并获取相关信息
      - ![简单应用](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20092659.png)

#### 基本数据类型

- Redis有5中基本数据类型：String（字符串）、List（列表）、Hash（字典）、Set（集合）、Sorted Set（有序集合）
   - String
   - ![String常用命令](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20093714.png)
   - List
   - ![List常用](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20094025.png)
   - Hash
   - ![Hash常用](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20094218.png)
   - Set
   - ![Set常用](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20094418.png)
   - Sorted Set
   - ![Sorted Set常用](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20094725.png)
   - 具体命令解释请查看官方文档http://www.redis.cn/commands.html

#### 什么是Jedis

- 在常见命令中，使用各种Redis自带客户端的命令行方式去访问Redis服务，而在实际工作中却需要用到Java代码才能访问，使用第三方jar包：Jedis。就能够方便的访问Redis的各种服务了
- 下面代码就是一个简单的Jedis应用，它取出了foo的值

```java
package redis;

import redis.clients.jedis.Jedis;

public class TestRedis {
	public static void main(String[] args) {
		Jedis jedis = new Jedis("localhost");
		jedis.set("foo", "bar");
		String value = jedis.get("foo");
		System.out.println(value);
	}

}
```
- Jedis的复杂操作代码

```java
package redis;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;

public class TestRedisManyCommands {

	JedisPool pool;
	Jedis jedis;
	@Before
	public void setup() {
		jedis = new Jedis("localhost");
	}
	
	/*
	 * Redis存储初级的字符串
	 * CRUD
	 */
	@Test
	public void testBasicString() {
		//添加数据
		jedis.set("name", "joker");
		System.out.println(jedis.get("name"));
		
		//修改数据
		jedis.append("name", "xiaoxian");
		System.out.println(jedis.get("name"));
		
		//直接覆盖原来的数据
		jedis.set("name", "zhangpeng");
		System.out.println(jedis.get("name"));
		
		//删除key对应的记录
		jedis.del("name");
		System.out.println(jedis.get("name"));
		
		//mset
		jedis.mset("name","joker","dota","poofu");
		System.out.println(jedis.mget("name","dota"));
	}
	
	/*
	 * Jedis操作Map
	 */
	@Test
	public void TestMap() {
		Map<String, String> user = new HashMap<>();
		user.put("name", "xiaoxian");
		user.put("pwd", "password");
		jedis.hmset("user",user);
		//取出user中的name，执行结果:[xiaoxian]。注意，结果是一个泛型的List
		//第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数
		List<String> rsmap = jedis.hmget("user", "name");
		System.out.println(rsmap);
		
		//删除map中的某个键值
		jedis.hdel("user", "pwd");
		System.out.println(jedis.hmget("user", "pwd"));//因为已被删除，所以返回的是null
		System.out.println(jedis.hlen("user"));//返回key为user的键中存放的值的个数1
		System.out.println(jedis.exists("user"));//是否存在key为user的记录，返回true
		System.out.println(jedis.hkeys("user"));//返回map对象中的所有key [name]
		System.out.println(jedis.hvals("user"));//返回map对象中的所有value [xiaoxian]
		
		Iterator<String> iter = jedis.hkeys("user").iterator();
		while(iter.hasNext()) {
			String key = iter.next();
			System.out.println(key+":"+jedis.hmget("user", key));
		}
	}
	
	/*
	 * Jedis操作List
	 */
	@Test
	public void TestList() {
		//开始前，先移除所有内容
		jedis.del("java framework");
		//第一个是key，第二个是起始位置，第三个是结束位置。jedis.llen获取长度，-1表示取得所有
		System.out.println(jedis.lrange("java framework", 0, -1));
		//先存放三条数据
		jedis.lpush("java framework", "spring");
		jedis.lpush("java framework", "struts2");
		jedis.lpush("java framework", "hibernate");
		//再取出所有数据。jedis.lrange是按范围取出
		//第一个是key，第二个是起始位置，第三个是结束位置。jedis.llen获取长度，-1表示取得所有
		System.out.println(jedis.lrange("java framework",0, -1));
	}
	
	/*
	 * Jedis操作Set
	 */
	@Test
	public void TestSet() {
		//添加
		jedis.sadd("sname", "zhangpeng");
		jedis.sadd("sname", "hushaung");
		jedis.sadd("sname", "zenghuanrui");
		jedis.sadd("sname", "joker");
		System.out.println(jedis.smembers("sname"));
		
		//移除joker
		jedis.srem("sname", "joker");
		System.out.println(jedis.smembers("sname"));//获取所有加入的value
		System.out.println(jedis.sismember("sname", "zhangpeng"));//判断zhangpeng是否是sname集合的元素
		System.out.println(jedis.srandmember("sname"));//随机返回集合sname中的一个元素
		System.out.println(jedis.scard("sname"));//返回集合的元素个数
	}
	
	@Test
	public void test() throws InterruptedException{
		//keys中传入的可以用通配符
		System.out.println(jedis.keys("*"));//返回当前库中的所有key
		System.out.println(jedis.keys("*name"));//返回[sname, name]
		jedis.del("list1");//删除key为list1的对象
		System.out.println(jedis.keys("*"));
		System.out.println(jedis.ttl("sname"));//返回给定key的有效时间，如果是-1则表示永远有效 
        jedis.setex("timekey", 10, "min");//通过此方法，可以指定key的存活（有效时间） 时间为秒 
        Thread.sleep(5000);//睡眠5秒后，剩余时间将为<=5 
        System.out.println(jedis.ttl("timekey"));   //输出结果为5 
        jedis.setex("timekey", 1, "min");        //设为1后，下面再看剩余时间就是1了 
        System.out.println(jedis.ttl("timekey"));  //输出结果为1 
        System.out.println(jedis.exists("key"));//检查key是否存在 
        System.out.println(jedis.rename("timekey","time")); 
        System.out.println(jedis.get("timekey"));//因为移除，返回为null 
        System.out.println(jedis.get("time")); //因为将timekey 重命名为time 所以可以取得值 min 
 
        //jedis 排序 
        //注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的） 
        jedis.del("a");//先清除数据，再加入数据进行测试 
        jedis.rpush("a", "1"); 
        jedis.lpush("a","6"); 
        jedis.lpush("a","3"); 
        jedis.lpush("a","9"); 
        System.out.println(jedis.lrange("a",0,-1));// [9, 3, 6, 1] 
        System.out.println(jedis.sort("a")); //[1, 3, 6, 9]  //输入排序后结果 
        System.out.println(jedis.lrange("a",0,-1)); 
	}
}
```

#### Spring Data Redis

- 项目结构
- ![项目结构](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-10-10%20113951.png)

- redis.properties

```
#ip地址
redis.hostName=127.0.0.1
#端口号
redis.port=6379
#如果有密码
redis.password=
#客户端超时时间单位是毫秒 默认是2000
redis.timeout=2000

#最大空闲数
redis.maxIdle=10
#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal
redis.maxActive=10
#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性
redis.maxTotal=10
#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。
redis.maxWaitMillis=1000
#连接的最小空闲时间 默认1800000毫秒(30分钟)
redis.minEvictableIdleTimeMillis=300000
#每次释放连接的最大数目,默认3
redis.numTestsPerEvictionRun=1024
#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
redis.timeBetweenEvictionRunsMillis=30000
#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个
redis.testOnBorrow=false
#在空闲时检查有效性, 默认false
redis.testWhileIdle=false
```

- applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"    
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"    
    xmlns:context="http://www.springframework.org/schema/context"    
    xmlns:mvc="http://www.springframework.org/schema/mvc"    
    xmlns:cache="http://www.springframework.org/schema/cache"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans      
                        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd      
                        http://www.springframework.org/schema/context      
                        http://www.springframework.org/schema/context/spring-context-4.2.xsd      
                        http://www.springframework.org/schema/mvc      
                        http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd  
                        http://www.springframework.org/schema/cache   
                        http://www.springframework.org/schema/cache/spring-cache-4.2.xsd">


	
	<!-- 加载配置文件 -->
	<context:property-placeholder location="classpath:*.properties" />
	<!-- redis连接池配置-->  
	<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig" >  
		<!--最大空闲数-->  
		<property name="maxIdle" value="${redis.maxIdle}" />  
        <!--连接池的最大数据库连接数  -->
    	<property name="maxTotal" value="${redis.maxTotal}" />
        <!--最大建立连接等待时间-->  
        <property name="maxWaitMillis" value="${redis.maxWaitMillis}" />  
        <!--逐出连接的最小空闲时间 默认1800000毫秒(30分钟)-->
        <property name="minEvictableIdleTimeMillis" value="${redis.minEvictableIdleTimeMillis}" /> 
        <!--每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3-->
        <property name="numTestsPerEvictionRun" value="${redis.numTestsPerEvictionRun}" /> 
        <!--逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1-->
        <property name="timeBetweenEvictionRunsMillis" value="${redis.timeBetweenEvictionRunsMillis}" /> 
        <!--是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个-->  
        <property name="testOnBorrow" value="${redis.testOnBorrow}" />  
        <!--在空闲时检查有效性, 默认false  -->
        <property name="testWhileIdle" value="${redis.testWhileIdle}" />  
    </bean >
    
    

    
	<!--redis连接工厂 -->
	<bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" destroy-method="destroy"> 
		<property name="poolConfig" ref="jedisPoolConfig"></property> 
		<!--IP地址 -->
		<property name="hostName" value="${redis.hostName}"></property> 
		<!--端口号  -->
		<property name="port" value="${redis.port}"></property> 
		<!--如果Redis设置有密码  -->
		<property name="password" value="${redis.password}" />
		<!--客户端超时时间单位是毫秒  -->
		<property name="timeout" value="${redis.timeout}"></property> 
	</bean>  
    
    <!--redis操作模版,使用该对象可以操作redis  -->
    <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" 
		p:connection-factory-ref="jedisConnectionFactory" >  
		<property name="keySerializer">
			<bean
				class="org.springframework.data.redis.serializer.StringRedisSerializer" />
		</property>
		<property name="hashKeySerializer">
			<bean
				class="org.springframework.data.redis.serializer.StringRedisSerializer" />
		</property>
		<property name="valueSerializer">
			<bean
				class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" />
		</property>
		<property name="hashValueSerializer">
			<bean
				class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" />
		</property>
    </bean >  
    
    <!--自定义redis工具类,在需要缓存的地方注入此类  -->
    <bean id="redisUtil" class="com.how2java.RedisUtil">
    	<property name="redisTemplate" ref="redisTemplate" />
    </bean>
	
</beans>
```

- RedisUtil.java

```java
package com.how2java;



import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;


import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.util.CollectionUtils;


/**
 * 基于spring和redis的redisTemplate工具类
 * 针对所有的hash 都是以h开头的方法
 * 针对所有的Set 都是以s开头的方法                    不含通用方法
 * 针对所有的List 都是以l开头的方法
 */
public class RedisUtil {
	private RedisTemplate<String, Object> redisTemplate;
	
	public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {
		this.redisTemplate = redisTemplate;
	}
	//=============================common============================
	/**
	 * 指定缓存失效时间
	 * @param key 键
	 * @param time 时间(秒)
	 * @return
	 */
	public boolean expire(String key,long time){
		try {
			if(time>0){
				redisTemplate.expire(key, time, TimeUnit.SECONDS);
			}
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * 根据key 获取过期时间
	 * @param key 键 不能为null
	 * @return 时间(秒) 返回0代表为永久有效
	 */
	public long getExpire(String key){
		return redisTemplate.getExpire(key,TimeUnit.SECONDS);
	}
	
	/**
	 * 判断key是否存在
	 * @param key 键
	 * @return true 存在 false不存在
	 */
	public boolean hasKey(String key){
		try {
			return redisTemplate.hasKey(key);
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * 删除缓存
	 * @param key 可以传一个值 或多个
	 */
	@SuppressWarnings("unchecked")
	public void del(String ... key){
		if(key!=null&&key.length>0){
			if(key.length==1){
				redisTemplate.delete(key[0]);
			}else{
				redisTemplate.delete(CollectionUtils.arrayToList(key));
			}
		}
	}
	
	//============================String=============================
	/**
	 * 普通缓存获取
	 * @param key 键
	 * @return 值
	 */
	public Object get(String key){
		return key==null?null:redisTemplate.opsForValue().get(key);
	}
	
	/**
	 * 普通缓存放入
	 * @param key 键
	 * @param value 值
	 * @return true成功 false失败
	 */
	public boolean set(String key,Object value) {
		 try {
			redisTemplate.opsForValue().set(key, value);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		
	}
	
	/**
	 * 普通缓存放入并设置时间
	 * @param key 键
	 * @param value 值
	 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
	 * @return true成功 false 失败
	 */
	public boolean set(String key,Object value,long time){
		try {
			if(time>0){
				redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
			}else{
				set(key, value);
			}
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * 递增
	 * @param key 键
	 * @param by 要增加几(大于0)
	 * @return
	 */
	public long incr(String key, long delta){  
		if(delta<0){
			throw new RuntimeException("递增因子必须大于0");
		}
		return redisTemplate.opsForValue().increment(key, delta);
    }
	
	/**
	 * 递减
	 * @param key 键
	 * @param by 要减少几(小于0)
	 * @return
	 */
	public long decr(String key, long delta){  
		if(delta<0){
			throw new RuntimeException("递减因子必须大于0");
		}
        return redisTemplate.opsForValue().increment(key, -delta);  
    }  
	
	//================================Map=================================
	/**
	 * HashGet
	 * @param key 键 不能为null
	 * @param item 项 不能为null
	 * @return 值
	 */
	public Object hget(String key,String item){
		return redisTemplate.opsForHash().get(key, item);
	}
	
	/**
	 * 获取hashKey对应的所有键值
	 * @param key 键
	 * @return 对应的多个键值
	 */
	public Map<Object,Object> hmget(String key){
		return redisTemplate.opsForHash().entries(key);
	}
	
	/**
	 * HashSet
	 * @param key 键
	 * @param map 对应多个键值
	 * @return true 成功 false 失败
	 */
	public boolean hmset(String key, Map<String,Object> map){  
        try {
			redisTemplate.opsForHash().putAll(key, map);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
    }
	
	/**
	 * HashSet 并设置时间
	 * @param key 键
	 * @param map 对应多个键值
	 * @param time 时间(秒)
	 * @return true成功 false失败
	 */
    public boolean hmset(String key, Map<String,Object> map, long time){  
        try {
			redisTemplate.opsForHash().putAll(key, map);
			if(time>0){
				expire(key, time);
			}
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
    }
	
	/**
	 * 向一张hash表中放入数据,如果不存在将创建
	 * @param key 键
	 * @param item 项
	 * @param value 值
	 * @return true 成功 false失败
	 */
	public boolean hset(String key,String item,Object value) {
		 try {
			redisTemplate.opsForHash().put(key, item, value);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * 向一张hash表中放入数据,如果不存在将创建
	 * @param key 键
	 * @param item 项
	 * @param value 值
	 * @param time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间
	 * @return true 成功 false失败
	 */
	public boolean hset(String key,String item,Object value,long time) {
		 try {
			redisTemplate.opsForHash().put(key, item, value);
			if(time>0){
				expire(key, time);
			}
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * 删除hash表中的值
	 * @param key 键 不能为null
	 * @param item 项 可以使多个 不能为null
	 */
    public void hdel(String key, Object... item){  
		redisTemplate.opsForHash().delete(key,item);
    } 
    
    /**
     * 判断hash表中是否有该项的值
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item){
		return redisTemplate.opsForHash().hasKey(key, item);
    } 
	
	/**
	 * hash递增 如果不存在,就会创建一个 并把新增后的值返回
	 * @param key 键
	 * @param item 项
	 * @param by 要增加几(大于0)
	 * @return
	 */
	public double hincr(String key, String item,double by){  
        return redisTemplate.opsForHash().increment(key, item, by);
    }
	
	/**
	 * hash递减
	 * @param key 键
	 * @param item 项
	 * @param by 要减少记(小于0)
	 * @return
	 */
	public double hdecr(String key, String item,double by){  
        return redisTemplate.opsForHash().increment(key, item,-by);  
    }  
	
	//============================set=============================
	/**
	 * 根据key获取Set中的所有值
	 * @param key 键
	 * @return
	 */
	public Set<Object> sGet(String key){
		try {
			return redisTemplate.opsForSet().members(key);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * 根据value从一个set中查询,是否存在
	 * @param key 键
	 * @param value 值
	 * @return true 存在 false不存在
	 */
	public boolean sHasKey(String key,Object value){
		try {
			return redisTemplate.opsForSet().isMember(key, value);
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
	}
	
	/**
	 * 将数据放入set缓存
	 * @param key 键
	 * @param values 值 可以是多个
	 * @return 成功个数
	 */
	public long sSet(String key, Object...values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
        	e.printStackTrace();
        	return 0;
        }
    }
	
	/**
	 * 将set数据放入缓存
	 * @param key 键
	 * @param time 时间(秒)
	 * @param values 值 可以是多个
	 * @return 成功个数
	 */
	public long sSetAndTime(String key,long time,Object...values) {
        try {
        	Long count = redisTemplate.opsForSet().add(key, values);
        	if(time>0) expire(key, time);
            return count;
        } catch (Exception e) {
        	e.printStackTrace();
        	return 0;
        }
    }
	
	/**
	 * 获取set缓存的长度
	 * @param key 键
	 * @return
	 */
	public long sGetSetSize(String key){
		try {
			return redisTemplate.opsForSet().size(key);
		} catch (Exception e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	/**
	 * 移除值为value的
	 * @param key 键
	 * @param values 值 可以是多个
	 * @return 移除的个数
	 */
	public long setRemove(String key, Object ...values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
        	e.printStackTrace();
        	return 0;
        }
    }
    //===============================list=================================
    
	/**
	 * 获取list缓存的内容
	 * @param key 键
	 * @param start 开始
	 * @param end 结束  0 到 -1代表所有值
	 * @return
	 */
	public List<Object> lGet(String key,long start, long end){
		try {
			return redisTemplate.opsForList().range(key, start, end);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * 获取list缓存的长度
	 * @param key 键
	 * @return
	 */
	public long lGetListSize(String key){
		try {
			return redisTemplate.opsForList().size(key);
		} catch (Exception e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	/**
	 * 通过索引 获取list中的值
	 * @param key 键
	 * @param index 索引  index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推
	 * @return
	 */
	public Object lGetIndex(String key,long index){
		try {
			return redisTemplate.opsForList().index(key, index);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * 将list放入缓存
	 * @param key 键
	 * @param value 值
	 * @param time 时间(秒)
	 * @return
	 */
	public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
        	e.printStackTrace();
        	return false;
        }
    }
	
	/**
	 * 将list放入缓存
	 * @param key 键
	 * @param value 值
	 * @param time 时间(秒)
	 * @return
	 */
	public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time > 0) expire(key, time);
            return true;
        } catch (Exception e) {
        	e.printStackTrace();
        	return false;
        }
    }
	
	/**
	 * 将list放入缓存
	 * @param key 键
	 * @param value 值
	 * @param time 时间(秒)
	 * @return
	 */
	public boolean lSet(String key, List<Object> value) {
	    try {
			redisTemplate.opsForList().rightPushAll(key, value);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
    }
	
	/**
	 * 将list放入缓存
	 * @param key 键
	 * @param value 值
	 * @param time 时间(秒)
	 * @return
	 */
	public boolean lSet(String key, List<Object> value, long time) {
	    try {
			redisTemplate.opsForList().rightPushAll(key, value);
			if (time > 0) expire(key, time);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
    }
	
	/**
	 * 根据索引修改list中的某条数据
	 * @param key 键
	 * @param index 索引
	 * @param value 值
	 * @return
	 */
	public boolean lUpdateIndex(String key, long index,Object value) {
	    try {
			redisTemplate.opsForList().set(key, index, value);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
    } 
	
	/**
	 * 移除N个值为value 
	 * @param key 键
	 * @param count 移除多少个
	 * @param value 值
	 * @return 移除的个数
	 */
	public long lRemove(String key,long count,Object value) {
		try {
			Long remove = redisTemplate.opsForList().remove(key, count, value);
			return remove;
		} catch (Exception e) {
			e.printStackTrace();
			return 0;
		}
	}
	
}
```

- TestRedis.java

```java
package com.how2java;

import java.util.HashMap;
import java.util.Map;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class TestRedis {
	
	public static void main(String[] args) throws Exception {
		ApplicationContext context=new ClassPathXmlApplicationContext("classpath:applicationContext.xml");

		RedisUtil redisUtil=(RedisUtil) context.getBean("redisUtil");
		
		//=====================testString======================
		redisUtil.set("name", "how2java");
		System.out.println(redisUtil.get("name"));
		redisUtil.del("name");
		System.out.println(redisUtil.get("name"));
		
		//=====================testNumber======================
		long incr = redisUtil.incr("number", 1);
		System.out.println(incr);
		incr =redisUtil.incr("number", 1);
		System.out.println(incr);
		
		//=====================testMap======================		
		Map<String,Object> map=new HashMap<>();
		map.put("name", "meepo");
		map.put("pwd", "password");
		redisUtil.hmset("user", map);
		System.out.println(redisUtil.hget("user","name"));
	}
	
}
```

#### RedisClient