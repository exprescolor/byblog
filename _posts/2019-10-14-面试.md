---
layout:     post 
title:      杂谈
subtitle:   面试
date:       2019-10-14
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.IPV4中数据包的传播方式有那些？

- 广播、单播、组播

#### 2.索引可以避免全盘扫描

#### 3.事务的原子性指的是什么？

- 事务中包括的所有操作要么都做，要么都不做。

#### 4.快速排序，堆排序，折半插入排序的时间复杂度为多少？

- O(nlog2n)

#### 5.软件工程定义？

- 软件工程是一种自顶向上分阶段实现的软件工程开发的方法。

#### 6.以下程序运行的结果为？

```java
public class Example extends Thread{
     @Override
     public void run(){
        try{
             Thread.sleep(1000);
             }catch (InterruptedException e){
             e.printStackTrace();
             }
             System.out.print("run");
     }
     public static void main(String[] args){
             Example example=new Example();
             example.run();
             System.out.print("main");
     }
}
```

- 结果为：run main
- Example这个类虽然继承了Thread类，但是并没有真正创建一个线程。创建一个线程需要覆盖Thread类的run方法，然后调用Thread类的start方法启动。
- 这里直接调用run方法并没有创建线程，跟普通方法一样，是顺序执行。

#### 7.Java中用正则表达式截取字符串中第一个出现的英文括号之前的字符串，比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式的写法为？

- 写法为：

```java
".*?(?=\\()"
```

- 正则表达式的贪婪匹配和非贪婪匹配
   - 如：`String str="abcaxc";Patter p="ab*c";`
   - 贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：`abcaxc(ab*c)`
   - 非贪婪匹配：就是匹配到结果就好，最少的匹配字符。如上面使用模式p进行匹配str，结果就是匹配到：`abc(ab*c)`
- 在编程中如何区分两种模式？
   - 默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。
      - 量词：{m,n}：m到n个
      - `*`：任意多个
      - +：一个到多个
      - ？：0个或一个
   - 对上题来说
      - .表示除\n之外的任意字符
      - `*`表示匹配0到无穷
      - +表示匹配1到无穷
      - (?=Expression)顺序环视，(?=\\()就是匹配正括号
   - 懒惰模式正则：
      - `src=".*?(?=\\()"`
   - 具体代码

```java
package Test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test02 {

	public static void main(String[] args) {
		String str = "北京市(海淀区)(朝阳区)(西城区)";
		 
	    String patStr = ".*?(?=\\()";
	     
	    Pattern pattern = Pattern.compile(patStr);
	     
	    Matcher matcher = pattern.matcher(str);
	     
	    if(matcher.find())
	    {
	        System.out.println(matcher.group(0));
	    }
	    else
	    {
	        System.out.println(matcher.group(0));
	    }
	}
}
```

   - 结果：北京市
   - 因为匹配到第一个"就结束了一次匹配，不会继续向后进行。

#### 8.ReadWriteLock适用于什么场景？

- ReadWriteLock适用于读多写少的并发场景
- CopyOnWriteArrayList适用于写少读多的并发场景

#### 9.以下程序的运行结果是什么？

```java
public class HelloSogou{
     public static synchronized void main(String[] a){
         Thread t=new Thread(){
             public void run(){Sogou();}
     };
     t.run();
     System.out.print("Hello");
     }
     static synchronized void Sogou(){
     System.out.print("Sogou");
    }
}
```

- 结果为：SogouHello
- 这里调用了`t.run();`。并没有启用一个新的线程，启动一个新的线程需要用`t.start();`
- 所以执行顺序是先执行`run()`，再执行`System.out.println("HELLO");`
- 如果`t.run();`换成了`t.start();`。那么结果应该是HelloSogou，因为main()方法和Sogou()方法都加了Synchronized同步锁，在main()方法结束（释放类锁）之前，Sougou()方法不会被执行。

#### 10.怎么实现GBK编码字节流到UTF-8编码字节流的转换？其中`byte[] src,dst;`

- 结果为：`dst=new String(src，"GBK").getBytes("UTF-8");`
- 操作步骤就是先解码再编码。
   - 用`new String(src,"GBK")`解码得到字符串
   - 用`getBytes("UTF-8")`得到UTF-8编码字节数组

#### 11.如下代码执行test()函数后，屏幕打印结果为？

```java
public class Test2
{
    public void add(Byte b)
    {
        b = b++;
    }
    public void test()
    {
        Byte a = 127;
        Byte b = 127;
        add(++a);
        System.out.print(a + " ");
        add(b);
        System.out.print(b + "");
    }
}
```

- 结果为：-128 127
- `public void add(Byte b){b=b++};`：b=b++在内存中主要有3步
   - 1.把变量b的值取出来，放在一个临时变量里（我们先记作tmp）；
   - 2.把变量b的值进行自加操作；
   - 3.把临时变量tmp的值作为自增运算前b的值使用，在本题中就是给变量b赋值。
- 由此我们可以知道add（）方法就是一个摆设，不会起到任何作用。
- Byte类型值大小为-128~127之间，add(++a)这里++a会越界，a的值变为-128。因为add()函数不起任何作用，所以b还是127。

#### 12.如下代码，假定str0，...,str4后序代码都是只读引用。Java7中，以如下代码为基础，在发生过一次Full GC后，如下代码在Heap空间（不包括PermGen）保留的字符数为多少？

```java
static String str0="0123456789";
static String str1="0123456789";
String str2=str1.substring(5);
String str3=new String(str2);
String str4=new String(str3.toCharArray());
str0=null;
```

- 结果为：15
- 垃圾回收主要针对的是堆区的回收，因为栈区的内存是随线程而释放的，堆区分为三个区：年轻代（Young Generation），年老代（Old Generation），永久代（Permanent Generation，也就是方法区）
   - 年轻代：对象被创建时（new）的对象通常被放在Young，经过一定的Minor GC（针对年轻代的内存回收），还活着的对象会被移动到年老代
   - 年老代：就是上述年轻代移动过来的和一些比较大的对象，Minor GC（Full GC）是针对年老代的回收
   - 永久代：存储的是final常量，static变量，常量池
- str3、str4都是直接new的对象，而subString其实也是new一个String对象返回，经过Full GC后，年老区的内存回收，则年轻区的占了15个，不算永久代，所以结果是15个。

#### 13.对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3，其最小内存值和Survivor区总大小分别是多少？

- 10240m；2048m
- -Xmx：最大堆大小；-Xms：初始堆大小；-Xmn:年轻代大小；-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值
- 年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。
- -Xms初始堆大小即最小内存值为10240m

#### Vector、StringBuffer、Properties类分别是线程安全的吗？

- 是

#### 实现或继承Collection接口的类包括哪些？

- ![示意图](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/458054_1441352361202_2B9A4774B9C5C489A9E9564854FFCD6C.jpg)