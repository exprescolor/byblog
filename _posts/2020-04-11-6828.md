---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partB(3)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-11 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

### 页面错误和内存保护

​		内存保护是操作系统的一个重要特性，可以确保一个程序中的错误不会破坏其他程序或破坏操作系统本身。

​		操作系统通常依赖于硬件支持来实现内存保护。操作系统让硬件知道哪些虚拟地址是有效的，哪些不是。当一个程序试图访问一个无效地址或一个它没有权限的地址时，处理器会在导致错误的指令处停止程序，然后将有关尝试操作的信息捕获到内核中。如果错误是可修复的，内核可以修复它并让程序继续运行。如果错误不可修复，则程序无法继续，因为它将永远无法通过导致错误的指令。

​		作为一个可修复错误的示例，考虑一个自动扩展堆栈。在许多系统中，内核最初分配一个堆栈页面，然后如果程序错误地访问了堆栈下面的页面，内核将自动分配这些页面，并让程序继续运行。通过这样做，内核只分配程序需要的堆栈内存，但是程序可以在拥有任意大的堆栈的假象下工作。

​		系统调用为内存保护带来了一个有趣的问题。大多数系统调用接口允许用户程序向内核传递指针。这些指针指向要读写的用户缓冲区。然后内核在执行系统调用时取消对这些指针的引用。这里有两个问题:

1. 内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核页面在操作自己的数据结构时出错，这就是内核错误，而错误处理程序应该使内核(以及整个系统)感到恐慌。但是，当内核取消引用用户程序给它的指针时，它需要一种方法来记住，这些取消引用导致的任何页面错误实际上都是代表用户程序的。
2. 内核通常比用户程序拥有更多的内存权限。用户程序可能会传递一个指向系统调用的指针，该系统调用指向内核可以读写但程序不能读写的内存。内核必须小心，不要被欺骗而取消对这样一个指针的引用，因为那样可能会暴露私有信息或破坏内核的完整性。

由于这两个原因，内核在处理用户程序提供的指针时必须非常小心。

​		现在，我们将使用一个机制来解决这两个问题，该机制检查从用户空间传递到内核的所有指针。当程序向内核传递一个指针时，内核将检查地址是否在地址空间的用户部分，并且页表将允许内存操作。

​		因此，内核将永远不会因为取消对用户提供的指针的引用而出现页面错误。如果内核发生了页面错误，那么它应该会终止。

### 练习9

修改kern/trap.c文件，使其能够实现：当在内核模式下发现页错，trap.c 文件会panic。

提示：

为了能够判断这个page fault是出现在内核模式下还是用户模式下，我们应该检查 tf_cs 的低几位。

阅读 user_mem_assert （在 kern/pmap.c），并且实现 user_mem_check;

修改一下 kern/syscall.c 去检查输入参数。

启动内核后，运行 user/buggyhello 程序，用户环境可以被销毁，内核不可以panic，你应该看到：

[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!

最后，将kern/kdebug.c中的debuginfo_eip更改为在usd、stabs和stabstr上调用user_mem_check。如果现在运行user/breakpoint，我们应该能够从内核监视器运行回溯，并在内核出现页面错误之前看到回溯遍历到lib/libmain.c。

题目要求我们要能够判断page fault是出现在内核模式还是用户模式，检查tf_cs的低几位，代码如下：

```c
void
page_fault_handler(struct Trapframe *tf)
{
	uint32_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if ((tf->tf_cs & 3) == 0) {    //根据 CS 段寄存器的低2位，这两位的名称叫做 CPL 位，表示当前运行的代码的访问权限级别，0代表是内核态，3代表是用户态。
        	panic("kernel page fault at:%x\n", fault_va);
    	}   
	// We've already handled kernel-mode exceptions, so if we get here,
	// the page fault happened in user mode.

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
		curenv->env_id, fault_va, tf->tf_eip);
	print_trapframe(tf);
	env_destroy(curenv);
}
```

user_mem_check 函数的功能是检查一下当前用户态程序是否有对虚拟地址空间 [va, va+len] 的 perm| PTE_P 访问权限。

我们要先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项，然后再去看一下这个页表项中有关访问权限的字段，是否包含 perm | PTE_P，只要有一个页表项是不包含的，就代表程序对这个范围的虚拟地址没有 perm|PTE_P 的访问权限。

```c
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
    uint32_t begin = (uint32_t)ROUNDDOWN(va, PGSIZE), end = (uint32_t)ROUNDUP(va + len, PGSIZE);
    int check_perm = (perm | PTE_P);
    uint32_t check_va = (uint32_t)va;

    for (; begin < end; begin += PGSIZE) {
        pte_t *pte = pgdir_walk(env->env_pgdir, (void *)begin, 0);
        if ((begin >= ULIM) || !pte || (*pte & check_perm) != check_perm) {  //具体检测规则
            user_mem_check_addr = (begin >= check_va ? begin : check_va);  //记录无效的那个线性地址
            return -E_FAULT;
        }    
    }    

    return 0;
}
```

我们还要补全 kern/syscall.c 文件中的一部分内容，即 sys_cputs 函数，这个函数要求检查用户程序对虚拟地指空间 [s, s+len] 是否有访问权限，所以我们恰好可以使用刚刚写好的函数 user_mem_assert() 来实现。

```c
static void
sys_cputs(const char *s, size_t len)
{
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, s, len, 0);
	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
}
```

完成代码之后：

```
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
Incoming TRAP frame at 0xefffffbc
hello, world
Incoming TRAP frame at 0xefffffbc
i am environment 00001000
Incoming TRAP frame at 0xefffffbc
[00001000] exiting gracefully
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
```

这也是练习10的输出。