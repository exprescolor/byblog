---
layout:     post                        # 使用的布局（不需要改）
title:      数据库设计实战学习笔记(五)              # 标题
subtitle:   常见问题与企业级解决(二)  # 副标题
date:       2020-05-26                  # 时间
author:     AhogeK                      # 作者
header-img:  https://tr3.cbsistatic.com/hub/i/r/2016/08/02/ffb48ac0-b355-4aec-b814-04c79e1e1bfd/resize/1200x/292c4adbf288356b843876804b244d69/mysqlhero.jpg    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - MySQL
    - 慕课学习笔记
---
### 数据库缓存、程序缓存应该选择哪个?
#### 为什么要缓存数据？
![ram](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-27%2016-27-01.png)

#### 数据库性能
* MySQL每秒可以处理5000千次读取，或者3000次写入
* 响应时间通常在10ms以内，但在1万并发的时候，要保证10ms以内的响应速度，任何数据库都做不到
  * ![howram](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-27%2016-30-35.png)

#### 数据库缓存
* MySQL缓存是KV结构的，Key是执行过的SQL语句，Value是查询的结果
* 如果执行添加、修改、删除，或者修改表结构，都会造成缓存清空
  * ![ramkv](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-27%2016-33-28.png)

#### 数据查询过程
* 执行SQL语句，MySQL先查询缓存。命中数据，就从缓存提取数据；没有命中，就从数据库中查询数据。
  * ![process](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-27%2016-36-03.png)

#### 数据库缓存注意事项
* 所有对数据加锁的事务中，不会使用查询缓存
  * $$ 事务\left\{
	\begin{aligned}
	UPDATE \\
	SELECT \\  
	\end{aligned}
	\right.
	$$   **SELECT 不使用缓存**
* 查询语句必须一模一样，才有机会命中缓存

#### 那么该不该使用数据库缓存呢？
* MySQL 8.0去除了查询缓存，Oracle官方也不推荐使用查询缓存
  * ``SHOW VARIABLES LIKE '%query_cache%';``
* 当MySQL缓存了很多结果的时候，一条更新语句就会让缓存全部作废，这严重的加重了内存管理的负担

#### 程序缓存的优势
* Redis、Memcashed这些缓存产品，结合Spring框架，在程序中可以细颗粒度，设置那些查询需要缓存，那些查询不用缓存
  * ![redis](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-27%2016-54-51.png)

#### SpringCache技术
* 方法声明加上``@Cacheable``注解，该方法执行的时候，Spring先查找缓存，根据命中的情况决定返回缓存，还是查询数据库
  * ```java
	@Cacheable("Cache1")
	public User get(Long id) {
		// 执行查询
		// 返回的结果会被缓存
		return User对象;
	}
	```
* 给方法声明前面加上@CacheEvict，Spring执行完数据库操作后，删除缓存记录
  * ```java
	@CacheEvict(value="Cache1")
	public void delete(Long id) {
		// 执行删除操作
	}
	```

### 新零售系统的智能拆分订单
#### 就进发货的难题
![Inbound&Outbound](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-27%2017-27-18.png)

#### 注册高德地图开发者
[高德地图开发者个人注册](https://lbs.amap.com/dev/id/choose)

#### 创建地图应用程序
* 我们需要先创建一个应用，才能使用高德地图API服务

#### 引入hutool依赖包
* Hutool是Java里面一个工具集合的依赖包，可以使用它的网络类，发送请求，查询地理坐标
  * ```xml
	<!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all -->
	<dependency>
		<groupId>cn.hutool</groupId>
		<artifactId>hutool-all</artifactId>
		<version>5.3.5</version>
	</dependency>
	``` 
  * ```java
	public class Demo1 {
		public static void main(String[] args) {
			HashMap<String, Object> map = new HashMap<String, Object>();
			map.put("key", "70e96c0a20b757e2cdb9913cf50a905a");
			map.put("address", "营口市盼盼工业园");
			String resp = HttpUtil.get("https://restapi.amap.com/v3/geocode/geo", map);
			System.out.println(resp);
			JSON json = JSONUtil.parse(resp);
			String location = json.getByPath("geocodes[0].location", String.class);
			String lng = location.split(",")[0];
			String lat = location.split(",")[1];
			System.out.println(lng);
			System.out.println(lat);
		}
	}
	```

#### 利用MySQL计算两点之间距离
* st_distance函数可以计算两个坐标之间相差的度数
  * ```sql
	SELECT st_distance(
		point(116.414042,39.92556),
		point(121.486864,31.232965)
	)*111195/1000;
	```
  * ```sql
  	SELECT
		id,address,
		st_distance(
			point(122.268278,40.731062),
			point(lng,lat)
		)*111195/1000 AS distance
	FROM t_warehouse
	ORDER BY distance
	LIMIT 1;
	```
  * ```sql
	SELECT
		t.id
	FROM
		(SELECT
			id,
			st_distance(
				point(122.268278,40.731062),
				point(lng,lat)
			)*111195/1000 AS distance
		FROM t_warehouse
		ORDER BY distance
		LIMIT 1) t
	JOIN t_warehouse_sku ws ON ws.warehouse_id=t.id
	AND ws.sku_id=1 AND ws.num>=1;
	```
  * ```sql
	JOIN t_warehouse_sku ws ON ws.warehouse_id=t.id
	AND ws.sku_id=1 AND ws.num>=1;
	```

### 中文分词技术
#### 为什么要做中文分词
* 中文是一种十分复杂的语言，让计算机理解中文语言更是困难

#### MySQL的全文索引
* MySQL的全文检索功能，既支持英文和中文
* MySQL全文检索对英文支持很好，但是对中文支持的不好。不能按照语义切词，只能按照字符切词

#### 创建全文索引
* 给SKU数据表的title字段添加全文索引功能

#### 执行全文检索查询
* 全文检索的条件写在WHERE子句中
  * ```sql
  	SELECT id, title, images, price
	FROM t_sku
	WHERE MATCH(title) AGAINST("小米9"); 
	```

#### 全文索引的弊病
* 中文字段创建全文索引，切词结果太多，占用大量存储空间
* 更新字段内容，全文索引不会更新，必须定期手动维护
* 在数据库集群中维护全文索引难度很大

#### 使用专业的全文检索引擎
* Lucene是Apache基金会的开源全文检索引擎，支持中文分词

##### 配置依赖文件
```xml
<!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-core -->
<dependency>
    <groupId>org.apache.lucene</groupId>
    <artifactId>lucene-core</artifactId>
    <version>8.5.1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-analyzers-common -->
<dependency>
    <groupId>org.apache.lucene</groupId>
    <artifactId>lucene-analyzers-common</artifactId>
    <version>8.5.1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.lucene/lucene-queryparser -->
<dependency>
    <groupId>org.apache.lucene</groupId>
    <artifactId>lucene-queryparser</artifactId>
    <version>8.5.1</version>
</dependency>
```

#### 引入第三方中文分词插件
* Lucene自带的中文分词插件功能较弱，需要引入第三方中文分词插件，对中文内容准确分词
[体验网站](http://hanlp.com/)

##### 配置依赖文件
```xml
<!-- https://mvnrepository.com/artifact/com.hankcs/hanlp -->
<dependency>
    <groupId>com.hankcs</groupId>
    <artifactId>hanlp</artifactId>
    <version>portable-1.7.7</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.hankcs.nlp/hanlp-lucene-plugin -->
<dependency>
    <groupId>com.hankcs.nlp</groupId>
    <artifactId>hanlp-lucene-plugin</artifactId>
    <version>1.1.7</version>
</dependency>
```

#### 创建Lucene索引
```java
// 创建存储目录
Directory directory = FSDirectory.open(new File("D:/123").toPath());
// 创建中文分词分析器
Analyzer analyzer = new HanLPAnalyzer();
// 创建索引配置对象
IndexWriterConfig indexWriterConfig = new IndexWriterConfig(analyzer);
// 创建索引写入器
IndexWriter indexWriter = new IndexWriter(directory, indexWriterConfig);

Document doc = new Document();
doc.add(new TextField("id", 1, Field.Store.YES));
doc.add(new TeextField("title", "小米9手机", Field.Store.YES));
indexWriter.addDocument(doc);
con.close();
```

```java
public class Demo1 {
	public static void main(String[] args) {
		try (Directory directory = FSDirectory.open(
				new File("/home/ahogek/eclipse-workspace/serialnumber/index").toPath())) {
			Analyzer analyzer = new HanLPAnalyzer();
			IndexWriterConfig config = new IndexWriterConfig(analyzer);
			IndexWriter writer = new IndexWriter(directory, config);
			DriverManager.registerDriver(new Driver());
			String url = "jdbc:mysql://192.168.50.228/neti?serverTimezone=GMT%2B8";
			String username = "root";
			String password = "123456";
			Connection con = DriverManager.getConnection(url, username, password);
			String sql = "SELECT id, title FROM t_sku";
			PreparedStatement pst = con.prepareStatement(sql);
			ResultSet set = pst.executeQuery();
			while(set.next()) {
				String id = set.getString("id");
				String title = set.getString("title");
				Document document = new Document();
				document.add(new TextField("id", id, Field.Store.YES));
				document.add(new TextField("title", title, Field.Store.YES));
				writer.addDocument(document);
			}
			con.close();
			writer.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

#### 全文检索
```java
// 打开索引目录
Directory directory = FSDirectory.open(Paths.get("D:/123"));
// 索引阅读器
IndexReader r = DirectoryReader.open(directory);
// 索引扫描器
IndexSearcher indexSearcher = new IndexSearcher(r);
// 需要搜索的内容
String parStr = "我想要苹果手机";
// 搜索字段的名称
String defaultField = "title";
// 中文分词器
Analyzer analyzer = new HanLPAnalyzer();
// 查询解析器
QueryParser queryParser = new QueryParser(defaultField, analyzer);
// 解析搜索
Query query = queryParser.parse(parStr);
TopDocs topDocs = indexSearcher.search(query, 100);
System.out.println("总命中数: " + topDocs.totalHits);
// 读取搜索到的内容
ScoreDoc[] scoreDocs = topDocs.scoreDocs;
for (ScoreDoc scoreDoc : scoreDocs) {
	Document document = indexSearcher.doc(scoreDoc.doc);
	System.out.println("id -> " + document.get("id"));
	System.out.println("title -> " + document.get("title"));
}
```

#### Lucene注意事项
* 不是所有数据表的记录,都要保存到Lucene上面.只对需要全文检索的字段使用Lucene即可

#### Lucene与MySQL的结合
![Lucene&MySQL](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-28%2003-13-23.png)