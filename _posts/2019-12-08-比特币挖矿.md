---
layout:     post 
title:      区块链
subtitle:   比特币挖矿、比特币脚本
date:       2019-12-08
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 区块链
---

#### 知识总结

- 1.比特币中存在两种节点：全节点、轻节点
   - **全节点**：
      - 1.一直在线
      - 2.在本地硬盘上维护完整的区块链信息
      - 3.在内存里维护UTXO集合，以便快速检验交易的正确性
      - 4.监听比特币网络上的交易信息，验证每个交易的合法性
      - 5.决定哪些交易会被打包进区块。缺省状况下，只要是合法的交易，并且交易费符合要求，就会被打包到区块中。
      - 6.监听别的矿工挖出来的区块，验证其合法性。从3个方面进行验证
         - 1.这个区块中的每个交易都要合法，包括铸币交易（有没有篡改block reward）
         - 2.发布的区块是不是符合难度要求的，通俗的来说，就是检查以下block header取哈希值之后，前面有没有足够多的0，同时也要检查一下block header里面难度目标域值设置是不是正确的，然后这个全节点还要按照比特币协议的要求每两周调整挖矿难度
         - 3. 检查这个区块是在延伸最长合法链
      - 7.挖矿
         - 决定沿着哪条链挖下去？
            - 缺省状况下，应该是沿着最长合法链挖下去
         - 当出现等长的分叉的时候，选择哪一条分叉？
            - 缺省情况下，选择的是最先监听到的那一个分叉
   - **轻节点**：
      - 1.不是一直在线
      - 2.不用保存整个区块链，只要保存每个区块的块头（大小和全节点相比差了1000倍）
      - 3.不用保存全部交易，只要保存与自己相关的交易
      - 4.无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性
      - 5.无法检测网上发布的区块的正确性
      - 6.可以验证挖矿的难度。因为挖矿的时候计算哈希值只用到了块头的信息，而块头的信息轻节点是保留的
      - 7.只能检测哪一个是最长链，但是不知道哪一个是最长合法链
   - **比特币的安全性保证**
      - 比特币的安全性是由两方面来保证的：
         - 一方面是密码学上的保证（别人没有你的私钥，就没有办法伪造你的签名，所以也就不能把你账户上的钱转走）
         - 另一方面是共识机制

#### 挖矿设备

- **挖矿设备的演变趋势是越来越专业化**
   - 最早的时候大家使用的是普通的PC，也就是CPU来进行挖矿操作。但是这样是很不划算的，因为计算机中的大部分内存都是闲置的，挖矿只用到其中很小的一部分内存；CPU当中的大部分部件也是闲置的，因为挖矿当中的计算哈希值操作只用到了通用CPU中的很少的一部分指令；硬盘和其他很多资源也都是闲置的。所以随着比特币挖矿难度的提高，用普通CPU挖矿就变得不具备性价比。
   - 后来就开始采用GPU挖矿。GPU主要用于大规模的并行计算。但是利用GPU也会有很多浪费，因为GPU是为了通用并行计算而设计的，用来挖矿的话它里面很多部件仍是处于闲置状态的，比如说用于浮点数运算的那些部件
   - 现在一般使用ASIC芯片进行挖矿操作（Application Specific Integrated Circuit）。整个芯片就是为了挖矿而设计的，没有多余的操作。为一种加密货币设计的ASIC芯片只能用于这一种加密货币的挖矿操作，其他加密货币不能用，除非这两种加密货币用的是同一个mining puzzle
- **挖矿的另一个趋势是大型矿池的出现，这样减轻了矿工的负担，收益也更加的稳定，但是也使发动51%攻击更容易了**
   - 一个矿池一般有一个矿主（pool manager）和许多矿工（miner），矿主连接着许多矿工，矿工只负责计算哈希值的操作，而全节点的其他职责都由这个矿主来承担
   - 某个矿工挖矿成功之后，会把出块奖励进行分配，分配的原则是：
      - 比如说现在挖矿的要求是前面必须有70个0，这时候矿主就会向下另外发一个降低难度的请求，只需要挖到前面有60个0即可，这样挖到的叫做一个share，当下面的矿工每挖到符合难度要求的share后，就会提交给矿主，提交的这个share叫做almost valid block。矿主就会把提交的share作为证明这个矿工工作量的数据，在挖矿成功之后，按照工作量进行分配奖励
      - 这样就有一个问题：会不会有的矿工在挖到符合条件的区块后不提交给矿主，而是自己发布出去；当找到符合矿主条件的share之后，把他提交给矿主。相当于自己独吞出块奖励？
         - 这样是不可能做到的。因为每个矿工的任务是由矿主来分配的，矿主负责组装好一个区块，然后交给矿工去尝试各种各样的nonce。而且在coinbase transaction里面包含一个收款人的地址，这个地址是矿主的地址，所以矿工挖到区块之后，如果他不提交给矿主，他自己发布出去是没有用的，里面的收款地址是矿主的，他取不出来钱。
- 矿池在各个国家的分布比例
- ![](https://vi2.xiu123.cn/live/2019/12/08/13/1003v1575781769101889269.jpg)
- 当一个攻击者的算力超过了51%，那么他就可以做分叉攻击或者封锁境域攻击（boycott）

#### 比特币脚本 

- **一个交易实例**
- ![](https://vi1.xiu123.cn/live/2019/12/08/13/1003v1575782629221257121.jpg)
- **上图交易结构**
- ![](https://vi0.xiu123.cn/live/2019/12/08/13/1003v1575782694712830125.jpg)
   - locktime：用来设定交易的生效时间，现在是0，也就是立即生效
   - blockhash：当前交易所在的区块的哈希值
   - confirmations：当前交易有多少个确认信息
   - time：当前交易产生的时间
   - block time：当前交易所在的区块产生的时间
- **交易的输入结构**
- ![](https://vi3.xiu123.cn/live/2019/12/08/13/1003v1575782908581353622.jpg)
   - txid：当前交易的比特币是之前哪一个交易的输出，并把之前的交易取哈希
   - vout：表示当前交易的比特币是之前交易里面的第几个输出
   - scriptSig：输入脚本
- **交易的输出结构**
- ![](https://vi1.xiu123.cn/live/2019/12/08/13/1003v1575783147649958855.jpg)
   - value：输出的金额，也就是给对方的比特币金额
   - n：序号，代表这是这笔交易里面的第几个输出
   - scriptPubKey：输出脚本
   - reqSigs：当前输出需要多少个签名才能够兑现
   - type：输出的类型。例子中的是pubkeyhash：公钥的哈希
   - address：输出的地址
- **脚本的执行流程**
- ![](https://vi3.xiu123.cn/live/2019/12/08/13/1003v1575783407037231182.jpg)
- **验证交易是否合法的操作**
- ![](https://vi1.xiu123.cn/live/2019/12/08/13/1003v1575783910985064112.jpg)
   - 把上一个交易的输出脚本和当前交易的输入脚本组合在一起执行，如果没有报错，那么交易就是合法的。
   - 现在使用的方法分别执行这两个脚本，先执行输入脚本，如果没有出错，那么再执行输出脚本，如果能顺利执行，最后栈顶的结果是非零值，也就是true，则代表交易是合法的。
   - 如果一个交易有多个输入的话，那么每个输入脚本都要和所对应的交易的输出脚本匹配之后来进行验证，全都验证通过，这个交易才是合法的
- **输入输出脚本的几种形式**
   - **1.第一种形式**：![第一种形式](https://vi0.xiu123.cn/live/2019/12/08/13/1003v1575784197888637371.jpg)
      - 输出脚本里直接给出收款人的公钥，第二行的checksig是检查签名的操作
      - 输入脚本中直接给出签名即可（这个签名是用私钥对这个输入脚本所在的整个交易的签名）
      - 脚本执行过程：
         - 1.把输入脚本里面提供的签名压入栈
         - 2.把输出脚本里面提供的公钥压入栈
         - 3.把栈顶的这两个元素弹出，用公钥检查签名是否正确。
         - 4.如果正确的话，返回true，说明验证通过
      - 实例：
      - ![](https://vi0.xiu123.cn/live/2019/12/08/13/1003v1575784505943730756.jpg)
   - **2.第二种形式**：![第二种形式](https://vi2.xiu123.cn/live/2019/12/08/13/1003v1575784580307066196.jpg)
      - 和上面的方法的区别是输出脚本里面没有直接给出收款人的公钥，给出的是公钥的哈希，公钥是在输入脚本里面给出的。输入脚本既要给出签名，也要给出公钥。输出脚本里的DUP、HASH160是为了验证签名的正确性
      - 这种形式是最常用的形式
      - 脚本执行：
      - ![](https://vi2.xiu123.cn/live/2019/12/08/13/1003v1575784778162171235.jpg)
         - 前两条语句来自输入脚本，后面的语句来自输出脚本
         - 1.把签名压入栈
         - 2.把公钥压入栈
         - 3.把栈顶的元素复制一遍（所以栈顶又多了一个公钥）
         - 4.把栈顶元素弹出来，取哈希，然后把得到的哈希值再压入栈（所以栈顶变成了公钥的哈希值）
         - 5.把输出脚本里提供的公钥的哈希值压入栈（栈顶现在是输出脚本里的收款人的公钥的哈希值）
         - 6.弹出栈顶的两个元素，比较他们是否相等（防止有人冒名顶替，用他自己的公钥替换别人的公钥）
         - 7.弹出栈顶的两个元素，用公钥检查签名是否正确
      - 实例：
      - ![](https://vi1.xiu123.cn/live/2019/12/08/14/1003v1575785111279044523.jpg)
   - **3.第三种形式**：![第三种形式](https://vi2.xiu123.cn/live/2019/12/08/14/1003v1575785191110969366.jpg)
      - 输出脚本提供的不是公钥的哈希，而是收款人提供的一个脚本的哈希，这个脚本叫做redeemScript（赎回脚本）
      - ![](https://vi0.xiu123.cn/live/2019/12/08/14/1003v1575785296501990723.jpg)
      - 实例：用P2SH实现P2PK
      - ![](https://vi2.xiu123.cn/live/2019/12/08/14/1003v1575785368897737892.jpg)
         - 输入脚本：签名、序列化的赎回脚本
         - 赎回脚本：公钥，并用checksig检查签名
         - 输出脚本：用来验证输入脚本里面给出的赎回脚本是否正确
      - 第一阶段的验证：
         - ![](https://vi1.xiu123.cn/live/2019/12/08/14/1003v1575785513357455503.jpg)
         - 前两行来自输入脚本，后面来自输出脚本
            - 把输入脚本的sig压入栈
            - 把序列化的赎回脚本压入栈
            - 对赎回脚本进行取哈希操作
            - 把输出脚本中给出的哈希值压入栈
            - 用equal比较压入栈的两个哈希值是否相等。如果相等，那么这两个哈希值就从栈顶消失。第一阶段的验证就结束了
      - 第二个阶段的验证：
         - ![](https://vi0.xiu123.cn/live/2019/12/08/14/1003v1575785836058934316.jpg)
            - 首先把输入脚本提供的序列化的赎回脚本进行反序列化，这是每个节点进行的操作，脚本中不显示
            - 把公钥压入栈
            - 同checksig检测一下输入脚本里给出的sig的正确性
            - 验证完成之后，整个P2SH才算执行完成
   - **多重签名**
      - 比特币系统中一个输出可能需要多个签名才能把钱取出来。比如某个公司的账户，需要5个合伙人中至少3个人的签名才能把账户中的钱取走。这样就为私钥的泄露提供了一些安全的保护。 
      - 脚本示例
      - ![](https://vi0.xiu123.cn/live/2019/12/08/14/1003v1575786644965020240.jpg)
         - 多重签名是通过checkmultisig实现的，也就是上图的最后一行
            - 输出脚本里给出n个公钥，同时指定一个域值m。输入脚本只需要提供这n个公钥对应的签名中任意m个合法的签名就能通过验证
            - 输入脚本的第一行有一个红色的叉子，他是因为比特币中checkmultisig的实现有一个bug，执行的时候会从堆栈上多弹出一个元素，这个bug现在已经没有办法改了，因为这是个去中心化的系统，如果想通过软件升级的方法去修复这个bug，这个代价是很大的，需要硬分叉。所以实际采用的方案是在输入脚本里往栈上多加进去一个没有用的元素。第一行这个红叉就代表这个没用的元素。
            - 给出的这m个签名的相对顺序，要和他们在n个公钥中的相对顺序是一致的才行
      - 脚本的执行过程
      - ![](https://vi0.xiu123.cn/live/2019/12/08/14/1003v1575787093112128893.jpg)
         - 这个例子中假设三个签名中给出两个就行，而且可以看出这两个签名给出的相对顺序也是和他们在公钥中的相对顺序是一样的
         - 前三行是输入脚本，剩下的为输出脚本
         - 1.第一行的false，就是我们说的多余的元素，首先把他给压入栈
         - 2.把两个签名依次压入栈
         - 3.把m的值压入栈
         - 4.把三个公钥压入栈
         - 5.把n的值压入栈
         - 6.最后执行checkmultisig，查看这个堆栈里是不是包含了这三个签名中的两个。如果是的话，验证通过。
      - 这种方法对于用户在购物的时候很不方便，因为用户需要填写他购买商品网站所提供的公钥中的其中几个才能通过验证。这就给用户生成转账交易带来一些不方便的地方。**这时候我们就可以用P2SH实现多重签名**
   - **用P2SH实现多重签名**
   - 示例：
   - ![](https://vi1.xiu123.cn/live/2019/12/08/14/1003v1575787554846820739.jpg)
   - 他的本质是把复杂度从输出脚本转移到了输入脚本，输出脚本只需要给出赎回脚本的哈希值即可。
   - 赎回脚本中要给出n个公钥，还有n和m的值。赎回脚本是在输入脚本里面提供的。也就是说是由收款人提供的。这样电商只需要在网站上公布这个赎回脚本的哈希值，然后用户生成转账交易的时候，把这个哈希值包含在输出脚本里就可以了。至于这个电商用什么样的多重签名规则，对用户来说是不可见的，用户没必要知道
   - 输入脚本是电商在花掉这笔输出的时候提供的，其中包含这个赎回脚本的序列化版本，同时还包含让这个赎回脚本验证通过所需要的m个签名。将来如果这个电商改变了所使用的多重签名规则，那么只需要改变这个输入脚本和赎回脚本里的内容，然后把新的哈希值公布出去就可以了。对用户来说，只不过是付款的时候要包含的哈希值发生了变化 
   - 脚本执行过程：
   - 第一阶段
      - 输入脚本为前四行，后面为输出脚本
      - ![](https://vi2.xiu123.cn/live/2019/12/08/14/1003v1575788148833459379.jpg)
      - 1.把多余的元素压入栈
      - 2.依次把两个签名压入栈
      - 3.把序列化的赎回脚本压入栈
      - 4.把赎回脚本取哈希
      - 5.把输出脚本里提供的哈希值压入栈
      - 6.判断这两个哈希值是否相等。这样第一阶段就完成了
   - 第二阶段：
   - 把赎回脚本展开后执行
   - ![](https://vi0.xiu123.cn/live/2019/12/08/14/1003v1575788373930617273.jpg)
      - 1.把m压入栈
      - 2.把三个公钥压入栈
      - 3.把n压入栈
      - 4.检查多重签名的正确性
   - 实例：
   - ![](https://vi2.xiu123.cn/live/2019/12/08/15/1003v1575788495675814800.jpg)
   - **4.第四种形式**：![第四种形式](https://vi1.xiu123.cn/live/2019/12/08/15/1003v1575788551781975024.jpg)
      - 这个脚本是销毁比特币的一种方法。
         - 销毁比特币的两个应用场景：
         - 1.有些小的币种，要求销毁一定数量的比特币，才能够得到这个币种。这种小币种叫做AltCoin（Alternative Coin）。除了比特币之外的其他小的加密货币都可以认为是AltCoin
         - 2.往区块链中写入一些内容。区块链是一个不可篡改的账本，有人就利用这种特性往里面添加一些需要永久保存的内容。
      - 任何用户都可以用这种方法销毁比特币，来换取往区块链中写入一些数据的机会
      - 这种脚本的好处是矿工看到这种脚本的时候，知道它里面的输出永远不可能兑现，所以就没有必要把他保存在UTXO里面，这样对全节点是比较友好的。