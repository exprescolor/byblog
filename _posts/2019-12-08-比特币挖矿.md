---
layout:     post 
title:      区块链
subtitle:   比特币挖矿、比特币脚本
date:       2019-12-08
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 区块链
---

#### 知识总结

- 1.比特币中存在两种节点：全节点、轻节点
   - **全节点**：
      - 1.一直在线
      - 2.在本地硬盘上维护完整的区块链信息
      - 3.在内存里维护UTXO集合，以便快速检验交易的正确性
      - 4.监听比特币网络上的交易信息，验证每个交易的合法性
      - 5.决定哪些交易会被打包进区块。缺省状况下，只要是合法的交易，并且交易费符合要求，就会被打包到区块中。
      - 6.监听别的矿工挖出来的区块，验证其合法性。从3个方面进行验证
         - 1.这个区块中的每个交易都要合法，包括铸币交易（有没有篡改block reward）
         - 2.发布的区块是不是符合难度要求的，通俗的来说，就是检查以下block header取哈希值之后，前面有没有足够多的0，同时也要检查一下block header里面难度目标域值设置是不是正确的，然后这个全节点还要按照比特币协议的要求每两周调整挖矿难度
         - 3. 检查这个区块是在延伸最长合法链
      - 7.挖矿
         - 决定沿着哪条链挖下去？
            - 缺省状况下，应该是沿着最长合法链挖下去
         - 当出现等长的分叉的时候，选择哪一条分叉？
            - 缺省情况下，选择的是最先监听到的那一个分叉
   - **轻节点**：
      - 1.不是一直在线
      - 2.不用保存整个区块链，只要保存每个区块的块头（大小和全节点相比差了1000倍）
      - 3.不用保存全部交易，只要保存与自己相关的交易
      - 4.无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性
      - 5.无法检测网上发布的区块的正确性
      - 6.可以验证挖矿的难度。因为挖矿的时候计算哈希值只用到了块头的信息，而块头的信息轻节点是保留的
      - 7.只能检测哪一个是最长链，但是不知道哪一个是最长合法链
   - **比特币的安全性保证**
      - 比特币的安全性是由两方面来保证的：
         - 一方面是密码学上的保证（别人没有你的私钥，就没有办法伪造你的签名，所以也就不能把你账户上的钱转走）
         - 另一方面是共识机制

#### 挖矿设备

- **挖矿设备的演变趋势是越来越专业化**
   - 最早的时候大家使用的是普通的PC，也就是CPU来进行挖矿操作。但是这样是很不划算的，因为计算机中的大部分内存都是闲置的，挖矿只用到其中很小的一部分内存；CPU当中的大部分部件也是闲置的，因为挖矿当中的计算哈希值操作只用到了通用CPU中的很少的一部分指令；硬盘和其他很多资源也都是闲置的。所以随着比特币挖矿难度的提高，用普通CPU挖矿就变得不具备性价比。
   - 后来就开始采用GPU挖矿。GPU主要用于大规模的并行计算。但是利用GPU也会有很多浪费，因为GPU是为了通用并行计算而设计的，用来挖矿的话它里面很多部件仍是处于闲置状态的，比如说用于浮点数运算的那些部件
   - 现在一般使用ASIC芯片进行挖矿操作（Application Specific Integrated Circuit）。整个芯片就是为了挖矿而设计的，没有多余的操作。为一种加密货币设计的ASIC芯片只能用于这一种加密货币的挖矿操作，其他加密货币不能用，除非这两种加密货币用的是同一个mining puzzle
- **挖矿的另一个趋势是大型矿池的出现，这样减轻了矿工的负担，收益也更加的稳定，但是也使发动51%攻击更容易了**
   - 一个矿池一般有一个矿主（pool manager）和许多矿工（miner），矿主连接着许多矿工，矿工只负责计算哈希值的操作，而全节点的其他职责都由这个矿主来承担
   - 某个矿工挖矿成功之后，会把出块奖励进行分配，分配的原则是：
      - 比如说现在挖矿的要求是前面必须有70个0，这时候矿主就会向下另外发一个降低难度的请求，只需要挖到前面有60个0即可，这样挖到的叫做一个share，当下面的矿工每挖到符合难度要求的share后，就会提交给矿主，提交的这个share叫做almost valid block。矿主就会把提交的share作为证明这个矿工工作量的数据，在挖矿成功之后，按照工作量进行分配奖励
      - 这样就有一个问题：会不会有的矿工在挖到符合条件的区块后不提交给矿主，而是自己发布出去；当找到符合矿主条件的share之后，把他提交给矿主。相当于自己独吞出块奖励？
         - 这样是不可能做到的。因为每个矿工的任务是由矿主来分配的，矿主负责组装好一个区块，然后交给矿工去尝试各种各样的nonce。而且在coinbase transaction里面包含一个收款人的地址，这个地址是矿主的地址，所以矿工挖到区块之后，如果他不提交给矿主，他自己发布出去是没有用的，里面的收款地址是矿主的，他取不出来钱。
- 矿池在各个国家的分布比例
- ![](https://vi2.xiu123.cn/live/2019/12/08/13/1003v1575781769101889269.jpg)
- 当一个攻击者的算力超过了51%，那么他就可以做分叉攻击或者封锁境域攻击（boycott）

#### 比特币脚本 

- 一个交易实例
- ![](https://vi1.xiu123.cn/live/2019/12/08/13/1003v1575782629221257121.jpg)
- 上图交易结构
- ![](https://vi0.xiu123.cn/live/2019/12/08/13/1003v1575782694712830125.jpg)
   - locktime：用来设定交易的生效时间，现在是0，也就是立即生效
   - blockhash：当前交易所在的区块的哈希值
   - confirmations：当前交易有多少个确认信息
   - time：当前交易产生的时间
   - block time：当前交易所在的区块产生的时间
- 交易的输入结构
- ![](https://vi3.xiu123.cn/live/2019/12/08/13/1003v1575782908581353622.jpg)
   - txid：当前交易的比特币是之前哪一个交易的输出，并把之前的交易取哈希
   - vout：表示当前交易的比特币是之前交易里面的第几个输出
   - scriptSig：输入脚本
- 交易的输出结构
- ![](https://vi1.xiu123.cn/live/2019/12/08/13/1003v1575783147649958855.jpg)
   - value：输出的金额，也就是给对方的比特币金额
   - n：序号，代表这是这笔交易里面的第几个输出
   - scriptPubKey：输出脚本
   - reqSigs：当前输出需要多少个签名才能够兑现
   - type：输出的类型。例子中的是pubkeyhash：公钥的哈希
   - address：输出的地址
- 脚本的执行流程
- ![](https://vi3.xiu123.cn/live/2019/12/08/13/1003v1575783407037231182.jpg)