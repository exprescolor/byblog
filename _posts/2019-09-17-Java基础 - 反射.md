---
layout:     post 
title:      Java基础0917
subtitle:   反射
date:       2019-09-17
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - Java
---

# Java基础

#### 反射（reflect）

- 反射机制指的是程序运行时能够获取自身的信息。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息

- 类是用来描述一组对象的，反射机制是用来描述一组类的
   - Class：描述类本身
   - Field：描述类中的属性
   - Method：描述类中的方法
   - Constructor：描述类中的构造方法
   - Package：描述类所属的包
   - Annotation：描述类中的注解@Override（注解可以放在类上面，属性上面，方法上面，构造方法上面、参数前面）
- 上述6个组成了反射机制


![反射机制](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-17%20111305.png)

#### Java反射机制主要提供了以下功能

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时调用任意一个对象的方法；生成动态代理

#### 反射机制的优缺点

- 为什么要用反射机制？
   - 编译主要分为动态编译和静态编译。
   - 动态编译：运行时确定类型，绑定对象。动态编译最大限度的发挥了Java的灵活性，体现了多态的应用，用以降低类之间的耦合性
   - 静态编译：在编译时确定类型，绑定对象即通过
- 反射机制的优点是可以实现动态的创建对象和编译，体现出很大的灵活性。
- 他的缺点是对性能有影响，使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的需要。这类操作总是慢于只直接执行相同的操作。

#### 如何获取Class

- `Class clazz=Class.forName("包名.类名");`
- `Class clazz=类名.class;`
- `Class clazz=对象.getClass();//Object类中的方法`

#### Class中的常用方法

```java
package testreflect;
import java.util.ArrayList;
public class TestMain {
    public static  void main(String[] args){
        //通过一个Class对象来操作Person.class类文件
        try {
            Class clazz = Class.forName("testreflect.Person");
            Object newInstance = clazz.newInstance();//相当于调用了Person类中的默认无参数构造方法创建对象
            System.out.println(newInstance);
            //获取类的修饰符
            int modifiers = clazz.getModifiers();
            System.out.println(modifiers);

            //类名字
            String name = clazz.getName();//类全名:testreflect.Person
            String simpleName = clazz.getSimpleName();//类名:Person
            System.out.println(name);
            System.out.println(simpleName);

            //获取类所在的包
            Package clazzPackage = clazz.getPackage();
            System.out.println(clazzPackage.getName());

            //获取当前类的父类
            Class superclass = clazz.getSuperclass();
            System.out.println(superclass);

            ArrayList<String> list = new ArrayList<>();
            //获取集合对应的class
            Class clazz1 = ArrayList.class;
            Class sclazz = clazz1.getSuperclass();
            if (sclazz!=null){
                System.out.println(sclazz.getName());
                sclazz=sclazz.getSuperclass();
            }

            //获取当前clazz所有的父接口
            Class[] interfaces = clazz1.getInterfaces();
            for (Class c:interfaces){
                System.out.println(c.getName());
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

```

#### Field类中的常用方法

```java
package testreflect;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class TestMain {

    public static void main(String[] args) {
        //通过一个Class对象来操作Person.class类文件
        try {
            Class clazz = Class.forName("testreflect.Person");
            //通过clazz来获取类中的属性
            Field field = clazz.getField("name");
            //获取结构
            int modifiers = field.getModifiers();//属性的修饰符
            System.out.println(modifiers);
            //获取属性的类型
            Class<?> fieldType = field.getType();
            System.out.println(fieldType);
            //获取属性名
            String fieldName = field.getName();
            System.out.println(fieldName);


        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}
```

#### 操作Person中的公有属性，向里面存值/从里面取值

```java
//TestMain.java
package testreflect;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class TestMain {

    public static void main(String[] args) {
        //通过一个Class对象来操作Person.class类文件
        try {
            Class clazz = Class.forName("testreflect.Person");
            Person p = new Person();
            //通过clazz来获取类中的属性
            Field field = clazz.getField("name");//知道属性名字是什么，属性是公有的
            //Field[] fields = clazz.getFields();获取全部属性
            //赋值
            field.set(p,"jokerboozp");

            //取值
            String name = (String) field.get(p);
            System.out.println(name);
            System.out.println(p);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}

//Person.java
package testreflect;

public class Person extends Animal{
    public   String name;
    public  int age;

    public String toString(){
        return "{"+name+","+age+"}";
    }
}

```

#### 操作Person中的私有属性

```java
//TestMain.java
package testreflect;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class TestMain {

    public static void main(String[] args) {
        //通过一个Class对象来操作Person.class类文件
        try {
            Class clazz = Class.forName("testreflect.Person");
            Person p = (Person) clazz.newInstance();
            //获取私有属性
            Field f = clazz.getDeclaredField("name");
            //设置私有属性可操作
            f.setAccessible(true);
            //设置私有属性值
            f.set(p,"jokerboozp");
            System.out.println(p);
            //取到私有属性的值
            String value = (String) f.get(p);
            System.out.println(value);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}

//Person.java
package testreflect;

public class Person extends Animal{
    private   String name;
    public  int age;

    public String toString(){
        return "{"+name+","+age+"}";
    }
}

```
- 例子(修改预先定义的String内容。)：

```java
String str="abc";
相当于
char data[] = {'a', 'b', 'c'};
String str = new String(data);
且String是被final修饰的
所以本例子相当于是利用反射修改私有属性
```

```java
package testreflect;

import java.lang.reflect.Field;

public class ChangeStringValue {

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        String str = new String("abc");
        System.out.println(str);
        //反射的技术可以获取私有属性，可以操作私有属性，虽然很不合理
        //1.获取String 类对应的那天个class
        Class<? extends String> clazz = str.getClass();
        //2.通过clazz获取类中的value属性
        Field field = clazz.getDeclaredField("value");
        //3.直接操作属性的值，设置私有属性可以被操作
        field.setAccessible(true);
        //4.获取value属性里面的值（内存地址）
        char[] temp = (char[]) field.get(str);
        //通过temp的地址引用，找到真实String对象中的数组，修改数组中每一个元素
        temp[0]='张';temp[1]='小';temp[2]='贤';
        System.out.println(str);
    }
}

```