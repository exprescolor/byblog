---
layout:     post 
title:      Shiro基础0921
subtitle:   更改Shiro认证策略、权限配置、配置Realms到SecurityManager、授权流程
date:       2019-09-21
author:     张鹏
header-img: img/post-bg-YesOrNo.jpg
catalog: true   
tags:                         
    - Shiro
---

#### 更改Shiro认证策略

- 更改applicationContext.xml中关于多Realm认证的配置
- 示例为把认证策略改为AllSuccessfulStrategy

```xml
<bean id="authenticator" class="org.apache.shiro.authc.pam.ModularRealmAuthenticator">
    	<property name="realms">
    		<list>
    			<ref bean="jdbcRealm"/>
    			<ref bean="secondRealm"/>
    		</list>
    	</property>
    	<property name="authenticationStrategy">
    		<bean class="org.apache.shiro.authc.pam.AllSuccessfulStrategy"></bean>
    	</property>
    </bean>
```
- ShiroRealm.java
```java
package com.sc.shiro;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.LockedAccountException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.crypto.hash.SimpleHash;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.util.ByteSource;

public class ShiroRealm extends AuthenticatingRealm {

	@Override
	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
		System.out.println("[shiroRealm] doGetAuthenticationInfo");
		//1.把AuthenticationToken转换为UsernamePasswordToken
		UsernamePasswordToken upToken=(UsernamePasswordToken) token;
		//2.从UsernamePasswordToken中来获取username
		String username=upToken.getUsername();
		//3.调用数据库的方法，从数据库中查询username对应的用户记录
		System.out.println("从数据库中获取username："+username+"所对应的用户信息");
		//4.若用户不存在，则可以抛出UnknownAccountException异常
		if ("unknown".equals(username)) {
			throw new UnknownAccountException("用户不存在！");
		}
		//5.根据用户信息的情况决定是否需要抛出其他的异常
		if ("monster".equals(username)) {
			throw new LockedAccountException("用户被锁定！");
		}
		//6.根据用户的情况，来构建AuthenticationInfo对象并返回,通常使用的实现类是SimpleAuthenticationInfo
		//以下是从数据库中获取的
		//第一个参数：principal-认证的实体信息，可以是username，也可以是数据表对应的用户的实体类对象
		Object principal=username;
		//第二个参数：credentials-从数据表中获取的密码
		Object credentials="fc1709d0a95a6be30bc5926fdb7f22f4";
		if ("admin".equals(username)) {
			credentials="038bdaf98f2037b31f1e75b5b4c9b26e";
		}else if ("user".equals(username)) {
			credentials="098d2c478e9c11555ce2823231e02ec1";
		}
		//第三个参数：realmName-当前realm对象的name。调用父类的getName()方法即可
		String realmName=getName();
		//盐值
		ByteSource credentialsSalt=ByteSource.Util.bytes(username);
		SimpleAuthenticationInfo info=null;//new SimpleAuthenticationInfo(principal, credentials, realmName);
		info=new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName);
		return info;
	}
	
	public static void main(String[] args) {
		String hashAlgorithmName="MD5";
		Object credentials="123456";
		Object salt=ByteSource.Util.bytes("user");
		int hashIterations=1024;
		
		Object result = new SimpleHash(hashAlgorithmName, credentials, salt,hashIterations);
		System.out.println(result);
	}

}

```

- SecondRealm.java

```java
package com.sc.shiro;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.LockedAccountException;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.crypto.hash.SimpleHash;
import org.apache.shiro.realm.AuthenticatingRealm;
import org.apache.shiro.util.ByteSource;

public class SecondRealm extends AuthenticatingRealm {

	@Override
	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
		System.out.println("[SecondRealm] doGetAuthenticationInfo");
		//1.把AuthenticationToken转换为UsernamePasswordToken
		UsernamePasswordToken upToken=(UsernamePasswordToken) token;
		//2.从UsernamePasswordToken中来获取username
		String username=upToken.getUsername();
		//3.调用数据库的方法，从数据库中查询username对应的用户记录
		System.out.println("从数据库中获取username："+username+"所对应的用户信息");
		//4.若用户不存在，则可以抛出UnknownAccountException异常
		if ("unknown".equals(username)) {
			throw new UnknownAccountException("用户不存在！");
		}
		//5.根据用户信息的情况决定是否需要抛出其他的异常
		if ("monster".equals(username)) {
			throw new LockedAccountException("用户被锁定！");
		}
		//6.根据用户的情况，来构建AuthenticationInfo对象并返回,通常使用的实现类是SimpleAuthenticationInfo
		//以下是从数据库中获取的
		//第一个参数：principal-认证的实体信息，可以是username，也可以是数据表对应的用户的实体类对象
		Object principal=username;
		//第二个参数：credentials-从数据表中获取的密码
		Object credentials="fc1709d0a95a6be30bc5926fdb7f22f4";
		if ("admin".equals(username)) {
			credentials="ce2f6417c7e1d32c1d81a797ee0b499f87c5de06222";
		}else if ("user".equals(username)) {
			credentials="073d4c3ae812935f23cb3f2a71943f49e082a718222";
		}
		//第三个参数：realmName-当前realm对象的name。调用父类的getName()方法即可
		String realmName=getName();
		//盐值
		ByteSource credentialsSalt=ByteSource.Util.bytes(username);
		SimpleAuthenticationInfo info=null;//new SimpleAuthenticationInfo(principal, credentials, realmName);
		info=new SimpleAuthenticationInfo("secondRealmName", credentials, credentialsSalt, realmName);
		return info;
	}
	
	public static void main(String[] args) {
		String hashAlgorithmName="SHA1";
		Object credentials="123456";
		Object salt=ByteSource.Util.bytes("admin");
		int hashIterations=1024;
		
		Object result = new SimpleHash(hashAlgorithmName, credentials, salt,hashIterations);
		System.out.println(result);
	}

}

```

#### Shiro把Realms配置给SecurityManager

- 在applicationContext.xml中把在配置多Realm验证中配置的Realms放在SecurityManager中。认证策略改为Atleast

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 1. 配置 SecurityManager! -->     
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="cacheManager" ref="cacheManager"/>
        <property name="authenticator" ref="authenticator"></property>
        <property name="realms">
    		<list>
    			<ref bean="jdbcRealm"/>
    			<ref bean="secondRealm"/>
    		</list>
    	</property>
    </bean>

    <!-- 2. 配置 CacheManager. 2.1 需要加入 ehcache 的 jar 包及配置文件. -->     
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/> 
    </bean>
    
    <bean id="authenticator" class="org.apache.shiro.authc.pam.ModularRealmAuthenticator">
    	<property name="authenticationStrategy">
    		<bean class="org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy"></bean>
    	</property>
    </bean>

    <!-- 3. 配置 Realm 3.1 直接配置实现了 org.apache.shiro.realm.Realm 接口的 bean -->     
    <bean id="jdbcRealm" class="com.sc.shiro.ShiroRealm">
    	<property name="credentialsMatcher">
    		<bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
    			<property name="hashAlgorithmName" value="MD5"></property>
    			<property name="hashIterations" value="1024"></property>
    		</bean>
    	</property>
    </bean>
    
    <bean id="secondRealm" class="com.sc.shiro.SecondRealm">
    	<property name="credentialsMatcher">
    		<bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
    			<property name="hashAlgorithmName" value="SHA1"></property>
    			<property name="hashIterations" value="1024"></property>
    		</bean>
    	</property>
    </bean>

    <!-- 4. 配置 LifecycleBeanPostProcessor. 可以自定的来调用配置在 Spring IOC 容器中 shiro bean 的生命周期方法. -->       
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

  
    <!-- 5. 启用 IOC 容器中使用 shiro 的注解. 但必须在配置了 LifecycleBeanPostProcessor 之后才可以使用. -->     
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"
          depends-on="lifecycleBeanPostProcessor"/>
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"/>
    </bean>

    <!-- 6. 配置 ShiroFilter. 6.1 id 必须和 web.xml 文件中配置的 DelegatingFilterProxy 的 <filter-name> 一致. 若不一致, 则会抛出: NoSuchBeanDefinitionException. 因为 Shiro 会来 IOC 容器中查找和 <filter-name> 名字对应的 filter bean. -->     
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>
        <property name="loginUrl" value="/login.jsp"/>
        <property name="successUrl" value="/list.jsp"/>
        <property name="unauthorizedUrl" value="/unauthorized.jsp"/>
        <!-- 配置哪些页面需要受保护. 以及访问这些页面需要的权限. 1). anon 可以被匿名访问 2). authc 必须认证(即登录)后才可能访问的页面. 3). logout 登出. 4). roles 角色过滤器 -->
        <property name="filterChainDefinitions">
            <value>
                /login.jsp = anon
                /shiro/login=anon
                /shiro/logout=logout
                # everything else requires authentication:
                /** = authc
            </value>
        </property>
    </bean>

</beans>

```

#### Shiro授权

- 授权，也叫访问控制，即在应用中控制谁访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需要了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）
   - 主体（Subject）：访问应用的用户。在Shiro使用Subject代表该用户。用户只有授权后才能访问相应的资源
   - 资源（Resource）：在应用中用户可以访问的URL，比如访问JSP页面，查看/编辑某些数据，访问某个业务方法，打印文本都是资源。用户只有授权后才能访问。
   - 权限（Permissions）：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力，即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增删改查）式权限控制）等。权限代表了用户有没有操作某个资源的权力，即反映在某个资源上的某个操作允不允许。
   - Shiro支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限，即实例级别的）
   - 角色（Role）：权限的集合，一般情况下会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。不同的角色拥有一组不同的权限。

- Shiro支持三种方式的授权
   - 编程式：通过`if/else`代码块完成

```java
if(subject.hasRole("admin")){
    //有权限
}else{
    //无权限
}
```
   - 注解式：通过在执行的Java方法上放置相应的注解完成，没有权限将抛出相应的异常

```java
@RequiresRoles("admin")
public void hello(){
   //有权限 
}
```
   - JSP/GSP标签：在JSP/GSP页面通过相应的标签完成

```jsp
<shrio:hasRole	name="admin">
<!- 有权限 ->
</shrio:hasRole>
```

#### Shiro默认拦截器

- Shiro内置了很多默认的拦截器，比如身份认证、授权等相关的。

![身份验证相关的](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-21%20152038.png)

![授权相关的](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-21%20152125.png)

- roles角色过滤器（通过设置角色来进行拦截操作）

```xml
//applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 1. 配置 SecurityManager! -->     
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="cacheManager" ref="cacheManager"/>
        <property name="authenticator" ref="authenticator"></property>
        <property name="realms">
    		<list>
    			<ref bean="jdbcRealm"/>
    			<ref bean="secondRealm"/>
    		</list>
    	</property>
    </bean>

    <!-- 2. 配置 CacheManager. 2.1 需要加入 ehcache 的 jar 包及配置文件. -->     
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/> 
    </bean>
    
    <bean id="authenticator" class="org.apache.shiro.authc.pam.ModularRealmAuthenticator">
    	<property name="authenticationStrategy">
    		<bean class="org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy"></bean>
    	</property>
    </bean>

    <!-- 3. 配置 Realm 3.1 直接配置实现了 org.apache.shiro.realm.Realm 接口的 bean -->     
    <bean id="jdbcRealm" class="com.sc.shiro.ShiroRealm">
    	<property name="credentialsMatcher">
    		<bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
    			<property name="hashAlgorithmName" value="MD5"></property>
    			<property name="hashIterations" value="1024"></property>
    		</bean>
    	</property>
    </bean>
    
    <bean id="secondRealm" class="com.sc.shiro.SecondRealm">
    	<property name="credentialsMatcher">
    		<bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
    			<property name="hashAlgorithmName" value="SHA1"></property>
    			<property name="hashIterations" value="1024"></property>
    		</bean>
    	</property>
    </bean>

    <!-- 4. 配置 LifecycleBeanPostProcessor. 可以自定的来调用配置在 Spring IOC 容器中 shiro bean 的生命周期方法. -->       
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

  
    <!-- 5. 启用 IOC 容器中使用 shiro 的注解. 但必须在配置了 LifecycleBeanPostProcessor 之后才可以使用. -->     
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"
          depends-on="lifecycleBeanPostProcessor"/>
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"/>
    </bean>

    <!-- 6. 配置 ShiroFilter. 6.1 id 必须和 web.xml 文件中配置的 DelegatingFilterProxy 的 <filter-name> 一致. 若不一致, 则会抛出: NoSuchBeanDefinitionException. 因为 Shiro 会来 IOC 容器中查找和 <filter-name> 名字对应的 filter bean. -->     
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>
        <property name="loginUrl" value="/login.jsp"/>
        <property name="successUrl" value="/list.jsp"/>
        <property name="unauthorizedUrl" value="/unauthorized.jsp"/>
        <!-- 配置哪些页面需要受保护. 以及访问这些页面需要的权限. 
        1). anon 可以被匿名访问 
        2). authc 必须认证(即登录)后才可能访问的页面. 
        3). logout 登出. 
        4). roles 角色过滤器 -->
        <property name="filterChainDefinitions">
            <value>
                /login.jsp = anon
                /shiro/login=anon
                /shiro/logout=logout
                
                /user.jsp=roles[user]
                /admin.jsp=roles[admin]
                # everything else requires authentication:
                /** = authc
            </value>
        </property>
    </bean>

</beans>

```

#### 授权流程分析

- 授权需要继承`AuthorizingRealm`类，同时实现`doGetAuthorizationInfo(PrincipalCollection)`方法.
- `AuthorizingRealm`类继承自`AuthenticatingRealm`，但没有实现`AuthenticatingRealm`中的`doGetAuthenticationInfo`方法。所有认证和授权只需要继承`AuthorizingRealm`就可以了，同时实现他的两个抽象方法。