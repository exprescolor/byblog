---
layout:     post 
title:      Java面试
subtitle:   面试题
date:       2019-10-10
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - Java面试题
---

#### 41. 在Java中，如何跳出当前的多重嵌套循环？

- 在外部循环的前一行，加上标签，在break的时候使用该标签，即能达到结束多重嵌套循环的效果

```java
public class HelloWorld{
    public static void main(String[] args){
        //打印单数
        outloop://outloop这个标识是可以自定义的，比如outloop1、ol2、out5
        for(int i=0;i<10;i++){
            for(int j=0;j<10;j++){
                System.out.println(i+":"+j);
                if(0==j%2)
                break outloop;//如果是双数，结束外部循环
            }
        }
    }
}
```

#### 42. List、Map、Set三个接口，存取元素时，各有什么特点？

- List是有顺序的，并且可以重复
- Set是无序的，不可以重复
- Map保存数据的方式是键值对

#### Anonymous Inner Class（匿名内部类）是否可以继承其他类，是否可以实现接口？

- 匿名内部类本质上就是在继承其他类，实现其他接口
- 如下：匿名类1就是继承了Thread，匿名类2就是实现了Runnable接口

```java
package redis;

public class HelloWorld2 {

	public static void main(String[] args){
		//匿名类1
		new Thread(){
			public void run() {
				
			}
		};
		//匿名类2
		new Runnable() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
			}
		};
	}
}
```

#### 44. 内部类可以引用外部类的成员吗？有没有什么限制？

- 可以引用
- 如果是非静态内部类，可以使用外部类的所有成员
- 如果是静态内部类，只能使用外部类的静态成员

#### 45. 多线程有几种实现方式？都是什么？

- 三种方式，分别是：
- 继承Thread类
- 实现Runnable接口
- 匿名内部类

#### 46. sleep()和wait()有什么区别？

- 首先sleep和wait之间没有任何关系
- sleep是Thread类的方法，指的是当前线程暂停
- wait是Object类的方法，指的是占用当前对象的线程临时释放对当前对象的占用，以使得其他线程有机会占用当前对象。所以调用wait()方法一定是在synchronized中进行

#### 47. 说出数据连接池的工作机制是什么？

- 因为创建连接和关闭连接的行为是非常耗费时间的，会显著降低软件的性能表现。解决方法就是先创建n条数据库连接Connection，循环使用，但是不进行关闭，这样再执行sql语句，就不需要额外创建连接了，直接用线程的连接就行，从而节约了创建连接和关闭连接的时间开销。

#### 48. 简述synchronized和java.util.concurrent.locks.Lock的异同？

- Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。
- Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一直获取下去。借助Lock这个特性，就能够规避死锁。synchronized必须通过谨慎和良好的设计，才能减少死锁的发生
- synchronized在发生异步和同步块结束时，会自动释放锁，而Lock必须手动释放，所以如果忘记释放锁，也会发生死锁。

#### 49. Class.forName的作用？为什么要用？

- Class.forName常见的场景是在数据库驱动初始化的时候调用
- Class.forName本身的意义是加载类到JVM中，一旦一个类被加载到JVM，他的静态属性就会被初始化，在初始化的过程中就会执行相关代码，从而达到“加载驱动的效果”

#### 50. 当一个线程进入一个对象的一个synchronized方法后，其他线程是否可以进入此对象的其他方法？

- 这要看情况而定，如果该对象的其他方法也是有synchronized方法的，那么其他线程就会被挡在外面。否则其他线程就可以进入到其他方法中。

#### 51. 说出几个最常见的runtime exception

1. NullPointerException：空指针异常
2. ArithmeticException：算数异常，比如除数为0
3. ClassCastException：类型转换异常
4. ConcurrentModificationException：同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常
5. IndexOutOfBoundsException：数组下标越界异常
6. NegativeArraySizeException：为数组分配的空间是负数异常