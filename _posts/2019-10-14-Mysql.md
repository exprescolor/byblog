---
layout:     post 
title:      Mysql
subtitle:   事务
date:       2019-10-14
author:     张鹏
header-img: img/post-bg-hacker.jpg#### 事务的基本特性（ACID）
catalog: true   
tags:                         
    - Mysql
---

#### 事务的基本特性（ACID）

- 1.原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节，事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样，也就是说事务是一个不可分割的整体，就像化学中的原子，是物质构成的基本单位。
- 2.一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏，比如A向B转账，不可能A扣了钱，B却没有收到
- 3.隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡里取钱，在A取钱的过程结束前，B不能向这张卡转账
- 4.持久性（Durability）：事务完成后，事务对数据库的所有更改将被保存到数据库，不能回滚。

#### 事务的并发问题

- 1.脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据
- 2.不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A在多次读取同一数据时，结果不一致
- 3.幻读：系统管理员A将数据库中的所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后，发现还有一条数据没有改过来，就好像发生幻觉一样，这就叫做幻读
- 不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除，解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

#### Mysql事务隔离级别

- 1.Read-Uncommitted（读取未提交内容）
   - 在该隔离级别中，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为他的实际性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）
- 2.Read-Committed（读取提交内容）
   - 这是大多数数据库系统的默认隔离级别（但不是Mysql默认的）。它满足了隔离的简单定义，一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同结果
- 3.Repeatable-Read（可重读）
   - 这是Mysql的默认事务隔离级别，他确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个问题：幻读。InnoDB和Falcon存储引擎通过多版本并发控制机制（MVCC）解决了该问题。
- 4.Serializable（可串行化）
   - 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，他在每个读的数据行上加了共享锁。在这个级别时，可能导致大量的超时现象和锁竞争。
- **隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大**

#### Mysql MVCC实现机制

- MVCC是一种多版本并发控制机制
- **MVCC是为了解决什么问题**
   - 大多数的Mysql事务型存储引擎，如InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制，事实上，他们都和MVCC多版本并发控制来一起使用
   - 锁机制可以控制并发操作，但是其系统开销比较大，而MVCC可以在大多数情况下代替行级锁，使用MVCC能降低其系统开销
- **MVCC实现**
   - MVCC是通过保存数据在某个时间点的快照来实现的，不同存储引擎的MVCC实现是不同的。典型的有乐观并发控制和悲观并发控制
- **MVCC具体实现分析**
   - InnoDB的MVVC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值，而是系统版本号（可以理解为事务的ID），每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。
   - InnoDB的读分为快照读和当前读，快照读是通过MVVC控制的，可能出现幻读的情况。当前读是通过行锁和间隙锁控制的，此时是加了排他锁的，所有其他的事务都不能动当前的事务。所以避免出现了幻读的可能，一般update、delete都是应用的当前读。
      - 当前读即加锁读，读取记录的最新版本号，会加锁保证其他并发事物不能修改当前记录，直至释放锁。插入/更新/删除操作默认使用当前读，显示的为select语句加lock in share mode或for update的查询也采用当前读模式。 
      - 快照读：不加锁，读取记录的快照版本，而非最新版本，使用MVCC机制，最大的好处是读取不需要加锁，读写不冲突，用于读操作多于写操作的应用，因此在不显示加[lock in share mode]/[for update]的select语句，即普通的一条select语句默认都是使用快照读MVCC实现模式。
   - 事务ID不是提交时创建的，在打开一个会话的时候就创建了一个事务ID，ID=1出现了，你在哪打开一个MySQL数据库连接会话，ID=2的事务就出现了
- **一个小例子：在Repeatable Read隔离级别下，MVVC具体是如何操作的**

```mysql
create table yang(
id int primary key auto_increment,
name varchar(20));
```

   - INSERT
      - InnoDB为新插入的每一行保存当前系统版本号作为版本号
      - 第一个事务ID为1

```mysql
start transaction;
insert into yang values(NULL,'yang') ;
insert into yang values(NULL,'long');
insert into yang values(NULL,'fei');
commit;
```

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | undefined          |
| 2    | long | 1                  | undefined          |
| 3    | fei  | 1                  | undefined          |


- SELECT
   - InnoDB会根据以下两个条件检查每行记录：
      - 1.InnoDB只会查找版本号早于当前事务版本的数据行（也就是行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
      - 2.行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在事务开始之前未被删除
      - **只有1，2同时满足的记录，才能返回作为查询结果**
- DELETE
   - InnoDB会为删除的每一行保存当前系统的版本号（事务ID）作为删除标识
   - 下述代码是第二个事务，ID为2

```mysql
start transaction;
select * from yang;  //(1)
select * from yang;  //(2)
commit; 
```

   - **假设1**
      - 假设在执行这个事务ID为2的过程中，刚执行到(1)，这时，另一个事务ID为3往这个表里添加了一条数据
      - 下述代码是第三个事务，ID为3

```mysql
start transaction;
insert into yang values(NULL,'tian');
commit;
```

- 这时表中的数据如下

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | undefined          |
| 2    | long | 1                  | undefined          |
| 3    | fei  | 1                  | undefined          |
| 4    | tian | 3                  | undefined          |

- 然后接着执行事务2中的(2)，由于ID=4的数据的创建时间（事务ID=3），执行当前事务的ID为2，而InnoDB只会查找ID小于或等于当前事务ID的数据行，所以ID=4的数据行并不会在执行事务2中的(2)被检索出来。在事务2中的两条select语句检索出来的数据如下表

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | undefined          |
| 2    | long | 1                  | undefined          |
| 3    | fei  | 1                  | undefined          |

   - **假设2**
      - 假设在执行这个事务ID为2的过程中，刚执行到(1)，假设事务执行到事务3后，接着又执行了事务4
      - 第四个事务

```mysql
start   transaction;  
delete from yang where id=1;
commit;  
```

- 此时数据库中的数据如下

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | 4                  |
| 2    | long | 1                  | undefined          |
| 3    | fei  | 1                  | undefined          |
| 4    | tian | 3                  | undefined          |


- 接着执行事务ID为2的事务(2)，根据SELECT检索条件可以知道，他会检索创建时间（创建事务的ID）小于当前事务ID的行和删除时间（删除事务的ID）大于当前事务的行。而ID=4的行上面已经说过，而ID=1的行由于删除时间（删除事务的ID）大于当前事务的ID，所以事务2的(2)也会把id=1的数据检索出来。所有事务2中的两条select语句检索出来的数据都如下表所示

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | 4                  |
| 2    | long | 1                  | undefined          |
| 3    | fei  | 1                  | undefined          |

- UPDATE
   - InnoDB执行Update，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要Update的行的删除时间
- **假设3**
   - 假设在执行完事务2的(1)后又执行，其他用户执行了事务3，4.这时，又有一个用户对这张表执行了UPDATE操作
   - 第五个事务

```mysql
start  transaction;
update yang set name='Long' where id=2;
commit;
```

- 根据UPDATE的更新原则：会生成新的一行，并在原来要修改的列的删除时间列山添加本事务ID，得到的表如下

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | 4                  |
| 2    | long | 1                  | 5                  |
| 3    | fei  | 1                  | undefined          |
| 4    | tian | 3                  | undefined          |
| 2    | Long | 5                  | undefined          |

- 继续执行事务2的(2),根据select语句检索条件，得到如下表：

| id   | name | 创建时间（事务ID） | 删除时间（事务ID） |
| ---- | ---- | ------------------ | ------------------ |
| 1    | yang | 1                  | 4                  |
| 2    | long | 1                  | 5                  |
| 3    | fei  | 1                  | undefined          |

- 还是和事务2中的(1)得到相同的结果。