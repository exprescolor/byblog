---
layout:     post   				    # 使用的布局（不需要改）
title:      深入理解计算机系统(CSAPP)_archlab	# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-07-18 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - CSAPP
---

# archlab

## part A

这一部分要用Y86-64实现下面三个函数

```C
/* 
 * Architecture Lab: Part A 
 * 
 * High level specs for the functions that the students will rewrite
 * in Y86-64 assembly language
 */

/* $begin examples */
/* linked list element */
typedef struct ELE {
    long val;
    struct ELE *next;
} *list_ptr;

/* sum_list - Sum the elements of a linked list */
long sum_list(list_ptr ls)
{
    long val = 0;
    while (ls) {
	val += ls->val;
	ls = ls->next;
    }
    return val;
}

/* rsum_list - Recursive version of sum_list */
long rsum_list(list_ptr ls)
{
    if (!ls)
	return 0;
    else {
	long val = ls->val;
	long rest = rsum_list(ls->next);
	return val + rest;
    }
}

/* copy_block - Copy src to dest and return xor checksum of src */
long copy_block(long *src, long *dest, long len)
{
    long result = 0;
    while (len > 0) {
	long val = *src++;
	*dest++ = val;
	result ^= val;
	len--;
    }
    return result;
}
/* $end examples */
```

其中Y86-64的编写规则在书中第四章4.1部分用例子解释的很清楚了。

主要考察的就是汇编语言的编写能力。

* sum_list

```
.pos 0
	irmovq stack,%rsp
	call main
	halt

# Sample linked list
.align 8
ele1:
.quad 0x00a
.quad ele2
ele2:
.quad 0x0b0
.quad ele3
ele3:
.quad 0xc00
.quad 0

sum_list:
	xorq %rax,%rax
	
loop_start:
	andq %rdi,%rdi
	je loop_end

	mrmovq 0(%rdi),%rsi
	addq %rsi,%rax
	mrmovq 8(%rdi),%rsi
	rrmovq %rsi,%rdi	

	jmp loop_start

loop_end:
	ret

main:
	irmovq ele1,%rdi
	call sum_list
	ret

.pos 1024
stack:
```

执行结果：

[![UO0yDO.png](https://s1.ax1x.com/2020/07/23/UO0yDO.png)](https://imgchr.com/i/UO0yDO)

* rsum_list

```
.pos 0
	irmovq stack,%rsp
	call main
	halt

.align 8
ele1:
.quad 0x00a
.quad ele2
ele2:
.quad 0x0b0
.quad ele3
ele3:
.quad 0xc00
.quad 0

rsum_list:
	xorq %rax,%rax
	andq %rdi,%rdi
	jne not_null
	ret
not_null:
	mrmovq 0(%rdi),%rsi
	pushq %rsi
	mrmovq 8(%rdi),%rdi
	call rsum_list
	popq %rsi
	addq %rsi,%rax
	ret



main:
	irmovq ele1,%rdi
	call rsum_list
	ret


.pos 1024
stack:
```

执行结果：

[![UO0jGn.png](https://s1.ax1x.com/2020/07/23/UO0jGn.png)](https://imgchr.com/i/UO0jGn)

* copy_block

```
.pos 0
	irmovq stack,%rsp
	call main
	halt
	


.align 8
src:
	.quad 0x00a
	.quad 0x0b0
	.quad 0xc00

dest:
	.quad 0x111
	.quad 0x222
	.quad 0x333

copy_block:
	xorq %rax,%rax
	pushq %r12
	pushq %r13
	irmovq $1,%r13
	irmovq $8,%r12
loop_start:	
	andq %rdx,%rdx
	je loop_end
	mrmovq (%rdi),%rcx
	rmmovq %rcx,(%rsi)
	addq %r12,%rdi
	addq %r12,%rsi
	xorq %rcx,%rax
	subq %r13,%rdx
	jmp loop_start
loop_end:
	popq %r12
	popq %r13
	ret

main:
	irmovq src,%rdi
	irmovq dest,%rsi
	irmovq $3,%rdx
	call copy_block
	ret


.pos 1024
stack:
```

执行结果：

[![UOB0oQ.png](https://s1.ax1x.com/2020/07/23/UOB0oQ.png)](https://imgchr.com/i/UOB0oQ)

## part B

这一部分要修改sim/seq文件夹下的seq-full.hcl文件，添加新指令。

可以参考书里面的指令,4.5.7章节对一些指令进行的举例。

修改的指令如下

```
############### Fetch Stage     ###################################

bool instr_valid = icode in 
	{ IIADDQ, INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ };

# Does fetched instruction require a regid byte?
bool need_regids =
	icode in { IIADDQ, IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		 IIRMOVQ, IRMMOVQ, IMRMOVQ };

# Does fetched instruction require a constant word?
bool need_valC =
	icode in { IIRMOVQ, IIADDQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL };

################ Decode Stage    ###################################

## What register should be used as the B source?
word srcB = [
	icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];

## What register should be used as the E destination?
word dstE = [
	icode in { IRRMOVQ } && Cnd : rB;
	icode in { IIRMOVQ, IOPQ, IIADDQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

################ Execute Stage   ###################################

## Select input A to ALU
word aluA = [
	icode in { IRRMOVQ, IOPQ } : valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;
	icode in { ICALL, IPUSHQ } : -8;
	icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

## Select input B to ALU
word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		      IPUSHQ, IRET, IPOPQ, IIADDQ } : valB;
	icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];

## Should the condition codes be updated?
bool set_cc = icode in { IOPQ, IIADDQ };
```

## part C

这部分结合了第四章的优化和第五章，参考了这位大佬的方法>https://blog.csdn.net/u012336567/article/details/51867766

```
# You can modify this portion
# Loop Header
        xorl    %eax , %eax
        iaddl   $-4 , %edx #len = len -4
        andl    %edx ,  %edx    
        jl  remian
Loop:   mrmovl (%ebx) , %esi
        mrmovl 4(%ebx),%edi
        rmmovl %esi , (%ecx)
        andl    %esi ,%esi
        jle LNpos1
        iaddl   $1 , %eax
LNpos1: rmmovl %edi , 4(%ecx)
        andl    %edi , %edi
        jle     LNpos2
        iaddl   $1, %eax
LNpos2:mrmovl 8(%ebx) , %esi
        mrmovl 12(%ebx),%edi
        rmmovl %esi ,8 (%ecx)
        andl    %esi ,%esi
        jle LNpos3
        iaddl   $1 , %eax
LNpos3: rmmovl %edi , 12(%ecx)
        andl    %edi , %edi
        jle     nextLoop
        iaddl   $1, %eax
nextLoop:
        iaddl   $16,%ebx
        iaddl   $16,%ecx
        iaddl   $-4,%edx
        jge Loop            

# maybe just remain less than 3
remian:  iaddl  $4 , %edx  # Restore the true len
        iaddl   $-1, %edx
        jl  Done
        mrmovl (%ebx) , %esi
        mrmovl 4(%ebx),%edi
        rmmovl %esi , (%ecx)
        andl    %esi ,%esi
        jle rNpos
        iaddl   $1 , %eax
rNpos:  
        iaddl   $-1, %edx
        jl  Done
        rmmovl  %edi , 4(%ecx)
        andl    %edi , %edi
        jle     rNpos1
        iaddl   $1, %eax
rNpos1:
        iaddl   $-1 , %edx 
        jl  Done
        mrmovl 8(%ebx) , %esi
        rmmovl %esi , 8(%ecx)
        andl    %esi ,%esi
        jle Done
        iaddl   $1 , %eax
```

