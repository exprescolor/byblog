---
layout:     post   				    # 使用的布局（不需要改）
title:      C++内存管理与分配相关知识点总结				# 标题 
subtitle:   八股的一部分 #副标题
date:       2022-04-08 				# 时间
author:     谢玄xx 						# 作者
header-img: img/bit (4).jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 内存分配
    - 八股
---

c++的指针：先在栈中存指针a，再向堆中申请内存空间存该指针所指向的元素，然后a指向该地址。

参考链接： [C/C++内存分配管理——作者HUST_Miao](https://blog.csdn.net/u010183728/article/details/81629706)

# 内存概述

在C++中内存分为5个区，分别是**堆**、**栈**、**自由存储区**、**全局/静态存储区**和**常量存储区**。

堆：堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

自由存储区：自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。

全局/静态存储区：这块内存是在程序编译的时候就已经分配好的，在程序整个运行期间都存在。例如全局变量，静态变量。

常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量(const)，不允许修改。

# 常见的内存错误及解决方法

1. 内存分配未成功，却使用了它。

   解决方法：在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。如果是用new来申请内存，申请失败是会抛出异常，所以应该捕捉异常来进行放错处理。(感谢@ melonstreet指出)。

2. 内存分配虽然成功，但是尚未初始化就引用它。

   解决方法：尽管有时候缺省时会自动初始化，但是无论创建什么对象均要对其进行初始化，即便是赋零值也不可省略，不要嫌麻烦。

3. 内存分配成功，但越界访问。

　 解决方法：对数组for循环时要把握边界，否则可能会导致数组越界。

4. 忘记了释放内存，导致内存泄漏。

　 解决方法：动态内存的申请和释放必须配对，new-delete和malloc-free且使用次数必须相同。


# new与malloc的区别

提到内存分配，就不可避免地涉及new和malloc。

1. 申请的内存所在位置
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

特别地，new甚至可以不为对象分配内存！

2. 返回类型安全性
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void* ，需要通过强制类型转换将void* 指针转换成我们需要的类型。
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。

3. 内存分配失败时的返回值
new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功.

4. 是否需要指定内存大小
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

5. 是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：
* 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
* 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
* 第三步：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：
* 第一步：调用对象的析构函数。
* 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

6. 
