---
layout:     post   				    # 使用的布局（不需要改）
title:      JOS学习笔记-Lab1-Part1		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-25 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# Part 1:_PC Bootstrap

## 开始学习x86汇编语言

这里给了一本参考资料介绍了汇编语言，可以参照这本书来查找汇编指令什么的，

**练习1**

熟悉6.828参考页上提供的汇编语言材料。你现在不必阅读它们，但是在读写x86汇编时，可以参考其中的一些内容。

好像并没有什么实质性的内容，但是要有一些汇编基础才行。

## 仿真x86

这里就是qemu的配置，昨天已经配置好了，遇到的问题和解决方案课件里也说的很清楚。

## PC的物理地址空间

pc的物理地址空间分布长这样：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd5zcnrsqkj30cp0fbgm7.jpg)

早期计算机的处理器并不能存储这么多物理内存，是从16kb,32kb,64kb发展起来的。

从0x000A0000到0x000FFFFF的384KB区域由硬件保留，用于特殊用途，比如视频显示缓冲区和非易失性内存中的固件。这个保留区域中最重要的部分是基本输入/输出系统(BIOS)，它占据从0x000F0000到0x000FFFFF的64KB区域。在早期的pc机中，BIOS被保存在真正的只读存储器(ROM)中，但是现在的pc机将BIOS保存在可更新的闪存中。BIOS负责执行基本的系统初始化，如激活显卡和检查安装的内存量。在执行这个初始化之后，BIOS从适当的位置(如软盘、硬盘、CD-ROM或网络)加载操作系统，并将机器的控制权传递给操作系统。

当Intel最终使用80286和80386处理器“打破了1m的限制”，这两个处理器分别支持16MB和4GB的物理地址空间时，PC架构师仍然保留了低1MB物理地址空间的原始布局，以确保与现有软件的向后兼容性。因此，现代pc机在物理内存从0x000A0000到0x00100000之间有一个“洞”，将RAM划分为“低”或“传统内存”(前640KB)和“扩展内存”(其他所有内存)。此外，PC的32位物理地址空间(首先是物理RAM)的最顶层的一些空间现在通常由BIOS保留，供32位PCI设备使用。

最近的x86处理器可以支持超过4GB的物理RAM，因此RAM可以进一步扩展到0xFFFFFFFF之上。在这种情况下，BIOS必须在32位可寻址区域的顶部的系统RAM中留下第二个洞，为这些32位设备的映射留下空间。由于设计上的限制，JOS将只使用PC的前256MB物理内存，所以现在我们将假设所有PC都“只有”32位物理地址空间。但是，处理复杂的物理地址空间和经过多年发展的硬件组织的其他方面是操作系统开发的重要实践挑战之一。

## The ROM BIOS

这一部分我们利用qemu和gdb来实现对操作系统的debug

首先打开两个终端，进入lab所在目录，其中一个终端输入make qemu-gdb,

![11.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd6eth3tbrj30on060aak.jpg)

另一个终端输入gdb，

![12.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd6etnq9wgj30t90h7tc5.jpg)

这里出现了一个错误（好像是两个），解决方案也上面也说的很清楚，往/home/s-seven/.gdbinit文件里添加两行代码

于是

`vi /home/s-seven/.gdbinit`

进入文件，添加

`add-auto-load-safe-path /home/s-seven/lab/.gdbinit
set auto-load safe-path /`

这两行到文件中，回到lab目录下面重新gdb，OK了，出现

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd6favygz5j30oo06l3ze.jpg)

然后我们看到`[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b`这一句，就是要执行的第一个指令的反汇编。通过这些输出信息我们可以总结：

·IBM PC在物理地址0x000ffff0处开始执行，它位于为ROM BIOS保留的64KB区域的最顶端。

·PC从CS = 0xf000和IP = 0xfff0开始执行。

·第一个要执行的指令是一条jmp指令，它跳转到分段的地址CS = 0xf000和IP = 0xe05b。

qemu这样开始与英特尔设计8088处理器的方式有关，PC中，BIOS的物理地址范围是 0x000f0000-0x000fffff，在处理器复位时，(模拟的)处理器进入实模式，将CS设置为0xf000，将IP设置为0xfff0，这样执行就从那个(CS:IP)段地址开始。

**实模式**

PC机启动时，CPU运行在实模式下，进入操作系统内核后，运行在保护模式下。实模式是早期CPU的工作模式，现代处理器在启动时运行于实模式，在启动完成后运行于保护模式。BIOS就运行在实模式下。

在实模式下(PC机启动的模式)，地址转换按照公式进行:物理地址= 16 *段地址+偏移量。因此，当PC将CS设为0xf000，将IP设为0xfff0时，所引用的物理地址为:

16 * 0xf000 + 0xfff0   #16进制乘法
   = 0xf0000 + 0xfff0     # 进位加0
   = 0xffff0 

##练习2

使用GDB的si(步骤指令)命令跟踪ROM BIOS以获得更多的指令，并尝试猜测它可能在做什么。您可能想要查看Phil Storrs I/O端口描述，以及6.828参考资料页面上的其他资料。不需要弄清楚所有的细节-只是BIOS首先要做的事情的一般概念。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd6gydz9zpj30fy0993z8.jpg)

查一下si指令，汇编指令的step into，于是我们可以直接输入si命令进行跟踪。

​	`0xffff0:	ljmp   $0xf000,$0xe05b`

先看第一行命令。这是一条跳转指令，跳转到0xe05b处。

`0xfe05b:	cmpl   $0x0,%cs:0x6ac8`

第二条，比较0x0和%cs:0x6ac8处的值比较，其中%cs:0x6ac8这个格式，就是 段地址：段内偏移 的格式，可以根据计算公式得到物理地址。

`0xfe062:	jne    0xfd2e1`

第三条，如果比较值不相等，则跳转至0xfd2e1地址处。

`0xfe066:	xor    %dx,%dx`

第四条，根据这条指令的地址0xfe066得到，上一条指令并没有跳转，于是这一步将dx寄存器清零。

`0xfe068:	mov    %dx,%ss`

第五条，这个样子ss寄存器也被清零了。

`0xfe06a:	mov    $0x7000,%esp`

第六条，将寄存器esp赋值为0x7000。

`0xfe070:	mov    $0xf34c2,%edx`

第七条，将edx寄存器赋值为0xf34c2。

`0xfe076:	jmp    0xfd15c`

第八条，跳转至0xfd15c

`0xfd15c:	mov    %eax,%ecx`

这一条，将eax寄存器的值赋给ecx

`0xfd15f:	cli`

这一条指令，我查了一下，是关闭中断指令，避免在启动时发生中断。

`0xfd160:	cld `

清除方向标志，即将标志位置0，在字串操作中使变址寄存器SI或DI的地址指针自动增加，字串处理由前往后。

相反功能指令是STD，将方向标志位DF置1，在字串操作中使SI或DI的地址指针自动递减，字串处理由后往前。

`0xfd161:	mov    $0x8f,%eax`

给eax寄存器赋值0x8f

`0xfd167:	out    %al,$0x70`

**out指令** 把寄存器al的值向端口写入，这里端口是0x70

`0xfd169:	in     $0x71,%al`

**in指令**：读取端口的值

**0x70和0x71** ：0x70端口和0x71端口是用于控制系统中一个叫做CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机关闭时存储一些信息。其中0x70可以叫做索引寄存器，这个8位寄存器的最高位是不可屏蔽中断(NMI)使能位。如果你把这个位置1，则NMI不会被响应。低7位用于指定CMOS存储器中的存储单元地址。

在向0x70端口写入值之后，必须对0x71端口有操作，否则RTC就会处在an unknown state之中。

**CMOS**：CMOS中可以控制跟PC相关的多个功能，其中最重要的就是时钟设备（Real Time Clock）的 ，它还可以控制是否响应不可屏蔽中断NMI(Non-Maskable Interrupt)。

所以这三条指令是用来关闭了NMI中断

`0xfd16b:	in     $0x92,%al`

`0xfd16d:	or     $0x2,%al`

`0xfd16f:	out    %al,$0x92`

这三条操作的是0x92这个端口，我们查到这个端口控制的是 PS/2系统控制端口A，然后和0x2或运算，再把值读入寄存器。（这是在干什么呢，我没搞懂。。）

`0xfd171:	lidtw  %cs:0x6ab8`

lidt指令：加载中断向量表寄存器(IDTR)。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器(IDTR)中。中断是操作系统中非常重要的一部分，有了中断操作系统才能真正实现进程。每一种中断都有自己对应的中断处理程序，那么这个中断的处理程序的首地址就叫做这个中断的中断向量。中断向量表自然是存放所有中断向量的表了。

`0xfd177:	lgdtw  %cs:0x6a74`

把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器中GDTR中。

```
0xfd17d:	mov    %cr0,%eax
0xfd180:	or     $0x1,%eax
0xfd184:	mov    %eax,%cr0
```

这三句的操作把CR0寄存器的最低位(0bit)置1。CR0的位0是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。

**控制寄存器**：控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性，如图4-3所示。CR0中含有控制处理器操作模式和状态的系统控制标志；CR1保留不用；CR2含有导致页错误的线性地址；CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）。>https://blog.csdn.net/echoisland/article/details/6726730 (这篇文章讲了这几个寄存器)

```
0xfd187:   ljmpl  $0x8, $0xfd18f
0xfd18f:   mov  $0x10, %eax
0xfd194:   mov  %eax, %ds
0xfd196:   mov  %eax, %es
0xfd198:   mov  %eax, %ss
0xfd19a:   mov  %eax, %fs
0xfd19c:   mov  %eax, %gs
```

这几句修改了寄存器的值，查资料得，加载完GDTR寄存器之后，要重新加载段寄存器的值。

以上，只是简单的了解了这些汇编指令都是什么，至于干了什么以及为什么要这么做，我现在还不知道。。。



当BIOS运行时，它设置一个中断描述符表，并初始化各种设备，如VGA显示器。这就是我们在QEMU窗口中看到的“Starting SeaBIOS”消息的来源。

在初始化PCI总线和BIOS知道的所有重要设备之后，它将搜索可启动的设备，如软盘、硬盘或CD-ROM。最后，当它找到一个可引导的磁盘时，BIOS从磁盘读取引导加载程序，并将控制传输给它。

**BIOS**

是什么：基本输入输出系统

干什么：作为PC启动后运行的一个程序，把操作系统从磁盘中导入内存，再把控制权转交给操作系统。