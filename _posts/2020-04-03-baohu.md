---
layout:     post   				    # 使用的布局（不需要改）
title:      第六章保护		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-03 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# 第六章 保护

## 6.1为什么要保护

80386的保护功能旨在帮助检测和识别错误。80386支持复杂的应用程序，其中可能包含数百或数千个程序模块。在这样的应用程序中，问题是如何尽快发现并消除错误，以及如何严格限制其损坏。为了帮助更快地调试应用程序并使它们在生产中更强大，80386包含用于验证存储器访问和指令执行以符合保护标准的机制。根据系统设计目标，可以使用或忽略这些机制。

## 6.2 80386保护机制概述

80386中的保护包括五个方面：

1. 类型检查
2. 极限检查
3. 可寻址域的限制
4. 程序入口点的限制
5. 指令集的限制

80386的保护硬件是内存管理硬件的组成部分。保护既适用于段翻译，也适用于页面翻译。

硬件会检查对内存的每个引用，以验证其满足保护标准。所有这些检查都是在内存周期开始之前进行的。任何违反都会阻止该循环开始并导致异常。由于检查与地址形成同时进行，因此不会降低性能。

无效的访问内存尝试会导致异常。

“特权”的概念对于保护的几个方面至关重要（前面的列表中的数字3、4和5）。应用于过程的特权是可以信任过程而不犯可能影响其他过程或数据的错误的程度。应用于数据的特权是数据结构应受到较少信任的过程的保护程度。

特权的概念既适用于段保护又适用于页面保护。

## 6.3段级保护

段是保护的单位，段描述符存储保护参数。当将段描述符的选择器加载到段寄存器中并且每次访问段时，CPU都会自动执行保护检查。段寄存器保存当前可寻址段的保护参数。

###6.3.1描述符存储保护参数

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-1.gif)

上图突出显示了段描述符中与保护相关的字段。

保护参数在创建描述符时由系统软件放置在描述符中。通常，应用程序程序员无需关心保护参数。

当程序将选择器加载到段寄存器中时，处理器不仅加载段的基地址，而且加载保护信息。每个段寄存器的不可见部分都有一些位，用于存储基本，限制，类型和特权级别。因此，对同一网段的后续保护检查不会消耗额外的时钟周期。

####6.3.1.1类型检查

描述符的TYPE字段具有两个功能：

- 它区分不同的描述符格式。
- 它指定段的预期用途。

除了用于应用程序通常使用的数据和可执行段的描述符外，80386还具有用于操作系统和门的特殊段的描述符。注意并不是所有的描述符都定义了段；门描述符具有不同的目的，本章稍后将进行讨论。

数据和可执行段描述符的类型字段包括一些位，这些位进一步定义了段的用途：

- 数据段描述符中的可写位指定指令是否可以写入该段。
- 可执行段描述符中的可读位指定是否允许从该段读取指令（例如，访问与指令一起存储的常量）。可读的可执行段可以通过两种方式读取：
  1. 通过CS寄存器，使用CS覆盖前缀。
  2. 通过将描述符的选择器加载到数据段寄存器（DS，ES，FS或GS）中。

类型检查可用于检测编程错误，这些错误将试图以程序员不希望使用的方式使用段。处理器在两种情况下检查类型信息：

1. 将描述符的选择器加载到段寄存器中时。某些段寄存器只能包含某些描述符类型。例如：
   - CS寄存器只能用可执行段的选择器加载。
   - 无法读取的可执行段的选择器无法加载到数据段寄存器中。
   - 只有可写数据段的选择器可以加载到SS中。
2. 当指令（隐式或显式）引用段寄存器时。某些段只能以某些预定义的方式由指令使用；例如：
   - 指令不得写入可执行段。
   - 如果未设置可写位，则任何指令都不能写入数据段。
   - 除非设置了可读位，否则任何指令都不能读取可执行段。

#### 6.3.1.2极限检查

段描述符的限制字段由处理器用来防止程序在段外部寻址。处理器对极限的解释取决于G（粒度）位的设置。对于数据段，处理器对限制的解释还取决于E位（扩展方向位）和B位（大位），如下表。

```
Case:                    1            2            3            4

Expansion Direction      U            U            D            D
G-bit                    0            1            0            1
B-bit                    X            X            0            1

Lower bound is:          0            0         LIMIT+1  shl(LIMIT,12,1)+1

Upper bound is:        LIMIT  shl(LIMIT,12,1)    64K-1         4G-1 

Max seg size is:        64K           4G         64K-1        4G-4K
                      0-FFFF      0-FFFFFFFF     !(0-0)      !(0-FFF)

Min seg size is:         1            4K           0            0
                        0-0         0-FFF      !(0-FFFF)  !(0-FFFFFFFF)

shl (X, 12, 1) = shift X left by 12 bits inserting one-bits on the right
```

当G = 0时，实际极限是20位极限字段的值，该值出现在描述符中。在这种情况下，限制的范围可能是0到0FFFFFH（2 ^（20）-1或1兆字节）。当G = 1时，处理器将12个低位一位附加到limit字段中的值。在这种情况下，实际限制范围可能从0FFFH（2 ^（12）-1或4千字节）到0FFFFFFFFH（2 ^（32）-1或4吉字节）。

对于除扩展数据段以外的所有类型的段，限制值比段的大小（以字节表示）小一。在以下任何一种情况下，处理器都会导致一般保护异常：

- 尝试访问地址>限制处的存储字节。
- 尝试在地址> =限制处访问存储字。
- 尝试在地址> =（限制2）处访问内存双字。

对于向下扩展的数据段，该限制具有相同的功能，但解释不同。在这些情况下，有效地址的范围是从限制+ 1到64K或2 ^（32）-1（4 GB），具体取决于B位。当限制为零时，展开细分的大小最大。（打开扩展位交换，可以访问哪些字节，哪些不能访问。）

通过向下扩展功能，可以通过将堆栈复制到更大的段来扩展堆栈的大小，而无需更新堆栈内指针。

处理器使用描述符表的描述符的限制字段来防止程序选择描述符表外部的表条目。描述符表的限制标识表中最后一个描述符的最后一个有效字节。由于每个描述符的长度为8个字节，因此对于最多可包含N个描述符的表，其极限值为N * 8-1。

限制检查会捕获编程错误，例如下标失控和无效的指针计算。发生此类错误时，可以对其进行检测，从而更容易查明原因。如果不进行限制检查，此类错误可能会破坏其他模块；直到以后，当损坏的模块行为不正确，并且难以确定原因时，才可以发现此类错误的存在。

#### 6.3.1.3特权级别

特权的概念是通过为处理器识别的键对象分配一个从零到三的值来实现的。此值称为特权级别。值零表示最大特权，值三表示最小特权。以下处理器识别的对象包含特权级别：

- 描述符包含一个称为描述符特权级别（DPL）的字段。
- 选择器包含一个称为请求者的特权级别（RPL）的字段。RPL旨在代表发起选择器的过程的特权级别。
- 内部处理器寄存器记录当前特权级别（CPL）。通常，CPL等于处理器当前正在执行的段的DPL。随着控制权转移到具有不同DPL的段，CPL会发生变化。

处理器通过将CPL与一个或多个其他特权级别进行比较，自动评估过程访问另一段的权限。在将描述符的选择器加载到段寄存器中时执行评估。用于评估对数据的访问权的标准与评估控制权向可执行段的转移的标准不同。因此，以下各节将分别考虑这两种类型的访问。

下图显示了如何将这些特权级别解释为保护环。中心用于包含最关键软件的段，通常是操作系统的内核。外圈用于不太重要的软件。

不必使用所有四个特权级别。设计为仅使用一个或两个特权级别的现有软件可以简单地忽略80386提供的其他级别。两级系统应使用零和三级特权。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-2.gif)

### 6.3.2限制数据访问

要对内存中的操作数进行寻址，80386程序必须将数据段的选择器加载到数据段寄存器（DS，ES，FS，GS，SS）中。处理器通过比较特权级别自动评估对数据段的访问。在将目标段描述符的选择器加载到数据段寄存器中时执行评估。正如 下图所示，

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-3.gif)

三种不同的权限级别进入这个类型的权限检查：

1. CPL（当前特权级别）。
2. 用于指定目标段的选择器的RPL（请求者的特权级别）。
3. 目标句段描述符的DPL。

仅当目标段的DPL在数值上大于或等于CPL和选择器的RPL的最大值时，指令才可以加载数据段寄存器（并随后使用目标段）。换句话说，过程只能访问特权级别相同或更低的数据。

任务的可寻址域随CPL的变化而变化。当CPL为零时，可以访问所有特权级别的数据段。当CPL为1时，仅可访问特权级别为1到3的数据段；当CPL为3时，仅可访问特权级别3的数据段。80386的此属性可用于例如防止应用程序过程读取或更改操作系统的表。

####6.3.2.1在代码段中访问数据

比使用数据段少见的是使用代码段来存储数据。代码段可以合法地保存常量；无法写入描述为代码段的段。可以使用以下方法访问代码段中的数据：

1. 使用不合格，可读，可执行段的选择器加载数据段寄存器。
2. 用合格，可读，可执行段的选择器加载数据段寄存器。
3. 使用CS覆盖前缀可以读取可读的可执行段，其选择器已加载到CS寄存器中。

与访问数据段相同的规则适用于情况1。情况2始终有效，因为其一致性位被设置的段的特权级别实际上与CPL相同，而与DPL无关。情况3始终有效，因为根据定义，CS中代码段的DPL等于CPL。

### 6.3.3限制控制转移

使用80386，控制传输通过指令 JMP， CALL， RET， INT和IRET以及异常和中断机制来完成。异常和中断是第9章 介绍的特殊情况 。本章仅讨论JMP， CALL和RET指令。

JMP，CALL和 RET 的“近”形式在当前代码段内传输，因此仅受限制检查。处理器确保JMP， CALL或 RET指令的目的地不超过当前可执行段的限制。该限制被缓存在CS寄存器中。因此，对近距离传输的保护检查不需要额外的时钟周期。

JMP和 CALL 的“远”形式的操作数是 指其他段。因此，处理器执行特权检查。JMP或 CALL可以通过两种方式 引用另一个段：

1. 操作数选择另一个可执行段的描述符。
2. 操作数选择一个呼叫门描述符。这种转移的门控形式将在后面有关呼叫门的部分中进行讨论。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-4.gif)

如上图所示，两个不同权限级别进入一个特权支票不使用调用门控制转移：

1. CPL（当前特权级别）。
2. 目标句段描述符的DPL。

通常，CPL等于处理器当前正在执行的段的DPL。但是，如果在当前可执行段的描述符中设置了合格位，则CPL可能大于DPL。处理器将缓存在CS寄存器中的CPL记录保留下来；此值可以与代码段的描述符中的DPL不同。

仅当满足以下特权规则之一时， 处理器才允许 JMP或 CALL直接到另一个段：

- 目标的DPL等于CPL。
- 设置目标代码段描述符的合格位，并且目标的DPL小于或等于CPL。

描述符具有合格位集的可执行段称为合格段。一致性段机制允许共享可以从各种特权级别调用但应在调用过程的特权级别执行的过程。此类过程的示例包括数学库和某些异常处理程序。当控制权转移到合格段时，CPL不变。这是CPL可能不等于当前可执行段的DPL的唯一情况。

大多数代码段不符合要求。上面的基本特权规则意味着，对于不合格的段，可以在没有门的情况下将控制权仅转移到具有相同特权级别的可执行段。但是，需要将控制转移到（数量上）较小的特权级别。与呼叫门描述符一起使用时，CALL指令可满足此需求 ，这将在下一部分中进行说明。在 JMP指令可以控制从不转移到不合格段，其DPL不等于CPL。

### 6.3.4门描述符保护程序入口点

为了保护不同特权级别的可执行段之间的控制传递，80386使用了门描述符。门描述符有四种：

- Call gates
- Trap gates
- Interrupt gates
- Task gates

本章仅涉及呼叫门。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-5.gif)

上图说明了呼叫门的格式。呼叫门描述符可以驻留在GDT或LDT中，但不能驻留在IDT中。呼叫门具有两个主要功能：

1. 定义过程的入口点。
2. 指定入口点的特权级别。

呼叫和跳转指令以与代码段描述符相同的方式使用呼叫门描述符。当硬件识别出目的地选择器引用了门描述符时，指令的操作将扩展，如调用门的内容所确定。

门的选择器和偏移量字段形成指向过程入口点的指针。调用门保证所有到另一个段的转换都进入一个有效的入口点，而不是可能进入过程的中间（或更糟的是进入指令的中间）。控制转移指令的远指针操作数不指向目标指令的段和偏移量；而是指针的选择器部分选择一个门，并且不使用偏移量。 下图说明了这种寻址方式：

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-6.gif)

四个不同的权限级别用于检查经由呼叫栅极的控制传输的有效性：

1. CPL（当前特权级别）。
2. 选择器的RPL（请求者的特权级别），用于指定呼叫门。
3. 门描述符的DPL。
4. 目标可执行段的描述符的DPL。

门描述符的DPL字段确定可以使用该门的特权级别。一个代码段可以具有多个旨在供不同特权级别使用的过程。例如，一个操作系统可能具有一些旨在供应用程序使用的服务，而其他服务可能仅旨在供其他系统软件使用。

门可以用于将控制转移到数值上较小的特权级别或相同特权级别（尽管对于转移到同一级别不是必需的）。只有 CALL指令才能使用门来转移到较小的特权级别。JMP 指令仅可将门用于 传输到具有相同特权级别的可执行段或转换到符合的段。

对于针对不合格段的 JMP指令，必须同时满足以下两个特权规则；否则，将导致一般保护例外。

```
MAX (CPL,RPL) <= gate DPL
target segment DPL = CPL
```

对于CALL指令（或对于符合条件的段的 JMP指令），必须同时满足以下两个特权规则；否则，将导致一般保护例外。

```
MAX (CPL,RPL) <= gate DPL
target segment DPL <= CPL
```

#### 6.3.4.1堆叠切换

如果呼叫门的目标代码段的特权级别不同于CPL，则请求进行层间转移。为了维护系统完整性，每个特权级别都有一个单独的堆栈。这些堆栈可确保有足够的堆栈空间来处理特权级别较低的调用。没有它们，如果调用过程没有在调用者的堆栈上提供足够的空间，则受信任过程将无法正常工作。

处理器通过任务状态段定位这些堆栈。每个任务都有一个单独的TSS，从而允许任务具有单独的堆栈。系统软件负责创建TSS，并在其中放置正确的堆栈指针。TSS中的初始堆栈指针是严格的只读值。在执行过程中，处理器永远不会更改它们。

当使用呼叫门来更改特权级别时，通过从任务状态段（TSS）加载指针值来选择新堆栈。处理器使用目标代码段（新的CPL）的DPL为PL 0，PL 1或PL 2索引初始堆栈指针。

新堆栈数据段的DPL必须等于新的CPL；如果不是，则发生堆栈异常。系统软件负责为使用的所有特权级别创建堆栈和堆栈段描述符。每个堆栈必须包含足够的空间来容纳旧的SS：ESP，返回地址以及处理调用可能需要的所有参数和局部变量。

与内部调用一样，子例程的参数也放在堆栈中。为了使特权转换对调用的过程透明，处理器将参数复制到新堆栈中。呼叫门的计数字段告诉处理器要从调用者的堆栈复制到新堆栈的双字（最多31个）。如果计数为零，则不会复制任何参数。

处理器在执行层间call时执行以下与堆栈相关的步骤。

1. 检查新堆栈以确保其足够大以容纳参数和链接；如果不是，则发生堆栈错误，错误代码为0。
2. 堆栈寄存器SS：ESP的旧值作为两个双字被压入新堆栈。
3. 参数已复制。
4. call指令（CS：EIP的前一个值）之后的指令指针 被压入新堆栈。SS：ESP的最终值指向新堆栈上的此返回指针。

TSS没有特权级别3堆栈的堆栈指针，因为特权级别3不能由任何其他特权级别的任何过程调用。

可能从另一个特权级别调用的过程，并且需要超过31个双字作为参数的过程，必须使用保存的SS：ESP链接来访问最后复制的双字之外的所有参数。

通过调用门的调用不会检查复制到新堆栈上的单词的值。被调用的过程应检查每个参数的有效性。

#### 6.3.4.2从过程返回

当前代码段内 的RET指令传输控制的“近”形式， 因此仅受限制检查。从堆栈弹出相应CALL之后的指令偏移量 。处理器确保此偏移量不超过当前可执行段的限制。

RET指令 的“ far”形式 弹出由先前的far CALL指令压入堆栈的返回指针 。在正常情况下，由于返回指针与先前的CALL或 INT有关，因此返回指针是有效的。但是，由于当前过程更改了指针或无法正确维护堆栈，因此处理器执行特权检查。通过返回指令从堆栈弹出的CS选择器的RPL标识了调用过程的特权级别。

段间返回指令可以更改特权级别，但只能更改特权级别较低的过程。当 RET指令遇到RPL在数值上大于CPL的已保存CS值时，将发生层间返回。这样的回报遵循以下步骤：

1. 进行了表6-3中所示的检查，并且CS：EIP和SS：ESP加载了以前保存在堆栈中的值。
2. 旧的SS：ESP（从当前堆栈的顶部开始）值由RET指令中指示的字节数调整 。所得的ESP值不与堆栈段的限制进行比较。如果ESP超出了限制，则在下一个堆栈操作之前不会识别该事实。（不保留返回过程的SS：ESP值；通常，该值与TSS中包含的值相同。）
3. 检查DS，ES，FS和GS段寄存器的内容。如果这些寄存器中的任何一个引用的DPL都大于新CPL的段（不包括合格代码段），则该段寄存器将装入空选择器（INDEX = 0，TI = 0）。在 RET指令本身没有信号在这些情况下的例外; 但是，任何后续尝试使用包含空选择器的段寄存器的内存引用都将导致一般保护异常。这样可以防止特权级别较低的代码使用段寄存器中保留的选择器来访问特权级别较低的代码，以访问更多特权段。

### 6.3.5位操作系统保留一些说明

有权影响保护机制或影响总体系统性能的指令只能由受信任的过程执行。80386有两类此类指令：

1. 特权指令-用于系统控制的指令。
2. 敏感指令-用于I / O和I / O相关活动的指令。

##6.3.6指针验证说明

指针验证是定位编程错误的重要组成部分。指针验证对于维持特权级别之间的隔离是必需的。指针验证包括以下步骤：

1. 检查指针的提供者是否有权访问该段。
2. 检查段类型是否适合其预期用途。
3. 检查指针是否违反了段限制。

尽管80386处理器会在指令执行期间自动执行检查2和3，但是软件必须协助执行第一次检查。为此提供了非特权指令 ARPL。软件还可以显式执行第2步和第3步，以检查潜在的违规情况（而不是等待异常）。为此提供了非特权指令LAR，LSL，VERR和VERW。

LAR（加载访问权限）用于验证指针是否指向具有适当特权级别和类型的段。LAR有一个用于描述符的操作数选择器，该描述符的访问权限将被检查。描述符必须在特权级别上可见，特权级别是CPL和选择器的RPL的最大值。如果描述符是可见的，则 LAR获得该描述符的第二个双字的掩码形式，用00FxFF00H掩码此值，将结果存储到指定的32位目标寄存器中，并设置零标志。（x表示未定义存储值的相应四位。）一旦加载，就可以测试访问权限位。LAR可以测试所有有效的描述符类型 指令。如果RPL或CPL大于DPL，或者选择器超出表限制，则不返回任何访问权限值，并且清零标志。可以从任何特权级别访问一致的代码段。

LSL （负载分段限制）允许软件测试描述符的限制。如果给定选择器表示的描述符（在内存或寄存器中）在CPL上可见，则 LSL将指定的32位寄存器加载一个32位，字节粒度的，未加扰的限制，该限制是根据分段的限制字段和G计算得出的位的描述符。只能对段（数据，代码，任务状态和本地描述符表）执行此操作；门描述符不可访问。。解释限制是段类型的函数。例如，向下扩展的数据段与代码段对待限制的方式不同。对于LAR和 LSL，如果执行加载，则设置零标志（ZF）；否则，将清除ZF。

#### 6.3.5.1描述符验证

80386有两条指令， VERR和 VERW，它们确定选择器是否指向可以在当前特权级别读取或写入的段。如果结果为负，则任何一条指令都不会引起保护错误。

VERR（验证读取）验证要读取的段，如果从当前特权级别可以读取ZF，则将ZF装入1。 VERR检查：

- 选择器指向GDT或LDT范围内的描述符。
- 它表示代码或数据段描述符。
- 该段是可读的，并且具有适当的特权级别。

数据段和不合格代码段的特权检查是DPL在数值上必须大于或等于CPL和选择器的RPL。不检查符合条件的段的特权级别。

VERW（书写验证）提供与VERR相同的功能来验证可写性。与VERR指令类似 ，如果可写性检查结果为肯定，则 VERW加载ZF。该指令检查描述符是否在边界之内，是否为段描述符，是否可写以及其DPL在数值上是否大于或等于CPL和选择器的RPL。代码段永远不可写，不符合。

#### 6.3.6.2指针完整性和RPL

请求者的特权级别（RPL）功能可以防止对指针的不当使用，这些指针可能破坏特权级别较低的特权代码或数据的操作。

一个常见的示例是文件系统过程FREAD（file_id，n_bytes，buffer_ptr）。该假设过程将文件中的数据读取到缓冲区中，并覆盖其中的任何内容。通常，FREAD在用户级别可用，仅提供指向位于特权级别并在特权级别运行的文件系统过程和数据的指针。通常，这样的过程会阻止用户级过程直接更改文件表。但是，在没有用于检查指针有效性的标准协议的情况下，用户级过程可以将指针提供到文件表中，以代替其缓冲区指针，从而导致FREAD过程不经意间破坏它们。

使用RPL可以避免此类问题。RPL字段允许将特权属性分配给选择器。该特权属性通常将指示生成选择器的代码的特权级别。80386处理器会自动检查加载到段寄存器中的任何选择器的RPL，以确定RPL是否允许访问。

为了利用处理器对RPL的检查，被调用过程仅需要确保传递给它的所有选择器的RPL至少与原始调用者的CPL相同（数字上）。此操作可确保选择器不比其供应商更受信任。如果使用选择器之一访问调用者将无法直接访问的段，即RPL在数值上大于DPL，则当将该选择器加载到段寄存器中时，将导致保护错误。

ARPL （调整请求者的特权级别）将选择器的RPL字段调整为原始值和指定寄存器中RPL字段的值中的较大者。后者通常是从堆栈中调用方的CS寄存器的映像加载的。如果调整更改了选择器的RPL，则会设置ZF（零标志）；否则，将置零。否则，将清除ZF。

## 6.4页面级保护

与页面相关的两种保护：

1. 可寻址域的限制。
2. 类型检查。

### 6.4.1页表条目保护参数

下图突出显示了控制页面访问的PDE和PTE的字段。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig6-10.gif)

#### 6.4.1.1限制可寻址域

通过将每个页面分配给两个级别之一来实现页面特权的概念：

1. 主管级别（U / S = 0）-用于操作系统和其他系统软件以及相关数据。
2. 用户级别（U / S = 1）-用于应用程序和数据

当前级别（U或S）与CPL有关。如果CPL为0、1或2，则处理器将在主管级别执行。如果CPL为3，则处理器正在用户级别执行。当处理器在主管级别执行时，所有页面都是可寻址的，但是，当处理器在用户级别执行时，仅属于用户级别的页面是可寻址的。

#### 6.4.1.2类型检查

在页面寻址级别，定义了两种类型：

- 只读访问（R / W = 0）
- 读/写访问权限（R / W = 1）

当处理器在主管级别执行时，所有页面都是可读和可写的。当处理器在用户级别执行时，只有属于用户级别并标记为可读写访问的页面才可写；属于主管级别的页面在用户级别上既不可读也不可写。

###6.4.2合并两个级别的页表的保护

对于任何一页，其页面目录条目的保护属性可能与其页面表条目的保护属性不同。80386通过检查目录和页表中的保护属性来计算页面的有效保护属性。

### 6.4.3覆盖页面保护

即使CPL = 3，也会将某些访问视为特权级别0引用进行检查：

- LDT，GDT，TSS，IDT参考。

- 在CALL / INT穿越过程中访问内部堆栈 。

## 6.5合并页面和段保护

启用分页后，80386首先评估段保护，然后评估页面保护。如果处理器在段或页面级别检测到保护违规，则请求的操作无法继续；而是发生保护异常。

例如，可以定义一个大数据段，该数据段具有一些只读的子单元和其他可读写的子单元。在这种情况下，只读子单元的页面目录（或页面表）条目会将U / S和R / W位设置为x0，这表示该目录条目（或对于个别页面）。例如，可以在类似UNIX的系统中使用此技术来定义大数据段，该数据段的一部分是只读的（对于共享数据或ROMmed常数）。这使类UNIX系统可以将“平面”数据空间定义为一个大段，使用“平面”指针在该“平面”空间中寻址，但仍能够保护共享数据，映射到虚拟空间的共享文件，以及主管区域。