---
layout:     post   				    # 使用的布局（不需要改）
title:      进程与线程的区别				# 标题 
subtitle:   计算机网络 #副标题
date:       2022-03-02 				# 时间
author:     谢玄xx 						# 作者
header-img: img/bit (1).jpg 	#这篇文章标题背景图片2022-03-02 
catalog: true 						# 是否归档
tags:								#标签
    - 操作系统
---

* **导航窗格**
	* [进程与线程简介](#进程与线程简介)
	* [进程与线程的区别](#进程与线程的区别)
	* [什么是多进程？](#什么是多进程？)
	* [什么是多线程？](#什么是多线程？)
	* [不同场景下，多进程/多线程该如何选择？](#不同场景下，多进程/多线程该如何选择？)


# 进程与线程简介

## 进程

* 进程是对运行时程序的封装，是**系统**进行资源调度和分配的的基本单位，实现了操作系统的并发； 
* 进程操作系统进行资源分配和调度的基本单位，多个进程之间相互独立；
* 进程稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制

## 线程
* 线程是进程的子任务，是**CPU**调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；
* 线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。
* 如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃。


# 进程与线程的区别

1. 一个线程只属于一个进程，而一个进程可以有多个线程(请注意，一个进程至少需要有一个进程，不能空)。线程依赖于进程而存在；
2. 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 （资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
4. 系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
5. 通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。
6. 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
7. 进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。
8. 进程适应于多核、多机分布；线程适用于多核。

# 什么是多进程？

* 进程其实是资源的分配的单位，包括代码、内存、CPU等等，多进程类似**程序的多开**，比如qq的多开。

```CPP
//强转c++，可能有误，理解意思即可
import multiprocessing
import time

void test1(){
    while(true)
    {
        cout << "--- this is process 1 ---" << endl;
        time.sleep(2);
    }
}
        
void test2(){
    while(true)
    {
        cout << "--- this is process 2 ---" << endl;
        time.sleep(2);
    }
}
int main():
    t1 = multiprocessing.Process(target=test1);
    t2 = multiprocessing.Process(target=test2);
    t1.start();
    t2.start();
    return 0;
```
* 多进程工作的原理：在主进程下，子进程1和子进程2分别复制了主进程的代码以及资源，而子进程1则只运行test1这个函数，子进程2则只运行test2这个函数，进程之间的全局变量互不影响，对资源的开销比较大。
* 打开任务管理器，结束任意子进程，发现主进程和子进程2没有受到影响，仍然继续运行，而当我们结束主进程的时候，所有子进程全部结束。

## 多进程的优点

1. 每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；
2. 通过增加CPU，就可以容易扩充性能；
3. 可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；
4. 每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大。

## 多进程的缺点

1. 逻辑控制复杂，需要和主程序交互；
2. 需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算 多进程调度开销比较大；
3. 最好是多进程和多线程结合，即根据实际的需要，每个CPU开启一个子进程，这个子进程开启多线程可以为若干同类型的数据进行处理。当然你也可以利用多线程+多CPU+轮询方式来解决问题……
4. 方法和手段是多样的，关键是自己看起来实现方便有能够满足要求，代价也合适。

# 什么是多线程？

* 在一个进程中我们也可以使用多任务，这就是线程，线程是操作系统资源调度的单位。多线程可以**共享全局变量**。
* 多线程并不会复制主进程的代码和资源，而是共享全局变量。相比多进程来说，资源开销更加小。
* 在同一时间，子线程会同时运行，实现多任务，而他们会共享全局变量。

## 多线程的优点

1. 无需跨进程边界；
2. 程序逻辑和控制方式简单；
3. 所有线程可以直接共享内存和变量等；
4. 线程方式消耗的总资源比进程方式好。

## 多线程的缺点

1. 每个线程与主程序共用地址空间，受限于2GB地址空间；
2. 线程之间的同步和加锁控制比较麻烦；
3. 一个线程的崩溃可能影响到整个程序的稳定性；
4. 到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；
5. 线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU。

# 不同场景下，多进程/多线程该如何选择？

1. 需要频繁创建销毁的优先用线程
这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的

2. 需要进行大量计算的优先使用线程
所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
这种原则最常见的是图像处理、算法处理。

3. 强相关的处理用线程，弱相关的处理用进程
什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了：
一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。
当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。

4. 可能要扩展到多机分布的用进程，多核分布的用线程

5. 都满足需求的情况下，用你最熟悉、最拿手的方式
至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。
需要提醒的是：虽然给了这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。

6. 在Linux下编程多用多进程编程，少用多线程编程；

7. 多线程比多进程性能高？误导！——应该说，多线程比多进程成本低，但性能更低。

多进程是立体交通系统，虽然造价高，上坡下坡多耗点油，但是不堵车；
多线程是平面交通系统，造价低，但红绿灯太多，老堵车。
我们现在都开跑车，油（主频）有的是，不怕上坡下坡，就怕堵车。






