---
layout:     post   				    # 使用的布局（不需要改）
title:      统计朋友圈数目				# 标题 
subtitle:    #副标题
date:       2022-05-06 				# 时间
author:     谢玄xx						# 作者
header-img: img/bit (6).jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - dfs
    - bfs
    - union
---

# 写在前面

* 第一次遇到这个问题，对于未能现场bug-free通过耿耿于怀，遂将此题记录下来，尝试使用多种方法解决该问题。

# 题目描述

班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有传递性：如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。之后返回全部学生朋友圈的数目，类型为整型。

* 示例1:

输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。  


* 示例2:

输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。


# 问题分析

本题可用多种方法解决——dfs, bfs, 图, union。扎实的基础才是解决问题的核心所在哇。

# 解决思路

## 广度优先搜索(bfs)


## 代码如下：

```CPP
class Solution {
    //查找和第i个学生为同一朋友圈的学生 
    void find(vector<vector<int>>& nums,int i, vector<bool>& visited)
    {
        visited[i] = true;
        for(int j=0; j< nums.size(); j++)
        {
            if(nums[i][j] == 0 || visited[j] == true) continue; //这句话是关键
            find(nums,j,visited);
            
        }
    }
public:
    int findCircleNum(vector<vector<int>>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int res=0;
        vector<bool> visited(n, false); //学生是否被归入某一朋友圈
        for(int i = 0; i < n; i++)
        {
            if(visited[i] == true) continue;
            find(nums, i, visited);
            res++;
        }
        return res;
    }
};
```

## 深度优先搜索(dfs)

## 代码如下：

```CPP

```

## union思想

## 代码如下：

```CPP

```
## 并查集思想

并查集是判断元素是否在统一集合中的数据结构。
最开始，每个元素都在一个单独的集合里，集合的顶点就是自己；当有相同集合的元素合并之后，他们就在同一集合里，且元素值相等。

* 并查集的缺点：如果发生不恰当的合并动作，可能造成查询时间过长的结果(因为需要遍历集合)。

## 代码如下：

```CPP

```
