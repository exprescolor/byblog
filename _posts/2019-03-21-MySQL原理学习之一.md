---
layout:     post
title:      MySQL 原理学习之一
subtitle:   MySQL
date:       2019-03-21
author:     WY
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - MySQL
---



# MySQL原理学习之一 #

>MySQL大体可以分成Server层和存储引擎两部分,存储引擎有多个,但都共用一个Server层.

### 运行流程

1.客户端连接连接器,并做相应的权限验证

2.连接器首先去查询缓存,如果命中则 直接返回结果

3.缓存没有命中时, 分析器做词法语法分析

4.优化器执行计划,根据索引重新排序和优化语句

5.执行器操作引擎,返回结果

6.存储引擎存储数据,提供读写接口

> 备注:当一个用户成功建立连接,之后的操作权限都基于此次读取到的连接的权限.

- `wait_timeout`参数控制连接器的时长,默认8小时无反应则自动断开,断开后可重新连接,执行请求
- 长连接:客户端持续请求,则一直使用同一个连接
- 短连接:每次执行完几个查询就断开连接,下次查询重新建立
- 连接过程比较复杂,则尽量使用长连接,减少建立连接的动作

#### 长连接带来的问题和解决方案

- 因为MySQL临时使用的内存是存在连接对象中,断开连接才会释放,所以一直长连接就会导致内存占用太大,被系统杀掉.
- 解决方案
  - 定期断开长连接,程序判断当执行一个内存占用过大的查询后,断开连接,之后重连查询
  - 5.7版本,通过执行`mysql_reset_connection`来重新初始化连接资源,此过程不需重连和验证.

### 查询缓存

> MySQL语句执行前,会先到缓存中看看是否之前执行过相同的语句,命中则返回,但通常来说除非静态表或更新频率较低表的能命中外,失败概率很高

`query_cache_type`设置`DEMAND`,默认不使用查询缓存

`SQL_CHCHE`显示设置使用查询缓存,如

```mysql
select SQL_CACHE * from x where id = 1;
```



### 日志系统

#### redo log 重做日志

> 更新语句如果每次都需要写入磁盘,磁盘查找对应记录,然后更新,其中`IO`成本,查找成本较高

- 先写日志,再写磁盘的方式
- 当一条记录需要更新,InnoDB引起会先把记录写到 `redo log`中,并更新内存,在适当时候再将操作记录更新到磁盘里面
- `innodb_flush_log_at_trx_commit =  1`,表示每次事务的 `rodo log`都直接持久化磁盘,可以保证MySQL异常重启后数据不丢失

#### binlog 归档日志

> sysnc_binlog = 1 , 表示每次事务的binlog都持久化到磁盘.

- 与redo log不同点
  - redo log日志隶属于InnoDB引擎层; binlog隶属于Server层,每个引擎都可使用
  - redo log 是物理日志;biglog是 逻辑日志
  - redo log 是循环写,空间固定会用完; biglog 是可以追加写入,不会覆盖以前的日志




### 事务隔离

#### 隔离性的概念

> 当数据库上有多个事务同时执行时,就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。

#### 隔离级别

- 读未提交

  - 一个事务还没提交时,它的变更就能被别的事务看到
- 读提交
  - 一个事务提交后,变更才会被其他事务看到
- 可重复读
  - 一个事务执行过程中看到的数据,总是跟这个事务在启动时看到的数据是一致的,当然在可重复读隔离级别下,未提交变更对其他事务也是不可见的.
- 串行化
  - 对同一行记录, 读写都会加锁,当出现读写锁冲突的时候,后面访问的事务必须等到前一个事务执行完成,才能继续执行



### 索引

> 有序数组索引只适用于静态存储引擎

- 基于主键索引和普通索引的查询有什么区别?
  - `select * from T where ID = 500`,既主键查询的方式,只需要搜索ID这颗**B+树**
  - `select * from T where k = 5`,既普通索引查询方式,则需要先搜索K索引树,得到ID的值,在到ID索引树搜索一次.这个过程称为回表.

#### 索引维护

> B+树为了维护索引的有序性,在插入新值的时候需要做必要的维护

- 假如我要给R5的记录中间插入一个记录,但R5所在数据页已满,这时根据B+树算法,会申请一个新的数据页,挪动部分数据到新页中,这就叫页分裂
- 有分就有合,当相邻的两个页删除了数据,利用率降低,会将数据页合并.

**备注**:自增主键的插入数据模式,都是追加操作,不涉及挪动其他记录,也不会触发叶子节点的分裂

#### 覆盖索引

> `select ID from T where k between 3 and 5`,这时不需要回表,因为ID值已经在k索引树上了,因此索引k已经覆盖了查询需求,称之为覆盖索引

- 覆盖索引可以 减少树的搜索次数,显著提高查询性能,所以使用覆盖索引是一个常用的性能优化手段

#### 建立联合索引时,如何安排索引内的字段排序

- 如果通过调整顺序,可以少维护一个索引.那么这个顺序就需要优先考虑采用

### 全局锁和表锁

> 根据加锁的范围,MySQL大致可以分成全局锁,表级锁,行锁三类

#### 全局锁

- 对整个数据库实例加锁
- 方法: `Flush tables with read lock (FTWRL)`
- 会使整个库处于只读状态,其他线程语句将被阻塞
- **场景**:做全库逻辑备份
- 问题
  - 在主库上备份,则备份期间都不能执行更新
  - 从库备份,则备份期间从库不能执行主库同步过来的binlog.会导致主从延迟
- 方案
  - 可重复读隔离级别下开启一个事务
  - `mysqldump`使用参数`-single-transaction`,导数据之前就会启动一个事务,来确保拿到一致性视图.由于**MVCC**的支持,数据可以正常更新
  - 前提是引擎要支持这个隔离级别
    - `single-transaction`只适用于使用事务引擎的库,替代是用**FTWRL**方法	
- 不使用`set global readonly = true`的原因
  - readonly的值会被用来做其他逻辑,如判读库是否是主库或备库
  - 异常处理机制差异,客户端如果发生异常,则数据库会一直保持readonly状态,会导致整个库长时间处于不可写状态.**FTWRL**则会释放这个全局锁

#### 表级锁

> 表级锁有两种:一种是表锁,一种是元数据锁 (meta data lock, MDL), MDL不需要显示使用,在访问一个表时会被自动加上,确保读写的正确性

**表锁语法: **`lock tables ... read / write`

**释放锁:**`unlock tables`

**事务中的MDL锁,在语句执行开始时申请,语句结束后并不会马上释放,而是等到整个事务提交后在释放**

- 如何安全的给小表加字段

  - 在alter table 语句设定等待时间,如果指定时间拿不到MDL写锁,先放弃,不要阻塞后面的业务语句.

    `ALTER TABLE t NOWAIT add column`

    `ALTER TABLE t WAIT N add  column`

    ​

#### 行锁

> 如果事务中需要锁多个行,要把最可能造成锁冲突,最可能影响并发度的锁尽量后放

#### 死锁和死锁检测

> 当并发系统中不同线程出现循环资源依赖,涉及的线程都在等待别的线程释放资源,就会导致这个线程进入无线等待的状态,称为死锁.

- 死锁后策略
  - 直接进入等待,直到超时.可通过参数 `innodb_block_wait_timeout`设置,默认为50s
  - 死锁检测,发现死锁后,主动回滚死锁链条中的某一事务,让其他事务的以继续,`innodb_deadlock_detect`设置为`on`,表示开启
- 死锁检测要耗费大量CPU资源,怎么解决由于热点行更新导致性能问题?
  - 如果确保业务不会出现死锁,可以临时把死锁检测关闭
  - 控制并发度