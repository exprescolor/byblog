---
layout:     post                        # 使用的布局（不需要改）
title:      NIO高级及Netty入门 # 标题
subtitle:      # 副标题
date:       2020-06-10                  # 时间
author:     AhogeK                      # 作者
header-img: https://w.wallhaven.cc/full/md/wallhaven-md5rx1.jpg    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - NIO
    - Netty
---
### NIO高级
#### NIO 同步阻塞与同步非阻塞

IO（BIO）同步、阻塞IO；NIO（1.7之前）同步、非阻塞IO；1.7之后 AIO 异步非阻塞IO

#### IO(BIO)和NIO区别
> 其本质就是阻塞和非阻塞的区别

* 阻塞：应用程序在获取网络数据的时候，如果网络传输数据很慢，就会一直等待，直到传输完成为止
* 非阻塞：应用程序直接可以获取已经准备就绪好的数据，无需等待

##### 解决同步阻塞IO
（伪异步IO）多线程
*但伪异步并非真正阻塞问题，在大量并发下就无法支撑，可能会造成占用大量内存与CPU*

可以使用线程池解决频繁创建线程造成卡死

但线程池也不能真正解决阻塞IO的核心问题

NIO -- 同步非阻塞 通过 通道和缓冲区 
NIO中可以通过选择器，将数据注册到选择器，无需等待I/O操作完成

|   |同步阻塞I/O（BIO）|伪异步I/O|非阻塞I/O|异步I/O（AIO）|
|---|---|---|---|---|
|客户端个数：I/O线程|1:1|M:N(其中M可以大于N)|M:1(1个I/O线程处理多个客户端连接)|M:0(不需要启动额外的I/O线程，被动回调)
|I/O类型(阻塞)|阻塞I/O|阻塞I/O|非阻塞I/O|非阻塞I/O|

#### 选择器KEY
* SelectionKey.OP_CONNECT
* SelectionKey.OP_ACCEPT
* SelectionKey.OP_READ
* SelectionKey.OP_WRITE

*四个常量用来表示四种不同类型的事件：可读、可写、可连接、可接受连接，可以用'|'位或操作符将常量连接起来*

### Netty
#### 什么是 Netty
> Netty 是一个基于 JAVA NIO 类库的异步通信框架，Netty是异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性

分布式开源框架中 dubbo、Zookeeper、RocketMQ地层RPC通讯都是使用Netty。
游戏开发中，底层使用的也是Netty通讯。

#### 为什么使用Netty，而不建议直接使用NIO
1. NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等
2. 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序；
3. 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序；
4. JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决。

#### Netty服务器端示例
> 需要 Netty-IO 包

```java
class ServerHanlder extends SimpleChannelHandler {

	
	// 通道被关闭的时候会触发
	@Override
	public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
		super.channelClosed(ctx, e);
		System.out.println("channelClosed");
	}

	// 必须要建立连接，关闭通道的时候才会触发
	@Override
	public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
		super.channelDisconnected(ctx, e);
		System.out.println("channelDisconnected");
	}

	// 接收出现异常
	@Override
	public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
		super.exceptionCaught(ctx, e);
		System.out.println("exceptionCaught");
	}

	// 接收客户端数据
	@Override
	public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
		super.messageReceived(ctx, e);
		System.out.println("messageReceived");
		System.out.println("服务器获取客户端参数：" + e.getMessage());
	}
}

public class NettyServer {

	public static void main(String[] args) {
		// 1. 创建服务对象
		ServerBootstrap serverBootstrap = new ServerBootstrap();
		// 2. 创建两个线程池 第一个监听端口号 NIO监听
		ExecutorService boos = Executors.newCachedThreadPool();
		ExecutorService wook = Executors.newCachedThreadPool();
		// 3. 将线程池放入工程
		serverBootstrap.setFactory(new NioServerSocketChannelFactory(boos, wook));
		// 4. 设置管道工程
		serverBootstrap.setPipelineFactory(() -> {
			// 设置管道
			ChannelPipeline pipeline = Channels.pipeline();
			// 传输数据的时候直接为String类型
			pipeline.addLast("decoder", new StringDecoder());
			pipeline.addLast("encoder", new StringEncoder());
			// 设置事件监听类
			pipeline.addLast("serverHanlder", new ServerHanlder());
			return pipeline;
		});
		// 绑定端口号
		serverBootstrap.bind(new InetSocketAddress(2333));
		System.out.println("服务器端已经被启动！");
	}
}
```

#### Netty客户端示例

```java
public class NettyClient {

	public static void main(String[] args) {
		System.out.println("netty client 启动...");
		// 1. 创建客户端类
		ClientBootstrap clientBootstrap = new ClientBootstrap();
		// 2. 线程池
		ExecutorService boos = Executors.newCachedThreadPool();
		ExecutorService wooker = Executors.newCachedThreadPool();
		// 3. 将线程池放入工程
		clientBootstrap.setFactory(new NioServerSocketChannelFactory(boos, wooker));
		// 4. 设置管道工程
		clientBootstrap.setPipelineFactory(() -> {
			// 设置管道
			ChannelPipeline pipeline = Channels.pipeline();
			// 传输数据的时候直接为String类型
			pipeline.addLast("decoder", new StringDecoder());
			pipeline.addLast("encoder", new StringEncoder());
			// 设置事件监听类
			pipeline.addLast("serverHanlder", new ServerHanlder());
			return pipeline;
		});
		// 连接服务器
		ChannelFuture connect = clientBootstrap.connect(new InetSocketAddress("127.0.0.1", 2333));
		Channel channel = connect.getChannel();
		System.out.println("Client start");
		Scanner scanner = new Scanner(System.in);
		while (true) {
			System.out.println("请输入内容...");
			channel.write(scanner.next());
		}
	}
}
```