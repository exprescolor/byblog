---
layout:     post
title:      PHP与MySQL
subtitle:   基础复习
date:       2019-03-03
author:     WY
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - PHP
    - MySQL
---

## PHP引用变量的概念和定义方式

> 概念

- 在PHP中引用意味着用不同的名字访问同一个变量内容.

> 定义方式

- 使用   &  符号

> 工作原理

- COW copy on write
- 赋值并不会新开辟一块新的内存空间,只有当写操作发生时,才会新开一块内存.
- 查看内存使用情况函数: memory_get_usage()
- 使用引用的话,两个变量永远指向一个内存空间,写操作不会新开辟内存.
- 查看zval结构体函数: xdebug_debug_zval() 
  - 需要安装扩展
  - 结构体: refcount 指向内存空间的个数 is_ref 是否是引用
- unset只会取消引用,不会销毁空间



## MySQL数据类型

> varchar 

- 用于存储可变长度的字符串,它比定长类型更节省空间
- 使用1或2个额外字节记录字符串的长度,列长度小于255字节,使用1个字节表示,否则用2个
- 如果存储空间超过指定长度,会被截断

> char

- char 是定长的,根据定义的字符串长度分配足够的空间
- char会根据需要采用空格进行填充以方便比较
- 适合存储很短的字符串,或者 所有值都接近同一个长度
- 超出设定的长度,会被截断
- 对于经常变更的数据,char比varchar更好,char不容易产生碎片
- 对于非常短的列,char 比varchar在存储空间上更有效率

> 枚举

- 可以代替常用的字符串类型
- 把不重复的集合存储成一个预定义的集合
- 把列表值压缩成一个或两个字节
- 内部存储的是整数
- 尽量避免使用数字作为enum枚举的常量,易混乱
- 排序是按照内部存储的整数进行排序

> 日期和时间类型

- 尽量使用timestamp 比datetime空间效率高
- 用整数保存时间戳的格式通常不方便处理
- 如果需要存储微秒, 可以使用bigint存储

> MySQL锁机制

- 读索: 共享的,不堵塞,多个用户可以同时读一个资源,互不干扰
- 共享锁和排他锁,其实就是读锁和写锁
- 写锁: 排他的,一个写锁会阻塞其他的写锁和读锁.,只允许一个人写入,防止其他用户读取正在写入的资源

> 锁粒度

- 表锁,系统 性能开销最小,会锁定整张表,MyISAM使用表锁
- 行锁,最大程度地支持并发处理,但也带来最大的锁开销.InnoDB实现行级索

> 事务处理

- MySQL提供事务处理的 表引擎,InnoDB
- 服务器层不管理事务,由下层的引擎实现,所以同一个事务中,使用多种存储引擎不靠谱  
- 在非事务的表上执行事务操作MySQL不会发出提醒,也不会报错

> 存储过程

- 为以后的使用而保存的一条或多条MySQL语句的集合
- 存储过程就是有业务逻辑和流程的集合
- 可以在存储过程中创建表,更新数据, 删除等
- 使用场景
  - 通过把处理封装在容易使用的单元中,简化复杂的操作
  - 保证数据的一致性
  - 简化对变动的管理

> 触发器

- 提供给程序员和数据分析员来保证数据完整性的一种方法.它是与表事件相关的特殊的存储过程
- 使用场景
  - 可通过数据库中的相关表实现级联更改
  - 实时监控某张表中的某个字段的更改而需要做出相应的处理
  - 某些业务编号的生成
  - 滥用会造成数据库及应用程序的维护困难

### MySQL索引

> 索引的基础

- 索引类似书籍的目录,要想找到一本书的某个特定主题,需要先查找书的目录,定位对应的页码
- 存数引擎使用类似的方式进行数据查询.先去索引中找到对应的值,然后根据匹配的索引找到对应的数据行

> 索引对性能的影响

- 大大减少服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 将随机IO变成顺序IO
- 大大 提供查询速度.降低写的速度,占用磁盘
- 使用场景
  - 小表,大部分全表扫描效率更高
  - 特大表,建立和使用索引的代价将随之增长,可以使用分区表技术解决

> 索引的类型

- 索引有很多种类型,都是实现在存储引擎层的
- 普通索引:最基本的索引,没有任何约束限制
- 唯一索引:与普通索引类似,但是具有唯一性约束
- 主键索引:特殊的唯一索引.不许有空值
- 一个表只能有一个主键索引,可以有多个唯一索引
- 主键索引一定是唯一索引,唯一索引不是主键索引
- 主键可以与外键构成参照完整性约束,防止数据不一致
- 组合索引:将多个列组合在一起创建索引,可以覆盖多个列
- 外键索引: 只有InnoDB类型的表才可以使用.保证数据的一致性,完整性和实现联机操作
- 全文索引: MySQL自带的全文索引只能用于MyISAM,并且只能对英文进行全文检索
- 原则
  - 最适合索引的列是在where字句中的列,或连接字句中的列
  - 索引列基数越大, 效果越好
  - 对字符串进行索引,应该指定一个前缀长度,可以节省大量的 索引空间
  - 根据情况创建复合索引,可以提供查询效率
  - 避免创建过多索引,会额外占用磁盘空间,降低写操作效率
  - 主键尽量选择较短的数据类型,可以有效减少索引的磁盘占用提高查询效率
  - 复合索引遵循前缀原则
  - like查询, %不能在前,可以使用全文索引
  - column is null 可以使用索引
  - 如果mysql估计使用索引会比全表扫码更慢,会放弃使用索引
  - 如果or前的条件中的 列有索引,后面的没.索引不会被用到
  - 列类型是字符串,查询时一定要给值加引号,否则索引失效

### 查找分析查询速度慢的原因

- 使用show profile
- set profiling = 1; 开启,服务器上执行的所有语句会检测消耗的时间,存到临时表中
- show profiles
- show profile for query 临时表iD

> 使用show status

- show status 会返回一些计数器, show global status 查看服务器级别的所有计数
- 跟进计数,可以猜测哪些操作代价较高或者消耗时间多

> 使用show processlist

- 观察是否有大量线程处于不正常的状态或者特征

> 使用explain

- 分析单条sql语句

> 慢查询日志

### 优化查询过程中的数据访问

- 访问数据太多导致查询性能下降
- 确定应用程序是否在检索大量超过需要的数据,可能是太多行或列
- 确认mysql服务器是否在分析大量不必要的数据行

> 避免使用如下sql 语句

- 查询不需要的记录,使用limit解决
- 多表关联返回全部列,指定返回字段值
- 总是取出全部列,select* 会让优化器无法完成索引覆盖扫描的优化
- 重复查询相同的数据,可以缓存数据,下次直接读取缓存

> 是否在扫描额外的记录

- 使用explain来进行分析,如果发现查询需要扫描大量的数据但只返回少数的行,可以通过如下技巧去优化
- 使用索引覆盖扫描,把所有用的列都放到索引中,这样存储引擎不需要回表获取对应行就可以返回结果

> 改变数据库和表的结构,修改数据表的范式

- 重写sql语句, 让优化器可以以更优的方式执行查询

> 切分查询

- 将一个大的查询分为多个小的相同的查询
- 一次性删除1000万的数据要比一次删除1万, 暂停一会的方案更加损耗服务器开销

> 分解关联查询

- 可以将一条关联语句分解成多条sql来执行
- 让缓存的效率更高
- 执行单个查询可以减少锁的竞争
- 在应用层做关联可以更容易对数据库进行拆分

> 优化count() 查询

- count(*)中的 * 会忽略所有的列,直接统计所有的列数, 因此不要使用count( 列名)
- MyISAM中,没有where条件的count(*)非常快
- 当有where条件,MyISAM的count统计不一定比其他表引擎快
- 可以使用explain查询近似值,用近似值替代count(*)
- 增加汇总表,使用缓存 

> 优化关联查询

- 确定on 或者 using 字句的列上有索引
- 确保group by 和 order by 中只有一个表的列,这样MySQL才有可能使用索引

> 优化group by 和 distinct

- 使用索引优化
- 关联查询中,使用标识列进行分组的效率会更高
- 如果不需要order by , 进行group by 时使用order by null , MySQL不会在对文件排序
- with rollup 超级聚合, 可以挪到应用程序处理

> 优化limit分页

- limit偏移量大的时候,查询效率低
- 可以记录上次查询的最大id, 下次查询时直接跟进该id来查询

> 优化union查询

- union all 的效率高于union

### 分区表的原理

> 工作原理

- 对用户而言,分区表是一个独立的逻辑表,但是底层MySQL将其分成了多个物理子表,这对用户来说是透明的,每一个分区表都会使用一个独立的表文件
- 创建表时使用 `partition by`字句定义每个分区存放的数据,执行查询时,优化器会根据分区定义过滤那些没有我们需要数据的分区,这样查询只需要查询所需数据在的分区即可
- 分区的主要目的是将数据按照一个较粗的粒度分在不同的表中,这样可以将相关的数据存放在一起,而且如果想一次性删除整个分区的数据也很方便 

> 适用场景

1.表很大,无法全部存在内存,或者只在表的最后有热点数据,其他都是历史数据

2.分区表的数据更容易维护, 可以对独立的分区进行独立的操作

3.分区表的数据可以分布在不同的机器上,从而高效使用资源

4.可以使用分区表来避免某些特殊的瓶颈

5.可以备份和恢复独立的分区

> 限制

1.一个表最多只能有1024个分区

2.`5.1版本`中,分区表表达式必须是整数,`5.5`可以使用列分区

3.分区字段中如果有主键和唯一索引列,那么主键列和唯一列都必须包含进来

4.分区表中无法使用外键约束

5.需要对现有表的结构进行修改

6.所有分区都必须使用相同的存储引擎

7.分区函数中可以使用的函数和表达式会有一些限制

8.某些存储引擎不支持分区

9.对于MyISAM的分区表,不能使用 `load index into cache`

10.对应MyISAM表,使用分区表时需要打开更多的文件描述符



### 分库分表的原理

> 工作原理

通过一些HASH算法或者工具实现将一些数据表垂直或者水平进行物理切分

> 适用场景

1.单表记录条数达到百万到千万级别时

2.数据本身有独立性,如表中分别记录各个地区的数据或则好不同时期的数据.特别是有些数据常用,有些不常用

2.解决表锁的问题

> 分表方式

1.水平分割

- 分割后降低在查询是需要读的数据和索引的页数,同时也降低了索引的层数,提高查询速度
- 缺点
  - 给应用增加复杂度,通常查询时需要多个表名,查询所有数据都需`union`操作
  - 在许多数据库应用中,这种复杂性会超过它带来的优点,查询时会增加读一个索引层的磁盘次数

2.垂直分表

- 把主键和 一些列放在一个表,然后把主键和另外的列放在另一个表中

> 使用场景

1.如果一个表中某些列常用,而另外一些列不常用

2.可以使数据行变小,一个数据页能存储更多数据,查询时减少IO次数

3.缺点

- 管理冗余列,查询所有数据需要`join`操作

> 分表缺点

- 有些分表策略基于应用层的逻辑算法, 一旦逻辑算法改变,整个分表逻辑都会改变,扩展性较差

### MySQL的复制原理及负载均衡

> MySQL主从复制工作原理

- 把主库上的数据更改记录到二进制日志
- 从库将主库的日志复制到自己的中继日志
- 从库读取中继日志中的事件,将其重放到从库数据中

> MySQL主从复制解决的问题

- 数据分布: 随意停止或者开始复制, 并在不同地理位置分布数据备份
- 负载均衡: 降低单个服务器的压力
- 高可用和故障切换: 帮助应用程序避免单点失败
- 升级测试: 可以使用更高版本的MySQL作为从库

### SQL查询的安全方案

1.使用预处理语句防sql注入

2.写入数据库的数据要进行特殊字符的转义

3.查询错误信息不要返回给用户,将错误记录到日志中

4.定期做数据备份

5.不给查询用户root权限,合理分配权限

6.关闭远程访问数据库权限

7.使用较复杂的口令

8.删除多余的用户

9.改变root用户名称

10.限制一般用户浏览其他库

11.限制用户对数据文件的访问权限

