---
layout:     post   				    # 使用的布局（不需要改）
title:      STL底层逻辑汇总				# 标题 
subtitle:   NONE #副标题
date:       2022-04-07 				# 时间
author:     谢玄xx 						# 作者
header-img: img/bit (5).jpg 	#这篇文章标题背景图片2022-03-02 
catalog: true 						# 是否归档
tags:								#标签
    - 操作系统
    - STL
    - 底层逻辑
---

# map、unordered_map和multimap

## 实现机理：
* map是基于**红黑树**来实现的（红黑树是很是严格的平衡二叉搜索树），红黑树具备自动排序功能，红黑树的每个节点都表明着map中的一个元素，所以对于map的查找，删除和插入操做都是对红黑树的操作。
* unordered_map是基于**哈希表**来实现的，查找的时间复杂度是O(1),在海量数据处理中有着普遍的应用。

## 优缺点

* map的优势：（1）map是有序的（2）基于红黑树实现，查找的时间复杂度是O(N)；
* map的缺点：空间占用率比较高，由于内部实现了红黑树，虽然提升了运行效率，可是每一个节点都要保存父亲节点和孩子节点和红黑树的性质，使得每个节点都占用大量的空间。
适用的状况：对于要有序的结构，适用map；

* unordered_map的优势：由于内部是哈希表来实现的，因此查找效率会很高。
* unordered_map的缺点：哈希表的创建比较**费时**。
适用的状况：对于查找问题，适用unordered_map会更好一点。

## map的常用操作(代码)

```CPP
/*map中经常使用的操作
*begin()	还回指向map头部的迭代器
*clear()	删除全部元素，注意是全部元素
*count()	还回指定元素出现的次序
*empty()	若是map为空则还回true
*end()		还回指向map末尾的迭代器
*erase()	删除一个元素
*find()		查找一个元素
*insert()	插入一个元素
*max_size()	还回能够容纳的最大元素个数
*size()		还回map中元素的个数
*swap()		交换两个map
*/

int main() {
	map<int, char> m;
	//1、数据的插入
	m.insert(pair<int, char>(1, 'a'));
	m.insert(pair<int, char>(3, 'b'));
	m.insert(pair<int, char>(2, 'c'));
	m.insert(pair<int, char>(-1, 'd'));
	map<int, char>::iterator it = m.begin();
	for (; it != m.end(); it++) {
		cout << it->first << ":" << it->second << endl;
}
	//2、数据的查找
	/*（1）使用find()函数，该函数能够找到key对应的value
	（2）使用count()函数,该函数的还回值只有0和1，1为找到，可是还回要查找的值*/
	it = m.find(1);
	if (it != m.end()) { cout << "find" << it->second << endl; }
	else { cout << "not find" << endl; }

	//3、map的清空
	//m.clear(m.begin(), m.end());

	//4、数据的删除
	//m.erase(it);

	//5、map的反向遍历，使用反向迭代容器
	
	for (map<int, char>::reverse_iterator Rit = m.rbegin(); Rit!=m.rend(); Rit++) {
		cout << Rit->first << ":" << Rit->second;
	}
	return 0;
}
```

感谢CSDN大佬**浮生勿语**，该文章由本人根据大佬的文章整理而成。 原文链接：[C++ map和unordered_map的区别和联系以及map的使用](https://blog.csdn.net/qq_36381573/article/details/100622599)

# set、unordered_set和multiset

* unordered_set基于哈希表，是无序的，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。
* set基于红黑树实现，红黑树具有自动排序的功能，因此map内部所有的数据，在任何时候，都是有序的。它实现了**红黑树**的**平衡二叉搜索树**的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。
平衡二叉搜索树使用中序遍历算法，搜索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。

通用输入数据如下：
```CPP
vector<int> list;
    list.push_back(5);
    list.push_back(14);
    list.push_back(34);
    list.push_back(22);
    list.push_back(39);
    list.push_back(5);
```

## set




## unordered_set

* 头文件：#include<unordered_set>
* 介绍：std::unordered_set 是基于hash表的，因此并不是顺序存储。
* 代码：

```CPP
 unordered_set<int> set;
	for (int i=0; i<list.size(); i++)
	{
		set.insert(list[i]);
	}
	for (unordered_set<int>::iterator i = set.begin(); i != set.end(); i++) 
	{
		cout << *i << endl;
	}
	cout << " find 39: " << *set.find(39) << endl;
	cout << "count 14:" << set.count(5) << endl;
```
结果如下：

```CPP
UnorderdSet
22
39
34
14
5
find 39: 39
count 14:1
```

# vector

## push_back()emplace_back()的区别

push_back()向容器尾部添加元素时，⾸先会创建这个元素，然后再将这个元素拷贝（调⽤拷贝构造函数）或者移动（调⽤移动构造函数）到容器中（如果是拷贝的话，事后会⾃⾏销毁先前创建的这个元素）；
⽽emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。

# stack

# queue

# deque

# list
