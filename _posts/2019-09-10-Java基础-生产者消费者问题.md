---
layout:     post 
title:      Java基础0910生产消费
subtitle:   生产者消费者问题
date:       2019-09-10
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - 总结
---

# Java基础

### 生产者消费者问题

- 生产者和消费者在同一时间段内共用同一个存储空间，生产者向空间内存放数据，消费者却取用数据。如果不加协调的话会出现以下情况：
   - 存储空间已满，而生产者一直占用着它，消费者等着生产者让出空间从而去除产品，生产者等着消费者消费产品，从而向空间中添加产品。两者互相等待，从而发生死锁。

```java
public class ProducerConsumer{
	public static void main(String[] args){
		SyncStack ss=new SyncStack();
		Producer p=new Producer(ss);
		Consumer c=new Consumer(ss);
		new Thread(p).start();
		new Thread(c).start();
	}
}

class WoTou{
	int id;
	WoTou(int id){
		this.id=id;
	}
	public String toString(){
		return "WoTou:"+id;
	}
}

class SyncStack{
	int index=0;
	WoTou[] arrWT=new WoTou[6];
	
	public synchronized void push(WoTou wt){
		while(index==arrWT.length){
			try{
				this.wait();//当前的正在访问的对象的线程wait
			}
			catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		this.notifyAll();//叫醒一个正在该对象上等待的线程
		arrWT[index]=wt;
		index++;
	}
	
	public synchronized WoTou pop(){
		while(index==0){
			try{
				this.wait();//当前的正在访问的对象的线程wait
			}
			catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		this.notifyAll();
		index--;
		return arrWT[index];
	}
}

class Producer implements Runnable{
	SyncStack ss=null;
	Producer(SyncStack ss){
		this.ss=ss;
	}
	public void run(){
		for(int i=0;i<20;i++){
			WoTou wt=new WoTou(i);
			ss.push(wt);
			System.out.println("生产了："+wt);
			try{
				Thread.sleep((int)(Math.random())*1000);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}

class Consumer implements Runnable{
	SyncStack ss=null;
	Consumer(SyncStack ss){
		this.ss=ss;
	}
	public void run(){
		for(int i=0;i<20;i++){
			WoTou wt=ss.pop();
			System.out.println("消费了："+wt);
			try{
				Thread.sleep((int)(Math.random())*1000);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}
```