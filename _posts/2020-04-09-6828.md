---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partB(1)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-09 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# partB 页面错误、断点异常和系统调用

### 处理页面错误

​		页面错误异常，中断向量14 (T_PGFLT)，是一个特别重要的异常，我们将在这个实验和下一个实验中大量使用它。当处理器出现页面错误时，它会存储线性地址即在一个特殊的处理器控制寄存器CR2中引起错误的地址。在trap.c中，我们提供了一个特殊函数page_fault_handler()的开头，用于处理页面错误异常。

#### 练习5

修改一下 trap_dispatch 函数，使系统能够把缺页异常引导到 page_fault_handler() 上执行。在修改完成后，运行 make grade，出现的结果应该是你修改后的 JOS 可以成功运行 faultread，faultreadkernel，faultwrite，faultwritekernel 测试程序。

Trapframe 中的 tf_trapno 成员代表这个中断的中断码。我们判断这个中断是否是缺页中断：

```c
static void
trap_dispatch(struct Trapframe *tf)
{
    // Handle processor exceptions.
    // LAB 3: Your code here.
    if (tf->tf_trapno == T_PGFLT) {
        return page_fault_handler(tf);
    }   

    // Unexpected trap: The user process or the kernel has a bug.
    print_trapframe(tf);
    if (tf->tf_cs == GD_KT)
        panic("unhandled trap in kernel");
    else {
        env_destroy(curenv);
        return;
    }   
}
```

### 断点异常

​		断点异常，中断向量3 (T_BRKPT)，通常被用来允许调试器通过临时用特殊的1字节int3软件中断指令替换相关的程序指令来在程序代码中插入断点。在JOS中，我们将略微滥用这个异常，将它转换成一个原始的伪系统调用，任何用户环境都可以使用它来调用JOS内核监视器。如果我们将JOS内核监视器看作原始调试器，那么这种用法实际上是适当的。lib/panic中的panic()的用户模式实现。例如，c在显示其panic消息后执行int3。

### 练习6

修改trap_dispatch()以使断点异常调用内核监视器。您现在应该能够在断点测试中获得成功。

判断中断是否为断点中断 (T_BRKPT)，然后调用monitor.c中的内核监视器。

```c
if (tf->tf_trapno == T_BRKPT) {
	return monitor(tf);
}   
```

### 系统调用

​		用户进程通过调用系统调用来请求内核为它们做一些事情。当用户进程调用系统调用时，处理器进入内核模式，处理器和内核协同保存用户进程的状态，内核执行适当的代码来执行系统调用，然后恢复用户进程。用户进程如何获得内核的注意，以及它如何指定希望执行哪个调用的具体细节因系统而异。

​		在JOS内核中，我们将使用int指令，这将导致处理器中断。特别是，我们将使用int $0x30作为系统调用中断。我们已经为您定义了常数T_SYSCALL为48 (0x30)。您必须设置中断描述符，以允许用户进程引起中断。注意，硬件不能生成0x30中断，所以允许用户代码生成它不会造成歧义。

​		应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中进行查找。系统调用号将在%eax中，参数(最多5个)将分别在%edx、%ecx、%ebx、%edi和%esi中。内核将返回值传回%eax。已经在lib/syscall.c的syscall()中为您编写了调用系统调用的汇编代码。



