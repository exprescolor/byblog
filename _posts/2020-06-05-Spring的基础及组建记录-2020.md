---
layout:     post                        # 使用的布局（不需要改）
title:      Spring的基础及组建记录              # 标题
subtitle:     # 副标题
date:       2020-06-05                  # 时间
author:     AhogeK                      # 作者
header-img:   https://miro.medium.com/max/2000/1*gycg7f5bYLuR4ut_JAEs7A.png   # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - Spring
---
### Spring的基本XML配置
> 关于Spring的基本XML配置有许多可以讲的地方，详细可以参阅[官方文档](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/)，里面有各个组件配置方法,这里简单提议下基本的Bean配置

例如先包中创建一个Bean实例类，例如 Person,可以给他属性，构造及其Get/Set方法
```java
public class Person {
	private String name;
	private Integer age;
	
	public Person() {}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public Integer getAge() {
		return age;
	}
	
	public void setAge(Integer age) {
		this.age = age;
	}
	
	public Person(String name, Integer age) {
		super();
		this.name = name;
		this.age = age;
	}
	
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
}

```

随后就可以创建XML文件，简单的Bean定义就是通过``<bean>``标签,上面的代码中可以看到有个包含name及age属性的构造方法，在``<bean>``标签中，我们可以添加``<constructor-arg>``标签进行属性注入，也可以通过``<property>``标签进行属性注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
	<bean id="person" class="io.github.ahogek.cap1.Person">
		<property name="name" value="AhogeK" />
		<property name="age" value="21" />
	</bean>
</beans>
```

随后在测试类中，可以通过``ClassPathXmlAplicationContext``类来加载属性获取Bean实例

```java
public class MainTest1 {
	public static void main(String[] args) {
		ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("beans.xml");
		Person person = (Person) classPathXmlApplicationContext.getBean("person");
		System.out.println(person);
	}
}

```

### Spring @Configuration注解
上面，我们我使用了XML文件进行Spring的配置，而在Spring中也可以通过``@Configuration``注解来创建配置类

#### @ComponentScan
``@ComponentScan``顾名思义，就是组建扫描，它可以帮助我们扫描指定包下的组件类，也可以在注解中添加``includeFilters``或``excludeFilters``属性配置来按照一些规则排除某些包的扫描

```java
@Configuration
@ComponentScan(value="io.github.ahogek.cap2", includeFilters = {
		@Filter(type=FilterType.CUSTOM, classes = {PersonalTypeFilter.class})
}, useDefaultFilters = false)
public class Cap2MainConfig {
	
}
```

**当中的过滤方式可以自定义指定，比如这里我就是创建了一个PersonalTypeFilter类**

```java
public class PersonalTypeFilter implements TypeFilter {

	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
		ClassMetadata classMetadata = metadataReader.getClassMetadata();
		Resource resource = metadataReader.getResource();
		String className = classMetadata.getClassName();
		System.out.println("------> " + className);
		if (className.contains("er")) {
			return true;
		}
		return false;
	}

}
```

类中需要实现TypeFilter接口并重写match方法，具体逻辑可以根据需要，这边可以通过元数据读取器获取类元数据，即ClassMetadata类，该类可以获取类名，这边判断类名中如果包含了 er 返回true 即包含（我这用的是include，exclude相反）

### @Scope注解

该注解来设置实例作用域范围，默认是单例 ``singleton``, 类似的还有多例，，请求，会话之类的，可[参阅文档](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes)中的1.5 Bean Scopes

### @Lazy注解

即懒加载模式

例如：
为添加进来的指定Bean添加``@Lazy``注解
```java
@Configuration
public class Cap4MainConfig {
	
	@Lazy
	@Bean
	public Person person() {
		System.out.println("给容器中添加Person");
		return new Person("AhogeK", 21);
	}
}
```

随后在测试类中进行获取，并不会先输出容器中的打印，而是启动类的打印，而只有当获取Bean的时候在会进行加载Bean并打印输出

### @Conditional注解

该注解意为条件，即在某个指定条件下才加载被注解的Bean

```java
@Conditional(LinCondition.class)
@Bean("james")
public Person james() {
  System.out.println("给容器中添加james");
  return new Person("james", 21);
}
```

这里需要一个条件类，我用该类来判断如果是Linux系统就加载该Bean

```java
public class LinCondition implements Condition {

	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		BeanFactory beanFactory = context.getBeanFactory();
		// Linux or Windows
		Environment environment = context.getEnvironment();
		String osName = environment.getProperty("os.name");
		System.out.println(osName);
		if ("Linux".contains(osName)) {
			return true;
		}
		return false;
	}

}
```

条件类需要实现 ``Condition``接口，并重写matches方法

*对于系统类型其实是可以通过VM arguments 中添加 os.name=Linux 来更改系统名*

### @Import注解
该注解也是用于在配置类上提供注入Bean的配置

可在注解中直接添加加载类数组，该加载类也可以是自定义的注册类提供要注入的Bean

``@Import(value = {Dog.class, Cat.class, AhogeKImportSelector.class, AhogeKImportBeanDefinitionRegisterar.class})``

其中 ``AhogeKImportBeanDefinitionRegisterar.class`` 就是自定义的

```java
public class AhogeKImportBeanDefinitionRegisterar implements ImportBeanDefinitionRegistrar {
	
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		boolean containsBeanDefinition = registry.containsBeanDefinition("io.github.ahogek.cap6.bean.Dog");
		boolean containsBeanDefinition2 = registry.containsBeanDefinition("io.github.ahogek.cap6.bean.Cat");
		System.out.println(containsBeanDefinition + " " + containsBeanDefinition2);
		if (containsBeanDefinition && containsBeanDefinition2) {
			RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Pig.class);
			registry.registerBeanDefinition("pig", rootBeanDefinition);
		}
	}
	
}
```

同样是实现一个接口 ``ImportBeanDefinitionRegistrar`` 重写一个Bean定义方法。

该类无需任何方法，可以通过 ``BeanDefinitionRegistry`` 的 ``registerBeanDefinition`` 方法注入Bean，当中第二参数是需要注入的Bean的包装类 ``RootBeanDefinition``

### Bean的声明周期

![BeanCycle](https://images0.cnblogs.com/i/580631/201405/181453414212066.png)
![BeanCycle2](https://images0.cnblogs.com/i/580631/201405/181454040628981.png)

在Bean的注入时，可以为Bean添加初始化方法及销毁方法

```java
public class Hk416 {

	public Hk416() {
		System.out.println("This is Hk416 Constructor,Just instantiation...");
	}
	
	public void init() {
		System.out.println("Hk416 initialization method running ... ");
	}
	
	public void destory() {
		System.out.println("Hk416 destory method running ...");
	}
}

@Configuration
public class Cap7MainConfigOfLifeCycle {

	@Bean(initMethod = "init", destroyMethod = "destory")
	public Hk416 hk416() {
		System.out.println("The Spring Configuration just return the HK416's Object");
		return new Hk416();
	}
}
```

**在多例模式下只有getBean的时候才会创建容器**

#### InitializingBean DisposableBean
这两个接口用于被Bean实现，然后可以重写两个方法：``afterPropertiesSet()``及``destroy()``
这两个重写的方法分别在*容器创建设置属性之后调用*及*容器关闭时调用*

#### JSR250规则的@PostConstruct及@PreDestroy注解
> JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。（来自百度百科）

* @PostConstruct 是Bean在完成初始化之后调用
* @PreDestroy 是容器移除对象前回调通知销毁Bean

#### BeanPostProcessor
这是一个Bean的后置处理器接口，实现该接口可以重写两个方法
* postProcessBeforeInitialization(Object bean, String beanName) 该方法在初始化之前进行后置处理工在(在init-method之前)
* postProcessAfterInitialization(Object bean, String beanName) 该方法在初始化之后进行后置处理工作