---
layout:     post   				    # 使用的布局（不需要改）
title:      828-lab1-part2(2)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-27 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# part2

## Loading the kernel

### 练习4

​	阅读关于C语言中指针编程的文章。在K&amp;R中从5.1(指针和地址)读到5.5(字符指针和函数)。然后下载指针的代码。c，运行它，并确保理解所有打印值的来源。注意，确保了解打印的第1行和第6行中的指针地址来自何处，打印的第2行到第4行中的所有值是如何到达那里的，以及为什么打印的第5行中的值似乎是损坏的。

​	我们下载这个程序并运行它。

```C
#include <stdio.h>
#include <stdlib.h>

void
f(void)
{   
    int a[4];    //数组
    int *b = malloc(16);    //指针并分配内存空间
    int *c;   //指针
    int i;
    //a输出的是数组的首地址，b输出的是内存起始空间，c是未定义指针
    printf("1: a = %p, b = %p, c = %p\n", a, b, c);

    c = a; //此时a和c同时指向a的内存地址，
    for (i = 0; i < 4; i++)  //给a的四个数组元素赋值100,101,102,103 
		a[i] = 100 + i;   
    c[0] = 200; //此时a的第一个元素=200，c的内存数据也为200
    printf("2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);  //即200,101,102,103
    
    //以下是访问数组的三种不同方法
    c[1] = 300;  //a[1]=300
    *(c + 2) = 301;  //a[2]=301
    3[c] = 302;   //a[3]=302
    printf("3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = c + 1; //指向下一个元素a[1]
    *c = 400;  //a[1]=400
    printf("4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = (int *) ((char *) c + 1);//把c强转为char型，然后+1再转回int，因为char和int大小不同，所以c在赋值时会影响到a[1]及后面的元素
    *c = 500;//四个字节大小，影响了a[1]和a[2]两个元素
    printf("5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    b = (int *) a + 1;  //b=a[0]的内存地址+四个字节（int的大小）
    c = (int *) ((char *) a + 1);  //c=a[0]的内存地址+1个字节（char的大小）
    printf("6: a = %p, b = %p, c = %p\n", a, b, c);
}

int
main(int ac, char **av)
{
    f();
    return 0;
}
```

​	原理在代码的注释上，下面是运行结果：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8j0yvo1yj30jr04xmxx.jpg)

​		要理解boot/main.c，需要知道ELF二进制文件是什么。当我们编译并链接一个C程序(如JOS内核)时，编译器将每个C源代码('. C ')文件转换成一个对象('.o')文件，目标文件中包含的是机器直接能够执行的机器指令。然后，链接器将所有编译后的目标文件组合成一个单一的二进制映像，比如obj/kern/kernel，在本例中是ELF格式的二进制映像，ELF格式代表“可执行和可链接格式”。

​		在6.828中，我们可以将ELF可执行文件看作是一个带有加载信息的头文件，后面是几个程序节，每个程序节是一个连续的代码块或数据块，目的是在指定的地址加载到内存中。boot loader不修改代码或数据;它将它加载到内存中并开始执行它。

​		ELF二进制文件以一个固定长度的ELF头开始，然后是一个可变长度的程序头，列出要加载的每个程序段。这些ELF头文件的C定义在inc/ ELF .h中。我们感兴趣的部分有:

   	 .text:程序的可执行指令。

​		.rodata:只读数据，如C编译器生成的ASCII字符串常量。(不过，我们不会设置硬件来禁止写入。)

​		.data: data部分保存程序的初始化数据，比如用初始化器声明的全局变量，比如int x = 5;。

​		当链接器计算程序的内存布局时，它为未初始化的全局变量保留空间，比如int x;，在一个称为.bss的部分中，该部分紧随着内存中的.data。C要求“未初始化的”全局变量以0值开始。因此，不需要在ELF二进制文件中存储.bss的内容;相反，链接器只记录.bss部分的地址和大小。加载程序或程序本身必须将.bss部分归零。

​		通过键入以下命令，检查内核可执行文件中所有部分的名称、大小和链接地址的完整列表:

`objdump -h obj/kern/kernel`

我们看一下这部分的信息：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8kzb1rxoj30n10ho419.jpg)

​		请特别注意.text部分的“VMA”(或链接地址)和“LMA”(或加载地址)。段的加载地址是应该将该段加载到内存中的内存地址。节的链接地址是节期望从中执行的内存地址。链接器以各种方式对二进制文件中的链接地址进行编码，例如，当代码需要全局变量的地址时，如果从一个没有链接的地址执行二进制文件，通常会导致二进制文件无法工作。

​		通常，链接地址和加载地址是相同的。通过下面指令查看引导加载程序的.text部分:

`objdump -h obj/boot/boot.out`

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8l6fakprj30ll09udh3.jpg)

​		对比VMA和LMA,确实是相同的。

​		引导加载程序使用ELF程序头来决定如何加载节。程序头指定ELF对象的哪些部分要加载到内存中，以及每个部分的目标地址。使用如下命令:

`objdump -x obj/kern/kernel`

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8lreyaw6j30o90dg40h.jpg)

​		然后，在objdump的输出中，将程序头列在“程序头”之下。ELF对象中需要加载到内存中的区域是那些被标记为“LOAD”的区域。每个程序头的其他信息都是给定的，比如虚拟地址(“vaddr”)、物理地址(“paddr”)和加载区域的大小(“memsz”和“filesz”)。

​		回到boot/main.c。每个程序头的ph->p_pa字段包含段的目标物理地址(在本例中，它实际上是一个物理地址，尽管ELF规范对该字段的实际含义含糊其辞)。

​		BIOS从地址0x7c00开始将boot sector加载到内存中，所以这是boot sector的加载地址。这也是boot sector执行的位置，所以这也是它的链接地址。我们通过将-Ttext 0x7C00传递给boot/Makefrag中的链接器来设置链接地址，这样链接器将在生成的代码中生成正确的内存地址。

###练习5

​		再次跟踪boot loader的前几条指令，找到第一条指令满足：修改了boot loader的链接地址，这个指令就会出现错误。然后将boot/Makefrag中的链接地址修改，运行make clean，用make重新编译，然后再次跟踪boot loader，看看会发生什么。别忘了把链接地址改回来。

​		开始时链接地址和加载地址是相同的，BIOS从0x7c00处开始加载。所以我们要修改的就是这个值。然后我们打开boot/makefrag这个文件：

```
$(OBJDIR)/boot/boot: $(BOOT_OBJS)
	@echo + ld boot/boot
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^
	$(V)$(OBJDUMP) -S $@.out >$@.asm
	$(V)$(OBJCOPY) -S -O binary -j .text $@.out $@
	$(V)perl boot/sign.pl $(OBJDIR)/boot/boot	
```

​		有这样一段，我们把-Ttext 0x7C00这里修改为0x7e00。执行make clean，再执行make。然后我们发现汇编代码里面

```
.globl start
start:
  .code16                     # Assemble for 16-bit mode
  cli                         # Disable interrupts
    7e00:	fa                   	cli    
  cld                         # String operations increment
    7e01:	fc                   	cld  
```

地址变成了我们修改之后的值。然后我们跟踪一下boot loader：

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8n7jlz8jj30ot0detbe.jpg)

发现坏了，没法跟踪。  那就把地址改回来吧。

​		查看内核的加载和链接地址。与boot loader不同，这两个地址是不同的:内核告诉boot loader以低地址将其加载到内存中，但它期望从高地址执行。在下一节中，我们将深入研究如何实现这一功能。

​		除了节信息之外，ELF头中还有一个对我们很重要的字段，它就是e_entry。该字段保存程序入口点的链接地址:程序文本部分中的内存地址，程序应该从这里开始执行。你可以看到入口点。

`objdump -f obj/kern/kernel`

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8vag637oj30k403qt8y.jpg)

​		我们现在应该知道boot/main.c中最小的ELF加载程序。它将内核的每个部分从磁盘上的加载地址读入内存，然后跳转到内核的入口点。

### 练习6

​		我们可以使用GDB的x命令来检查内存。GDB手册有完整的细节，但是现在，只要知道命令x/Nx ADDR在ADDR打印N个内存单词就足够了。

​		重置机器(退出QEMU/GDB并重新启动它们)。在BIOS进入boot loader的地方检查内存0x00100000中的8个字，然后在boot loader进入内核的地方再检查一次。它们为什么不同?第二个断点是什么?

在一开始，我们读取0x00100000处的内存：

![3.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8vt5zx5mj30np02274f.jpg)

在boot loader进入内核后再读取一次：

![2.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd8vsnjsa3j30mw01vaa5.jpg)

发现内存中的值有变化，原因是前面我们分析过bootmain函数，他会把各个程序段存放在内存，这样我们读取到的就是内核中某一个段的内容。

第二次读取的内容，由于程序入口是0x0010000c，在我们读取的内存中，对比上面我们objdump的内容，这里面存放的应该是.text节部分。

