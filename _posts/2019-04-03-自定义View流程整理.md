---
layout:     post
title:      自定义View流程整理
date:       2019-04-03
author:     OldJii
header-img: img/diyview.jpg
catalog: true
tags:
    - 自定义View
    - Android
---
> 版权声明：转载请务必注明作者与原文链接

# 序言

严格来说自定义View分为：自定义单一View、自定义ViewGroup，本文仅对自定义单一View进行讲解。

`下文中出现“自定义View”皆为“自定义单一View”`

# 正文

自定义单一View也分两种：继承View、继承特定View（如TextView）

### 继承View

步骤
1. 自定义类，继承View
2. 在values目录下创建自定义属性的XML文件（非必要）
3. 重写三个构造方法（如果有自定义属性，需要在构造方法中处理自定义属性）
4. 重写onDraw()（如果需要支持padding，需要在onDraw()中手动获取并处理）
5. 重写onMeasure()（非必要，但要想View支持wrap_content必须重写）
6. 在XML中按全路径添加自定义View

下面的实例是最简单的版本，如果支持“自定义属性”、“padding”、“wrap_content”则参考“##自定义View的原理”里面的各项
```java
public class CircleView extends View {
    Paint mPaint1;

    public CircleView(Context context){
        this(context, null);
    }
    public CircleView(Context context,AttributeSet attrs){
        this(context, null, 0);
    }
    public CircleView(Context context,AttributeSet attrs,int defStyleAttr ){
        super(context, attrs, defStyleAttr);
        init();
    }
    
    private void init() {
        mPaint1 = new Paint ();
        mPaint1.setColor(Color.BLUE);
        mPaint1.setStrokeWidth(5f);
        mPaint1.setStyle(Paint.Style.FILL);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        int width = getWidth();
        int height = getHeight();
        int r = Math.min(width, height)/2;
        canvas.drawCircle(width/2,height/2,r,mPaint1);
    }
}
```

### 继承特定View

继承自系统已有View时,一般是对其原有功能进行扩展或者修改, 比如一个Dialog、TextView在这里注意监听器的使用

这里附上一份“自定义TextView实现打字机效果“的源码，逻辑很简单，就是使用Timer不断裁剪内容实现
```java
/**
 * 打字机效果
 */
public class TyperTextView extends TextView {
    private String mShowText = null;
    private String mTimer = null;

    public TyperTextView(Context context) {
        super(context);
    }

    public TyperTextView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public TyperTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    private void stopTimer() {
        if(mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
    }

    private void startTimer() {
        stopTimer();
        mTimer = new Timer();
        mTimer.schedule(new TyperTask(), 80)    //间隔时间80ms
    }
    
    /**
     * 要显示的内容
     * 
     * @param text
     */
    public void init(final String text) {
        if(TextUtils.isEmpty(text))
            return ;
        post(new Runnable() {
            @Override
            public void run() {
                mShowText = text;
                setText("");
                startTimer();
            }
        });
    }

    class TyperTask extends TimerTask {
        @Override
        public void run() {
            post(new Runnable() {
                @Override
                public void run() {
                    int length = getText().toString().length();
                    if(length < mShowText.length()) {
                        setText(mShowText.substring(0, length + 1));
                        startTimer();
                    } else {
                        stopTimer();
                    }
                }
            })
        }
    }
}
```

# 问题分析

## 为什么自定义View默认不支持wrap_content？

你在设置wrap_content时实际就是设置View的观测模式为AT_MOST，match_parent则对应EXACTLY

然而在onMeasure()中的getDefaultSize()的默认实现中，当View的测量模式是AT_MOST、EXACTLY时，View的大小都会被设置成子View的MeasureSpec里的specSize

然而整个specSize = parenSize = 父容器当前剩余控件大小 => match_parent的效果

所以，如果不手动设置支持wrap_content属性，那么wrap_content属性是不会生效的，显示效果同match_parent

***解决方法***：

在重写的onMeasure()中自定义测量方法根据onMeasure()的参数widthMeasureSpec、heightMeasureSpec计算出准确的measureWidth/Height并传入setMeasuredDimension

```java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    setMeasuredDimension(measureWidth(widthMeasureSpec),measureHeight(heightMeasureSpec));
}
```
自定义的测量方法：
```java
private int measureWidth(int widthMeasureSpec) {
    int result = 0;
    int specMode = MeasureSpec.getMode(widthMeasureSpec);
    int specSize = MeasureSpec.getSize(widthMeasureSpec);
    if (specMode == MeasureSpec.EXACTLY) {
        result = specSize;
    } else {
        //根据实际情况修改，如是文字显示，可以获取用获取文字宽高度的代码替换200
        result = 200;
        if (specMode == MeasureSpec.AT_MOST) {
            result = Math.min(result, specSize);
        }
    }

    return result;
}
```

## 如何使自定义View支持padding属性？

方法很简单也很笨：
在重写onDraw()时手动获取传入的padding属性并手动做出对宽高的影响

```java
protected void onDraw(Canvas canvas) {

    super.onDraw(canvas);

    // 获取传入的padding值
    final int paddingLeft = getPaddingLeft();
    final int paddingRight = getPaddingRight();
    final int paddingTop = getPaddingTop();
    final int paddingBottom = getPaddingBottom();

    // 获取绘制内容的高度和宽度（考虑了四个方向的padding值）
    int width = getWidth() - paddingLeft - paddingRight ;
    int height = getHeight() - paddingTop - paddingBottom ;

    int r = Math.min(width, height)/2;
    canvas.drawCircle(paddingLeft+width/2,paddingTop+height/2,r,mPaint1);
}
```

## 在自定义View中如何使用自定义属性？

步骤：
1. 在values目录下创建自定义属性的xml文件
2. 在自定义View的构造方法中解析自定义属性的值
3. 在布局文件中使用自定义属性

下面是各步骤的代码实现：
第一步：
```java
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="CircleView">
        <attr name="circle_color" format="color"/>
    </declare-styleable>
</resources>
```
第二步：
```java
public CircleView(Context context,AttributeSet attrs,int defStyleAttr ){
        super(context, attrs, defStyleAttr);
        TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.CircleView);
        mColor = a.getColor(R.styleable.CircleView_circle_color,Color.RED);
        a.recycle();
        init();
    }
```
第三步：注意添加xmlns:app
```java
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="scut.carson_ho.diy_view.MainActivity"
    >
    <scut.carson_ho.diy_view.CircleView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="#000000"
        android:padding="30dp"
        app:circle_color="#FF4081" />
</RelativeLayout>
```