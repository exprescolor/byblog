---
layout:     post   				    # 使用的布局（不需要改）
title:      反转链表 				# 标题 
subtitle:   链表相关 #副标题
date:       2022-04-12 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea2.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 链表
    - LeetCode
---

# 题目描述

给定一个单链表的头节点head，请你反转这个链表并返回它。

# 解题思路1——递归





# 代码如下

```CPP
ListNode* reverseList(ListNode* head)
{
    if(!head || !head->next)
    {
        return head;
    }
    ListNode* newhead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newhead;
}
```

算法时间复杂度：O(n),其中n是链表长度；空间复杂度：O(n)。空间复杂度主要取决于递归所调用的栈空间，最多为n层。


# 解题思路2——迭代

假设链表为1-2-3-nullptr，我们需要把它反转为nullptr-3-2-1.遍历链表时，将当前节点的next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储它的前一个节点。在更改引用之前，还需要存储后一个节点，最后返回新的头引用。

* 先把前节点置空，把head赋给当前节点；

* 然后next = prev，prev = curr， curr = next

* 最后返回previous即可。


# 代码如下
```CPP
ListNode* reverseList(ListNode* head)
{
    ListNode* prev = nullptr;
    ListNode* curr = head;
    while(curr)
    {
        ListNode* next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```
算法时间复杂度：O(n),其中n是链表长度；空间复杂度：O(1)。
