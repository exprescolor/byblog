---
layout:     post 
title:      Java基础1007
subtitle:   Java基础复习
date:       2019-10-07
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - Java
---

#### 栈

- 栈的特点如下：
   - 栈描述的是方法执行的内存模型，每个方法被调用都会创建一个帧栈（存储局部变量、操作数、方法出口等）
   - JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）
   - 栈属于线程私有，不能实现线程间的共享
   - 栈的存储特性是“先进后出，后进先出”
   - 栈是由系统自动分配，速度快。栈是一个连续的内存空间。

#### 堆

- 堆的特点如下：
   - 堆用于存储创建好的对象和数组（数组也是对象）
   - JVM只有一个堆，被所有线程共享
   - 堆是一个不连续的内存空间，分配灵活，速度慢！

#### 方法区（静态区）

- 方法区的特点如下：
   - JVM只有一个方法区，被所有线程共享。
   - 方法区实际也是堆，只是用于存储类、常量相关的信息。
   - 用来存放程序中是不变或唯一的内容。（类信息【class对象】、静态变量、字符串常量等）

#### 垃圾回收机制

- 任何一种垃圾回收算法一般要做两件基本事情
   - 发现无用的对象
   - 回收无用对象占用的内存空间
- 垃圾回收机制可以将“无用的对象”进行回收。无用的对象指的是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。

#### 垃圾回收相关算法

- 引用计数法
   - 堆中每个对象都有一个引用计数，被引用一次，计数加1；被引用变量值变为nul，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法被识别。

- 引用可达法（根搜索算法）
   - 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

#### 通用的分代垃圾回收机制

- 分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代，年老代，持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间
   - 年轻代
      - 所有新生成的对象都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当年轻代区域存放满对象时，就将对象存放到年老代区域。
   - 年老代
      - 在年轻代中经历了N（默认15）次垃圾回收后仍然存活的对象，就会被放到年老代中，因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC（全量回收），来一次大扫除，全面清理年轻代区域和年老代区域。
   - 持久代
      - 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响
- Minor GC：
   - 用于清理年轻代区域，Eden区域满了就会触发一次Minor GC，清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”（这两个区大小空间相同，同一时间只有一个在用，另一个为空）
- Major GC：
   - 用于清理老年代区域
- Full GC：
   - 用于清理年轻代、老年代区域。成本较高，会对系统性能产生影响

#### 分代垃圾回收机制的过程

1. 新创建的对象，绝大多数都会存储到Eden中
2. 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区
3. 当Eden区再次满了，会将S1中的b不能清空的对象存到另一个Survivor中，如S2，同时将Eden区中不能清空的对象，也复制到S1中，保证Eden和S1均被清空
4. 重复多次（默认15）Survivor中没有被q清理的对象，则会复制到老年代Old（Tenured）区中
5. 当Old区满了，则会触发一个一次完整的垃圾回收（Full GC），之前新生代的垃圾回收称为（MinorGC）

#### JVM调优和Full GC

- 在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节，有如下原因可能导致Full GC：
   - 年老代（Tenured）被写满
   - 持久代（Perm）被写满
   - `System.gc();`被显式调用（程序建议GC启动，不是调用GC）
   - 上一次GC之后Heap的各域分配策略动态变化

#### 开发中容易造成内存泄露的操作

- 创建大量无用对象
   - 比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder

```java
String str ="";
for(int i=0;i<10000;i++){
    str+=i;//相当于产生了10000个String对象
}
```
- 静态集合类的使用
   - 像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放

- 各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭
   - IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘h或者网络连接，不使用的时候一定要关闭

- 监听器的使用
   - 释放对象时，没有删除相应的监听器

- **注意**
   - 程序员无权调用垃圾回收器
   - 程序员可以调用`System.gc();`，该方法只是通知JVM，b并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能
   - finalize方法：是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。