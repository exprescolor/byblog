---
layout:     post 
title:      杂谈
subtitle:   面试
date:       2019-10-16
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.Spring的效益最大化是否需要结合Hibernate或者Mybatis？

- 不需要，Spring有自己的jdbc Template，这是效益最大化的数据库组件

#### 2.Spring的事务

- Spring的事务包括声明式事务和编程式事务
   - 编程式事务需要你在代码中直接加入处理事务的逻辑，可能需要在代码中显式调用beginTrasnsaction()、commit()、rollback()等事务管理方法。如在执行a方法时需要事务处理，你需要在a方法开始时开启事务，处理完后，在方法结束时，关闭事务
   - 声明式事务的做法是在a方法外围添加注解或直接在配置文件中定义，a方法需要事务处理。在Spring会通过配置文件在a方法前后拦截，并添加事务。
   - 二者区别，编程式事务侵入性比较强，但处理粒度更细，相当于一个是手动事务，一个是系统自动事务。编程式事务就是需要手动写代码提交事务、回滚事务等。声明式事务就是在配置文件中声明以下什么时候需要事务，到时候系统会自动commit，出异常了自动rollback，不需要在代码中写commit或rollback。
- Spring中涉及到事务管理的API核心的只有3个：TransactionDefinition、PlatformTransactionManager、TransactionStatus。
   - 给定的事务规则就是用TransactionDefinition，用于定义一个事务
   - 按照……来执行提交或者回滚操作就是用PlatformTransactionManager，用于执行事务的具体操作
   - 表示一个运行着的事务的状态就是用TransactionStatus

#### 3.在Servlet中，能实现重定向的方法是？

- 运用javax.servlet.http.HttpServletResponse接口的sendRedirect方法

#### 4.当多个浏览器终端请求web服务器的时候，服务器为每个客户启动一个线程，不是进程。

#### 5.servlet接口定义了servlet的生命周期方法：init（）、service（）、destory（）三个方法

#### 6.Spring事务的传播属性。

- 假设外层事务 Service A 的 Method A() 调用 内层Service B 的 Method B()
- PROPAGATION_REQUIRED     支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。
   - 如果ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候spring已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运行在 ServiceA.methodA() 的事务内部，就不再起新的事务。
假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。
这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。
- PROPAGATION_REQUIRES_NEW     新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作
   - 比如我们设计 ServiceA.methodA() 的事务级别为 PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起，ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。
   - 他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。如果 ServiceB.methodB() 失败回滚，如果他抛出的异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看B抛出的异常是不是A会回滚的异常)。
- PROPAGATION_SUPPORTS     支持当前事务，如果当前没有事务，就以非事务方式执行。
   - 假设ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.methodB()时，如果发现ServiceA.methodA()已经开启了一个事务，则加入当前的事务，如果发现ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。
- PROPAGATION_MANDATORY     支持当前事务，如果当前没有事务，就抛出异常。
- PROPAGATION_NOT_SUPPORTED     以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER     以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED  如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。
   -  ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时两者之间又将如何协作呢?  ServiceB.methodB 如果 rollback, 那么内部事务(即 ServiceB.methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA.methodA) 可以有以下两种处理方式:
      -  a、捕获异常，执行异常分支逻辑
        void methodA() {
        try {
            ServiceB.methodB();
        } catch (SomeException) {
            // 执行其他业务, 如 ServiceC.methodC();
        }
    }
这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。
      - b、 外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB.methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA.methodA) 将根据具体的配置决定自己是 commit 还是 rollback

#### 7.Spring设置成员变量共享？

- @Scope(“prototype”)表示每获取一个bean创建一个对象。这虽然看起来是多例。但成员变量并不共享。要想成员变量共享，可设置为“session”或“globalSession”
- 单例模式下会共享普通成员变量和静态成员变量；多例模式下普通成员变量不共享，静态成员共享。在开发中，SpringMVC优先使用单例模式，而且尽量不要在Controller中设置成员变量。
- 如果要定义成员变量并为成员变量赋值可以配置source.properties，通过读取配置文件来为成员变量初始化

#### 8.Spring的依赖注入

- Spring的依赖注入有三种方式（Google上搜有写3种的、4种的、5种的。。。Emmmmm  ）
   - Setter方法注入（设定值注入）
   - 构造器注入
      - Spring支持利用构造器注入参数实例化Bean方式。只要在Spring的配置文件中增加构造器参数constructor-arg
      - Spring就会自动的调用有参数的构造器创建bean对象实例, 整个过程无需程序编码只需要配置applicationContext.xml文件即可
   - 自动装配功能实现属性自动注入
      - Spring IoC容器可以自动装配（autowire）相互协作bean之间的关联关系，autowire可以针对单个bean进行设置，autowire的方便之处在于减少xml的注入配置。
- 使用构造函数依赖注入时，Spring保证所有一个对象所有依赖的对象先实例化后，才实例化这个对象。使用set方法依赖注入时，Spring首先实例化对象，然后才实例化所有依赖的对象。
- 当设值注入与构造注入同时存在时，先执行设值注入，在执行构造注入。
- spring的IOC容器能够帮我们自动new对象，对象交给spring管之后我们不用自己手动去new对象了，也就是控制权的转让。
- spring使用BeanFactory来实例化、配置和管理对象，但是它只是一个接口，里面有一个getBean()方法。
- 我们一般都不直接用BeanFactory，而是用它的实现类 ApplicationContext ，这个类会自动解析我们配置的applicationContext.xml

#### 9.Spring只支持方法级别的织入点，域级别的还没有实现。Struts2是类级别的。

#### 10.在Spring中，Bean的scope默认是什么？

- singleton，也就是单例
- Scope描述的是Spring容器如何新建Bean实例的。Spring的Scope有以下几种，通过@Scope注解来实现。
   - （1）Singleton：一个Spring容器中只有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例。
   - （2）Prototype：每次调用新建一个Bean实例。
   - （3）Request：Web项目中，给每一个 http request 新建一个Bean实例。
   - （4）Session：Web项目中，给每一个 http session 新建一个Bean实例。
   - （5）GlobalSession：这个只在portal应用中有用，给每一个 global http session 新建一个Bean实例。

#### 11.在Spring框架中获取连接池可以有哪些方式？

- DBCP数据源
- C3P0数据源
- Spring的数据源实现类(DriverManagerDataSource)
- 获取JNDI数据源
- 具体解释见：https://blog.csdn.net/eff666/article/details/58643406

#### 12.final方法等同于private方法。这句话对吗？

- 不对
- private方法只可以在类的内部使用，在类外根本访问不到， 而final方法可以在类外访问，但是不可以重写该方法，就是说可以使用该方法的功能但是不可以改变其功能，这就是private方法和final方法的最大区别
- private说的是访问修饰符，是一个访问权限的问题，final说的是这个方法不能被重写

#### 13.默认RMI采用的是什么通信协议？

- TCP/IP

#### 14.Servlet中的方法

- init方法： 是在servlet实例创建时调用的方法，用于创建或打开任何与servlet相的资源和初始 化servlet的状态，Servlet规范保证调用init方法前不会处理任何请求 
- service方法：是servlet真正处理客户端传过来的请求的方法，由web容器调用， 根据HTTP请求方法（GET、POST等），将请求分发到doGet、doPost等方法 
- destory方法：是在servlet实例被销毁时由web容器调用。Servlet规范确保在destroy方法调用之 前所有请求的处理均完成，需要覆盖destroy方法的情况：释放任何在init方法中 打开的与servlet相关的资源存储servlet的状态

#### 15.Servlet是线程安全的吗？

- Servlet是线程不安全的，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误。

#### 16.JSP分页代码中，正确的步骤次序是什么？

- 先取总记录数，得到总页数，再取所有的记录，最后显示本页的数据。

#### 17.ASCII码和ANSI码

- 标准ASCII只使用7个bit，扩展的ASCII使用8个bit。
- ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。不同 ANSI 编码之间互不兼容。在简体中文Windows操作系统中,ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。
- ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符，即ASCII码
- ASCII 表上的数字 0–31 分配给了控制字符，用于控制像打印机等一些外围设备。例如，12 代表换页/新页功能。此命令指示打印机跳到下一页的开头。所以ASCII码不是都可以打印的

#### 18.计算42度（角度）的余弦值的方法？

- `double d=Math.cos（Math.toRadians（42））`
- Math.cos为计算弧度的余弦值(Math.cos的参数要求是弧度)，Math.toRadians函数讲角度转换为弧度

#### 19.JSP的9大内置对象

- 1.request对象
     客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。
- 2.response对象
     response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。
- 3.session对象
     session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.
- 4.out对象
     out对象是JspWriter类的实例,是向客户端输出内容常用的对象
- 5.page对象
     page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例
- 6.application对象
     application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。
- 7.exception对象
   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象
- 8.pageContext对象
pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。
- 9.config对象
config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

#### 20.下面哪个语句是创建数组的正确语句？

1. `float f[][] = new float[6][6];`
2. `float []f[] = new float[6][6];`
3. `float f[][] = new float[][6];`
4. `float [][]f = new float[6][6];`
5. `float [][]f = new float[6][];`

- 正确答案：1、2、4、5
- 数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组

#### 21.哪个方法用于定义线程的执行体？

- run();方法
- run方法线程执行体.start方法开启多线程

#### 22.泛型只在编译的时候保证数据类型的正确性，和运行期间的性能无关

#### 23.关于Socket通信编程，以下描述正确的是？

1. 客户端通过new ServerSocket()创建TCP连接对象
2. 客户端通过TCP连接对象调用accept()方法创建通信的Socket对象
3. 客户端通过new Socket()方法创建通信的Socket对象
4. 服务器端通过new ServerSocket()创建通信的Socket对象

- 正确答案：3
- 客户端通过new Socket()方法创建通信的Socket对象。服务器端通过new ServerSocket()创建TCP连接对象。accept接纳客户端请求

#### 24.以下代码的运行结果是？

```java
public static void main(String[] args){
    String s;
    System.out.println("s="+s);
}
```

- 结果：由于String s没有初始化，代码不能编译通过。
- 成员变量有初始值，而局部变量没有初始值。本题中的s定义在方法中所以为局部变量，没有初始值。变量没有初始值就使用了，编译通不过

#### 25.如果Child extends Parent，那么正确的有哪些？

1. 如果Child是class，且只有一个有参数的构造函数，那么必然会调用Parent中相同参数的构造函数
2. 如果Child是interface，那么Parent必然是interface
3. 如果Child是interface，那么Child可以同时extends Parent1，Parent2等多个interface
4. 如果Child是class，并且没有显示声明任何构造函数，那么此时仍然会调用Parent的构造函数

- 答案：2、3、4
- 1.子类的构造器第一行默认都是super()，默认调用直接父类的无参构造，一旦直接父类没有无参构造，那么子类必须显式的声明要调用父类或者自己的哪一个构造器。
- 2、3.接口只能继承接口，但是可以多继承。类都是单继承，但是继承有传递性。
- 4.一个类一旦没有显式的定义任何构造，那么JVM会默认给你一个无参构造。无参构造的第一行依然默认是super()。

#### 26.数据独立性是指应用程序和数据结构之间相互独立, 互不影响。

#### 27.授权编译系统和合法性检查机制一起组成了安全性子系统。

#### 28.逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的，即，当数据的逻辑结构改变时，用户程序也可以不变。

#### 29.数据的逻辑独立性是指什么？

1. 内模式改变，模式不变
2. 模式改变，内模式不变
3. 模式改变，外模式和应用程序不变
4. 内模式改变，外模式和应用程序不变

- 正确答案：3
- 当模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。

#### 30.以下代码执行完毕后，b的值是多少？

```java
String a="Hello";
String b=a.substring(0,2);
```

- 结果：He
- substring   方法将返回一个包含从start到最后（不包含end ）的子字符串的字符串。

#### 31.多态的根源是继承，多态的表现形式是重写

#### 32.以下代码，当输入2时返回值是多少？

```java
public static int getValue(int i) {
        int result = 0;
        switch (i) {
        case 1:
            result = result + i;
        case 2:
            result = result + i * 2;
        case 3:
            result = result + i * 3;
        }
        return result;
}
```

- 结果：10
-  switch结构中没有break的话，匹配完不会跳出，会继续匹配下一个case直到整个结构结束

#### 33.下列代码的输出结果是多少？

```java
boolean b=true?false:true==true?false:true;
System.out.println(b);
```

- 结果：false
- Java的三目运算符：(a<b)?a:b。他是一个表达式，意思是：如果a<b为真,则表达式取a值,否则取b值.
- 题目中的解释：首先==的优先级大于三目运算符，所以先运算true==true;因为要从右向左执行（三目运算符右边返回的值不一定是布尔类型，从左向右的话可能会报错，所以从右向左运行），所以接下来运算true?fasle:true，得到false；之后运算true?false:false，得到false。

#### 34.以下程序的执行结果是什么？

```java
static boolean foo(char c)
 {
 System.out.print(c);
 return true;
 }
 public static void main(String[] args) {
 int i =0;
 for(foo('A');foo('B')&&(i<2);foo('C'))
 {
 i++;
 foo('D');
 }
 }
```

- 答案：ABDCBDCB

#### 35.下列代码中，输出为true的个数为多少？

```java

class A{}

class B extends A{}

class C extends A{}

class D extends B{}

A obj = new D();

System.out.println(obj instanceof B);

System.out.println(obj instanceof C);

System.out.println(obj instanceof D);

System.out.println(obj instanceof A);
```

- 3个
- D属于B,D属于A,D属于D,D不属于C（自己画图即可）

#### 36.以下程序的输出结果为多少？

```java
public static void main(String args[]) {
System.out.println(14^3);
}
```

- 13
- ^表示异或 就是相同是0 不同是1，14是1110，3是0011，所以14^3=1101，即13

#### 37.switch支持 int及以下（char， short， byte），String， Enum。在Java7中不支持String，Java7之后才支持

#### 38.方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放