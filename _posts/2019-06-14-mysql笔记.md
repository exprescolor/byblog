---
layout:     post
title:      mysql笔记 mysql速查
subtitle:   
date:       2019-6-14
author:     xinxin
catalog: true
tags:
    - mysql
---


# mysql数据库

## mysql基本语句

### 基于存储介质



#### 关系性数据库:存储在磁盘中

以二维表的形式存储

**由关系数据结构\关系操作集合\关系完整性约束三部分组成**

关系数据结构:二维表

关系操作集合:sql语句

关系完整性约束:数据内部有队形的关联关系

约束关系:表内约束:对应的列只存放对应的数据

表间约束:自然界各实体对应的关联关系(外键)

#### 非关系性数据库:存储在内存

#### sql

结构化查询语言

#### dql

数据查询语言(专门用于查询数据)

#### dml

数据操作语言 

专门用于写数据

#### tpl

事物处理语言

专门用于事物安全处理

#### dcl

数据控制语言

专门的权限管理(确定单个用户组对数据库对象的访问)

#### ddl

数据定义语言 





------

### 登录

**通常服务端与客户端不在一台电脑上**

1. mysql.exe
2. 输入对应服务器的地址 -h
3. 输入对应mysql监听端口-P
4. 输入用户名-u
5. 输入密码-p

```shell
mysql -u root -p
mysql -h主机地址  -P端口 -u用户名 -p密码
mysql -hlocalhost -P3305 -uroot -proot
```



### 退出

exit

\q

quit









### mysqk服务端架构



1. 数据库管理系统:DBMS,专门管理服务器端的而所有内容
2. 数据库(第二层):DB专门用于存储数据的仓库
3. 二位数据表(第三层):table 专门用于存储具体实体的数据
4. 字段:field,具体存储某种类型的数据



#### 数据库中常用的关键字

row行

column列(field)



### 数据库基本操作

#### 数据库是数据存储的最外层(最大单元)



#### 创建数据库

create database  数据库名字[库选项]

库选项:数据库的相关属性

字符集:代表当前数据库下的数据 

```mysql
create database mydatabase;
create database mydatabase1 charset gbk;
```

#### 显示所有数据库

```mysql
show databases;
```

##### 系统库

information_schema保存数据库所有的结构信息

mysql核心数据库( 权限关系)

performance_schema 效率库 运行效率高不高就可以来这里看看对应的数据

##### 显示

```mysql
show databases like '匹配模式'
```

‘my%‘，获取以my开头

’m_databses‘，获取以m开头最后为databases的数据库

’%databases‘，获取以databases结尾的数据库

#### 查看数据库创建语句

```mysql
show create database 数据库名字
```

#### 选择数据库

如果要操作数据要进入对应的数据库中

```mysql
use 数据库名字
```



#### 修改数据库字符集

```mysql
alter database 数据库名字 charset=字符集 
```

#### 删除数据库

```mysql
drop database 数据库名字; 
```



### 数据表操作

#### 创建数据表

create table 表名(字段名 字段类型 [字段属性.....)[表选项]

```mysql
create table 数据库名.表名(
-- 字段名 字段类型中间以逗号分割
    name varchar(10) -- 10个字符       
);

-- 或者进入数据库再创建
use 数据库名
create table 表名(
    name varchar(10) 
);

```

表选项

engine：存储引擎

charset：存储引擎

collate：校对集

##### 例子

```mysql
create table 表名(
    name varchar(10) 
)engine [=] innodb/myisam charset utf8;
```

#### 复制已有表

只复制已有表的结构，表中的数据不复制

```mysql
create table 表名 like 数据库.表名


use test
show table
create table teacher like mydatabase2.teacher;
```

### 显示数据表

每当创建好文件存储再文件中以存储引擎frm代表结构文件

所有存储文件放在外部的ibdata文件中





```mysql
-- 查看所有表
show tables；
show tables like '匹配模式'

-- 显示表结构字段信息
describe 表名
desc 表名
show columns from
```

![深度截图_选择区域_20190427145800](../图片/深度截图_选择区域_20190427145800.png)

与  创建表的字符按信息一一对应

create table 表名(字段名 字段类型 [字段属性.....)[表选项]





### 设置表属性

engin charset 和 collate

 alter table 表名 表选项 [=]  值

```mysql
alter table student charset gbk;
```

如果数据库已经确定，里面有很多数据，不要轻易修改表选项

```mysql
-- 修改表名
rename table 表名 to 重命名的名称;
rename table student to my_student;
-- 修改表选项
alter table 表名 表选项 [=] 值;
alter table student charset gbk;
-- 新增字段
alter table 表名 add [column] 新字段名 列类型[列属性]  [字段位置:first/after 字段名]

--  修改字段名
alter table 表名 change 字段名 新字段名 字段类型 [列属性] [新位置];
alter table my_student change sex newsex int  null ; -- 后面 null表示修改属性

-- 修改字段类型
alter table 表名 modify 字段名 新类型 [新属性] [新位置]
alter table my_student modify newsex int(2) not null; -- 后面not表示修改属性为不为空
-- 删除字段
alter table 表名  drop 字段名 ；

-- 删除表结构
drop table 表名[，表名2]
```

字段位置

first在某某之前

after在某某之后

### 数据基础操作

#### 插入记录

```mysql
insert into 表名[(字段列表)] values（对应的字段列表）
```

#### 数据查询操作

```mysql
select *from 表名；
select 字段列表（使用逗号分割） from 表名；
-- 查询某个如age为30的所有记录
select 字段列表 from 表名
where 字段名= 值；
```

#### 删除操作

```mysql
delete from 表名 where 字段名=值；

```

#### 更新操作

```mysql
update 表名 set 字段名 =值 where 字段名=值

```

### 字符集

```mysql
set names utf8;  -- 设置字符集
show variables like 'character_set_%';  -- 显示字符集

```



## 字段类型

### 数字类型

| 类型           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 整数类型       |                                                              |
| tinyint        | 迷你整形，用一个字节表示。                                   |
| smallint       | 小整形，系统你用两个字节                                     |
| mediumint      | 中整形3个字节                                                |
| int            | 用四个字节保存的整形                                         |
| bigint         | 大整型，用八个字节来表示                                     |
| 小数类型       |                                                              |
| float（10，2） | 浮点用7个字节保存整数，只能保证7位数的精度 四舍五入的方式进行计算 前面表示整数8位小数2位 |
| double         | 双精度能保证8位的精度                                        |
| decimal（）    | 定点数小数部分可能不精确，但整数部分一定会正确               |
|                |                                                              |



数据的显示长度

tinyint(3)最大显示三位
int（4）最长显示四位

tinyint（2） zerofill  往左侧补充零

### 时间类型

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| date      | 对应格式位 yyyy-mm-dd                                        |
| time      | hh：ii：ss  用来描述时间段                                   |
| datetime  | 日期时间类型date 和time合起来的类型                          |
| timestamp | 时间戳类型（对应的数据被修改，数据会自动修改）               |
| year      | year ，1900-2155 占用一个字节，两中插入模式0-99 和四位数的具体年 进行两位数的插入时当输入69以下，系统时间位20+数字，如果时70以上，系统的时间位19+数字 |
|           |                                                              |

### 字符类型

| 类型    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| char    | 定长字符char（L）                                            |
| varchar | 变长字符，指定长度之后系统会根据实际储存的数据来计算长度，分配合适的长度。基本语句varchar（L），系统会在数据的后面增加1-2个字符，用来保存数据所占用的空间长度 |
| text    | 文本类型   一般超过255的文本用text进行存储                   |
| blob    | 存储二进制文件，一般不适用blob来储存文件本身，通常使用文件本身 |
| enum    | 枚举类型，在插入数据之前，先设定几个项。如：男\女\保密       |
| set     | 集合类型，可以同时保存的数据类型<br />1个字节，set只能有8个选项<br />2个字节，set有16个选项<br />。。。。<br /><br />一般适用于多选 |







### 列属性

#### null

```mysql
-- 在创建表时添加
create table 表名(
字段名 字段类型 null/not null
)；
-- 添加字段时
alter table 表名 add 字段名 字段类型 null/not null 
-- 修改字段类型时
alter table 表名 modify 字段名 新类型  null/not null 
-- 修改字段名时
alter table 表名 change 字段名 新字段名 类型 null/not null 

```

修改字段名时  **类型** 一定要加上

#### defalut

#### key（主键）

```mysql
create table 表名（
字段名 字段类型 primary key 
）

```



#### comment列描述

#### auto_increment自动增长（extra）

#### unique key保证数据的唯一性（key）

#### 外键

1. 外键字段必须与关联的主键字段类型完全一致
2. 基本属性相同
3. 外键只能使用innodb储存



对主表和从表都有一定的约束作用

1. 不能插入主表不存在的数据
2. 不能随便删除被从表引用的数据

可以在创建外键时对约束进行选择

基本语法：

```mysql
alter table 表名 add [constraint `外键名`] foreign key(外键字段) reference 主表(主键) on 约束模式
create table 表名（
字段名 类型 ，
[constraint `外键名`] foreign key(外键字段) reference 主表(主键) on 约束模式
）

alter table `profile` 
add constraint `user_profile` foreign key (`uid`) 
references `user`(`id`) on delete cascade on update cascade;


create table demo.ChinesePinyinInfo
(
    ID     int     not null     auto_increment,
    CharID     int     null,
    Pinyin varchar(10)     null,
    Tone tinyint unsigned     null,
    primary key (ID),
    
    -- 方式一：不指定外键名称，数据库自动生成
    foreign key (CharID) references ChineseCharInfo(ID) on delete cascade on update cascade 
    
    -- 方式二：指定外键名称为(FK_Name)
    -- constraint FK_Name foreign key (CharID) references ChineseCharInfo(ID) on delete cascade on update cascade 
)



-- 删除外键
alter table `表名` drop foreign key `外键名`;

```

**references**注意有s





**约束模式**(主要是对主表的约束)

1. `district`:严格模式 不允许修改（默认）

2. `cascade`：级联模式一起操作，主表数据跟随从表变化 `on update cascade`

3. `set null` 置空模式  主表变化 删除从表   `on delete set null`

   



![深度截图_选择区域_20190427145800](../图片/深度截图_选择区域_20190427145800.png)



| 属性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| null           | yes表示对应的字段为空值                                      |
| 默认值         | default当字段被设计的时候，如果默认条件下，用户不进行数据的插入，就设置为默认值 |
| 列描述         | comment:对字段进行描述注释，查看表的创建语句                 |
| 主键           | primarykey 在一张表中有且只有一个字段，里面的值具有唯一性<br /> 两种创建方式：1.在字段后增加主键属性<br />2.在所有字段后增加primary key选项<br />例：primaty key()<br />3.在表后增加<br />使用alter table 表名 add primary key （字段）；<br /><br /><br /><br />查看主键<br />通过desc 表名观察key属性<br />通过查看表的创建语句<br /><br /><br />删除主键 <br />alter table 表名 drop primary key;<br /><br /><br />复合主键<br />设置两个主键<br /><br /><br />主键约束<br />当前字段对应的数据不能为空<br />当前字段对应的数据不能有重复 |
| auto_increment | 自动增长：只适用于数值<br />一张表只能有一个自增长<br /><br /><br />用户指定数据之后自增长就不参与了，但下一个值会以这个值为基础而改变<br /><br />修改自增长只修改比之前大的数<br /><br />插入字增长在创建字段后加auto_increment<br />创建字增长<br />在创建表后添加anto_increment=值<br /><br />修改字增长<br />alter table my_auto auto_increment =10; 从10开始自增<br />删除自增长<br />alter table my_auto modify id int;<br />不要再添加primary key属性 |
| unique key     | 主键可以保证字段数唯一性<br />但是一张表只有一个主键<br /><br />唯一键是索引的一种（提升查询效率）<br />unique key用来保证对应字段的唯一性<br />允许为空，在不为空的同时，增加唯一键<br />两种设置方式<br />1.在字段之后增加增加额日益标志符<br />2.在所有字段只有后使用unique key（字段列表）<br />3.在创建完之后增加唯一键<br /><br />删除唯一键<br />alter table 表名 drop index 唯一键的名字（列名） |
| 外键           |                                                              |

### 表关系

表与表之间有什么样的关系，每种关系应该如何设置表结构

#### 一对一

一对一，一张表的一条记录与另外一张表最多有一条明确的关系。通常，此设计方案保证两张表使用同样的主键

常见的表保存到一张，不常见的表存到另一张

#### 一对多

多对一，通常也叫做多对一的关系。通常一对多的关系设计方案，在多关系的表中去维护一个字段。这个字段是“一”关系的主键

#### 多对多

多对多，一张表的一条记录在另一张表中匹配到多条数据，反过来也一样

通常再创建一个表来满足关系







## 数据高级操作

### 插入记录

**添加多组数据。**

```mysql
insert into 表名 [(字段列表)] values(值列表)，(值列表).....； 
-- 值列表以逗号隔开，分号为止

```

### 主键冲突的解决办法

使用业务主键，在实际数据插入时不知道数据是否存在已有的主键

#### 主键冲突更新

如果主键冲突 覆盖原有的字段 ，对应的字段更新为新值

```mysql
insert into 表名 values(值列表) on duplicate key update 字段=新值

```

#### 主键冲冲突替换

如果主键冲突，删除原来的数据，再重新插入进入

```mysql
replace into 表名 values(值列表)

```

##### 区别

二者的区别在于一个是更新某个字段，一个时删除之后再进行插入效率不一样

### 蠕虫复制

成倍的增加数据，一般使用到生产环境到开发环境，复制数据进行测试

```mysql
insert into 表名 [(字段列表)] select */字段列表 from 表名
-- 示例
insert into mytable values(name) select name form mytable;
-- 每使用一次增加表的数据量，注意主键冲突

```

### 更新数据

```mysql
update 表名 set 字段名 = 新值 where 判断条件
-- 限制数量的更新
update 表名 set 字段名 =新值 where 判断条件 limit 数量

```

### 删除操作

删除可以使用where 和limit  

但是auto_increment 自动增长 不会被重置

```mysql
truncate 表名;

```

truncate 会清空内容并 复位自动增长



### 运算符

#### 算数运算符

+-*/%

除法的运算结果用 浮点数表示

#### 比较运算符

```mysql
>\<\ = \>=\<=
-- 在mysql中相等的运算符为   =   <=>   不等于为<>
‘1’<=>1 
-- 在mysql中 数据先转化为同类型再进行比较
where  age  between 20 and 30

```

#### 逻辑运算符

and \or \not 

#### in运算符

只要结果集在其中存在就返回结果

```mysql
select *from my_student where stu_id in ('stu001','stu002')

```



#### is 运算符

是专门用来判断是否为空的运算符

```mysql
select *from my_int where int_6 is null;


```

#### like 运算符

使用来模糊匹配

```mysql
like "%"   -- 匹配单个
like '-'   -- 匹配单个

```







## 查询语句

```mysql
select 选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制

```

### 选项

all：查询全部的记录（默认）

distinct:去重



字段列表

有的时候（大部分时候）需要从多张表获取数据，在获取数据时，不同的表中多中有同名字段时，需要将同名字段设为不重名的。

字段名 [as] 别名

例子：

```mysql
select name as name1,name name2 from student;

```

### form 数据源

#### 单表

from 表名

#### 多表

从多张表获取数据

from 表名1, 表名2

```mysql
select *from 表1,表2;

```

若表一有 7条数据 ，表2 有3条数据

则上返回结果为21条。

从第一张取出一条数据去以此拼凑第二张表的数据 得到3条数据

#### 动态数据

from后面跟的数据不是一个实体表，而是从一个表中查询出来的二维数组。必须设置一个别名

```mysql
select 字段 from (select 字段 from 表名) [as] 别名 

```

从另外一张表查询出来，再查询

### where字句

从数据表获取数据的时候，进行筛选

在拿到一条结果时就进行判断，如果不存在就舍弃。

不能使用聚合函数。

where 是通过运算符来比较运算结果的

### group by字句

group by 表示分组的含义，分组之后进行数据统计。

#### 聚合函数

搭配聚合函数一起使用。

1. count() 求数据的数量，空值不统计，若如果为 * 为统计**记录** 
2. avg()  求平均值
3. sum() 求和
4. max() 求最大值
5. min()求最小值
6. group_concat()将数据字段拼凑起来

#### 多分组

将数据按照某个字段进行分组之后，对已经分组的数据再次进行分组

字段在前 先分组，字段在后的后分组，

默认进行升序排序 [asc/desc]

```mysql
select count(*) ,class_id,group_concat(name) from student group by class_id ,gender desc;
-- 班级升序 ，性别降序

```

#### 回溯统计

当进行多分组之后，往上统计的过程需要进行层层上报，将这种层层上报的过程称之为回溯统计：每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为null

基本语句：group by  with rollup



```mysql
select class_id,count(*)from my_student group by class_id;

```

| class_id | count(*) |
| -------- | -------- |
| 1        | 3        |
| 2        | 3        |



```mysql
select class_id,count(*)from my_student group by class_id with rollup;

```

| class_id | count(*) |
| -------- | -------- |
| 1        | 3        |
| 2        | 3        |
| null     | 6        |





```mysql
select class_id,count(*),gender from my_student group by class_id ,gender;

```

| class_id | gender | count(*) |
| -------- | ------ | -------- |
| 1        | 男     | 1        |
| 1        | 女     | 2        |
| 2        | 男     | 2        |
| 2        | 女     | 1        |

**多分组回溯**

```mysql
select class_id,count(*),gender from my_student group by class_id ,gender with rollup;

```

| class_id | gender | count(*) |
| -------- | ------ | -------- |
| 1        | 男     | 1        |
| 1        | 女     | 2        |
| 1        | null   | 3        |
| 2        | 男     | 2        |
| 2        | 女     | 1        |
| 2        | null   | 3        |
| null     | null   | 6        |



### having 字句

having 在group by字句之后，可以针对分组进行数据筛选，where不行

 group by 可以使用聚合函数，where表示将数据从磁盘拿到内存，where之后的所有操作都是内存操作

### order by 排序

根据校对规则对字段进行排序

asc降序|dasc升序

order by 字段1, 字段2......

### limit子句

限制获取子句的数量。

#### 分页

利用limit来限制获取指定区间的数据，

基本语法

```mysql
select *from student limit offset,length
-- offset 偏移量 
-- length 具体多少条记录(如果数量不够，不会强求)

```



## 连接查询

### 联合查询

合并多个相似的选择查询的结果集

将多个查询结果合并到一起（纵向合并）

​							

#### 应用场景

1. 数据量大的情况下，需要对每每张表进行分部数据统计
2. 将同一张表不同的结果，合并到一张展数据

#### 基本语法

```mysql
select 语句
union [union 选项]
select 语句;


```

ｕｎｉｏｎ选项

1. ｄｉｓｔｉｎｃｔ　去重　默认选项
2. ａｌｌ　保存所有的结果



ｕｎｉｏｎ只需要保证字段数一样，不需要保证字段名一致

只保留第一个ｓｅｌｅｃｔ语句的对应的名字



#### ｏｒｄｅｒ　ｂｙ　语句

只要使用ｏｒｄｅｒ　ｂｙ语句就必须将ｓｅｌｅｃｔ　语句括起来



ｏｒｄｅｒ　ｂｙ　在联合查询中生效必须配合ｌｉｍｉｔ**必须**跟后面的限制数。通常设置一个较大的数









### 表间查询

将多张表连接在一起进行查询（会导致记录数行和字段数列发生改变）

在关系型数据库中，实体与实体之间是存在很多联系的。

#### 交叉连接

交叉连接：将两张表的数据与另外一张表彼此交叉

原理

- 从一张表依次取出每一条记录
- 取出每一条记录以后，与另外一张表的全部记录挨个匹配
- 没有任何匹配条件，所有的结果都会进行
- 记录数＝两张表的记录数相成

语法

- ```mysql
  select *from 表1 cross join 表2
  select *from my_student cross join my_int
  
  ```

```
  
- ```mysql
  select from 表1，表2    --  结果一致

```



#### 内连接

内连接：从一张表中取出所有的记录从另外一张表中匹配：利用匹配条件进行匹配

成功则保留，失败则放弃

原理

- 从第一张表取出一条数据，然后去另外一张表中进行匹配
- 利用匹配条件进行匹配
- 匹配到：保留，继续向下匹配
- 匹配失败：向下爱继续如果全表失败，结束

语法

```mysql
表1 [inner] join 表2 on 匹配条件
select *from my_student join my_class on my_student.class_id=my_class.id;

```

如果内连接没有条件就是交叉连接

内连接要保证匹配到，才能保存

可以使用where替换on进行内连接

#### 外连接

外连接：按照某张表作为主表（表中所有记录在最后都会保留），

- 左连接
- 右连接

原理

- 左连接是左表为主表，右连接是右表为主表
- 拿主表的每一条记录，去匹配另外一张表



语法

左连接是主表在前

右连接是主表在后

```mysql 
left/right join on 条件

```



#### 自然连接

表A和表B中有相同的名称的字段

使用自然连接

```mysql
表1 natrual join 表2

```



#### using关键字

在连接查询时用on的地方使用using 



使用using对应的两表的连接字段是同名的

```mysql
表1 join 表2 using (同名字段)

```







## 子查询

子查询。嵌套查询查询下层的程序模块



exists 返回的结果是1 或者0



- where 子查询
- from 子查询（子查询作为数据源）

### 标量子查询

子查询的结果是一个数据

```mysql
select *from class where id=(select class_id from student where stu_name='小王' ) ；

```

### 列子查询



子查询的结果是一列  集合

例子：查询已有学生的班级

```mysql
select *from class where id in (select class_id from student)

```

### 行子查询

行查询的结果是一行多列

- **行元素**

行元素：字段元素是指一个字段对应的值，行元素对应的就是多个字段，多个字段合起来作为一个元素参与运算，把这种情况称之为行元素



语法：

```mysql
主查询   where 条件[（构造的一个行元素）]=（行子查询）

```

获取班级年龄最大，且身高最高的学生

```mysql
select *from student where (stu_age,stu_height)=(select max(stu_age),max(stu_heightt) from student )

```

### 表子查询

```mysql
select 字段表 from(子查询)

```

 

例子：获取班级最高的学生

```mysql
select *from (select student order by stu_height desc) group by class_id;

```

### exists子查询

查询结果只有0或者1，1代表成立，0代表不成立

语法

```mysql
where exists(查询语句 )

```

查询有学生在的班级

```mysql
select *from class as c where exists(select stu_id from student as s where s.class_id= c.id)

```

### 关键字

- in 主查询
  where 条件 in（列子查询）
- any 任何一个
  =any(列子查询)：条件在查询结果中有任意一个匹配，等价于in
  <>any(列子查询)：条件在查询结果中不等于任意一个
  1=any（1，2，3 )     ===true
  1<>any（1，2，3)    \=\==true
- some  和any一致
- all
  all(列子查询)



## 其他

### 数据备份与还原

`sql`备份，不仅备份数据，而且备份数据库语句，但是产生的备份文件特别大。数据变更不是特别频繁的语句

windows下有一个专门用于备份`sql`的客户端  `mysqldump.exe`





```shelll
mysqldump -h地址 -u用户 -p密码 数据库名字 [表1    表2......]>备份文件地址

```

- 整库备份（提供数据库名子）
- 单表备份（数据库后面给一张表）
- 多表备份

数据还原

必须指定数据库

- 利用mysql客户端 mysql.exe -hpup 数据库<文件位置
- sql指令，提供了一种导入 source sql 文件位置//必须进入对应的数据库

### 用户权限

```mysql
select *from mysql.user\G

```



user：代表用户的用户名

host：代表允许访问的客户端（ip或者主机地址）。如果host



- 创建用户

  1. 使用root用于在mysql.user表中插入记录
  2. 专门创建用户的sql指令

  基本语法：`create user 用户@'地址' identified by '明文密码'` 

  用户：用户名@主机地址

  主机地址：‘/%’



```mysql
drop user user2；  -- 删除用户
set password for 用户 =password("新的密码")  ;-- 修改密码
uptate mysql.user set password = password ("new password") where user='' and  host ='';

```

#### 权限管理

1. 数据权限：增删该查（select \update\ delete\insert）
2. 结构权限：结构操作（create \drop）
3. 管理权限：权限管理（create user\grant\revoke）通常给管理员

- 授予权限：grant

  将权限分配给用户

  基本语法：grant 权限列表  on 数据库/* .表名/* to 用户

  权限列表：使用逗号分割，但是可以使用all privilege代表全部 权限

  select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file

```mysql
grant 权限列表 on 数据库名.表名 to 用户@用户地址

grant select on test.* to user1@localhost   -- 使用%匹配符，匹配多个字符

revoke 权限列表/all privileges on '用户'@ '地址'
-- 取消权限

flush privileges;   //刷新

```

### 视图

```mysql
create view 视图名 as select 语句； -- 创建视图
replace view  视图名 as select 语句；  -- 更新视图
drop view 视图名   -- 删除视图

```

在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。

视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。

## 事务

事务：访问并可能更新数据库的中各种数据项的一个**程序执行单元**。事务通常由高级数据库操纵杆给语言或编程语言书写的用户程序执行所引起 。事务由事务开始和事务结束之间执行的全体操作组成。合并成程序执行单元。

事务原理

mysql 允许将事务统一进行管理（存储引擎时innodb），将用户所做的操作，暂时先保存下来，不直接放到数据表



### 自动事务autocommit

当客户端发送一条sql指令，给服务器的时候，服务器在执行之后，不用等待用户反馈的结果，会自动将结果同步到数据表

```mysql
show variables like 'autocommit';

```

![](深度截图_选择区域_20190429172818-1556530369609.png)

```mysql
set autocommit =OFF；    --  关闭事务

```

这时做增删改时数据不会同步，在另一个客户端看不到结果，当前客户端可以看到。

会利用事务日志的结果对数据进行查看

```mysql
commit -- 使用commit 提交事务

```

当提交事务之后，在另一个客户端就可以管看到结果

自动事务一般不关闭，一般使用手动事务来进行





### 手动事务

手动事务：不管开始还是过程还是结束都需要用户，手动发送事务操作指令来实现

1. `start transcation`  开启事务
2. 事务处理：多个指令构成
3. `commit/rollback`，到这个时候所有的事务才会提交/清空





回滚点：

savepoint，当有一系列事务操作时，而其中的步骤如果成功了，没有必要重新来过，可以在某个点，设置一个记号（回滚点），如果后面有错误，那么可以回到这个记号的位置



```mysql
sacepoint 回滚点名称；
rollback 设定的回滚点

```



### 事务的特性

事务由四种特性：原子性、一致性、隔离性、持久性

1. **原子性**：一个事务是一个不可分割的工作单位，事务中的操作，要么全做成，要么都不做
   事务是不可拆分的

2. **一致性（consistency）**
   事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关。

   要么是一次性修改，要么时根本不动

3. **隔离性（isolation）**
   一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

   如果一个客户端在使用事务操作一个数据的时候，另外一个客户端不对该数据进行操做，发生等待。

4. **持久性（durability）**
   持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。









## 函数

### 变量

#### 系统变量

所有连接都有效

系统内部定义的变量，系统变量针对多有用户（mysql客户端）有效

查看系统所有变量 `show variables [like pattern]`

查询系统变量

```mysql
select @@变量名

```

1. 局部修改：只修改当前客户端的，并且当此有效

   ```mysql
   set 变量名 =新值；
   
   ```

2. 全局修改：针对所有客户端，”所有时刻“都有效

   ```mysql
   set global 变量名 =值； -- 或者
   set @@global.变量名 = 值；
   
   ```

   全局修改只针对新客户端有效，当前如果查询当前变量值不发生改变

   注意：如果想要本次连接的变量修改有效，不能使用全局修改，只能使用会话级别修改

#### 会话变量

用户定义使用@符号定义

当此连接有效，只要当此连接就有效（可以跨库）

会话变量又称为用户变量，会话变量跟mysql客户端时绑定的，设置的变量，只对当前的用户使用的客户端生效

定义用户变量：`set @变量名=值`

**在mysql 中没有比较符号，所以赋值符号为  set：= 值**

允许将从表中查到的数据储存到变量中：查询得到的数据必须只能是一行数据（一个变量对应一个字段值）：mysql没有数组。

1. 赋值且查看赋值过程

   ```mysql
   select @变量1 :=字段1，@变量2:=字段2....from 数据表 where 条件
   
   ```

2. 赋值，不看过程

   ```mysql
   select 字段1,字段2...from 数据源 where 条件 into @变量1，变量2
   
   ```

#### 局部变量（局部作用于）

只能在结果内声明

begin 到 end 语句块之间。在该语句块里设置的变量

1. 局部变量是 `declare` 关键字声明

2. 局部变量 `declare` 语句的位置一定是在begin和end之间（在下面讲到的函数\存储过程\触发器  中使用）

3. 声明语法：declare 变量名 数据类型[属性]

   

### 流程结果

#### ｉｆ分支

if在mysql中有两种基本用法

1. 在select查询中，当作一种条件来进行判断

   ```mysql
   if(条件，为真结果，为假结果)
   -- 例子
   select *,from if(stu_age>20,"符合"，"不符合") as judge from my_student;
   
   ```

   

2. 在复杂的语句块中

   ```mysql
   if 条件表达式 then
   	满足条件要执行的语句
   end if；
   
   
   ```

#### while  循环

```mysql
while 条件 do
	要循环执行的代码
end while

```

在代码块中使用

结构标志符

```mysql
标志名字：while 条件 do
循环体
end while[标识名字]

```

标志符的存在主要是为了循环体中使用循环控制。在mysql中没有 `continue` 和 `break` 由自己的关键字代替



```mysql
lterate 标志名字    -- :以下代码不执行，重新开始循环
leave 标志名字      -- 离开，真个该循环终止

```



### 函数

#### 内置函数

内置函数

|                  名称                  | 说明                                                         |
| :------------------------------------: | :----------------------------------------------------------- |
|                字符函数                |                                                              |
|             char_length()              | 判读字符换的字附属                                           |
|                length()                | 判读字符串的数                                               |
|               concat ()                | 连接字符串                                                   |
|                instr()                 | 判断字符在目标字符串中是否存在，存在返回其位置，不存在返回0  |
|                lcase()                 | 全部小写                                                     |
|                 left()                 | 从左侧指定位置开始截取字符串                                 |
|                ltrim()                 | 消除左边对应的空格                                           |
|                 mid()                  | 从中间指定位置开始截取，如果不指定截取长度，直接到最后。     |
|                时间函数                |                                                              |
|                 now()                  | 返回当前时间，日期 时间                                      |
|               curdate()                | 返回当前日期                                                 |
|               curtime()                | 返回当前时间                                                 |
|               datediff()               | 判断两个日期之间的天差距  ，必须是字符串类型                 |
| date_add(日期,interval 时间数字  type) | type：day/hour/minute/second   进行时间增加                  |
|            unix_timestamp()            | 获取时间戳                                                   |
|         from_timestamp(时间戳)         | 获取对应时间类型                                             |
|                数学函数                |                                                              |
|                 abs()                  | 绝对值                                                       |
|               ceiling()                | 向上取整                                                     |
|                floor()                 | 下取整                                                       |
|                 pow()                  | 指数                                                         |
|                 rand()                 | 随机数                                                       |
|                round()                 | 四舍五入                                                     |
|                其他函数                |                                                              |
|                 md5()                  | 对数据进行加密                                               |
|               version()                | 获取版本号                                                   |
|               datebase()               | 显示当前所在的数据库                                         |
|                 uuid()                 | 生成一个唯一标志符，自增长是单表唯一，uuid是整库（数据唯一同时空间唯一） |

#### 用户自定义函数

mysql 一旦见到语句结束符，就会自动开始执行，所以需要重置结束符才能执行

语法

```mysql
delimiter 新符号
create function 函数名（形参名  类型）
returns 返回值类型;
begin 
//函数体
return 返回值数据;   必须与结构体中的返回值类型一致
end ;
delimiter ;

```

需要为型参数传数据类型

```mysql
show function status  [like `pattern`]; -- 查看所有函数

```

调用函数

```mysql
select 函数名；

```

删除函数

```mysql
drop function 函数名；

```

1.自定义函数属于用户会话级别的，只有当前客户端的数据库中可以使用

2.可以在不同的数据库下看到，但是不可以使用

3.函数表必须规范返回值，不能使用select 指令，select一旦执行就会得到一个结果，可以使用一个select 给变量赋值

```mysql
 select 字段1，字段2 from 表 into 变量1 ，变量2

```



## 存储过程



### 概念

存储过程实在大型数据库系统中，一组为了完成**特定功能的sql语句集**，







### 创建语法

```mysql
create procedure 过程名字 （{参数列表}）
begin
	过程体
end
结束符（:）
-- 如果只有一条指令可以省去 begin和end



delimiter //

create function f(x int)

returns  varchar(2)

begin

if x=10 then return '1132141234';

else then return '121321';

end //

delimiter ;

```

### 查看过程

```mysql
show procedure status;
show create procedure 过程名；

```

### 删除过程

```mysql
drop procedure 过程名

```



### 调用过程

```mysql
call 过程名(参数)；

```



### 形参类型

#### in

表示参数从外部传入里面使用，可以是直接数据也可以是保存数据的变量

#### out

表示参数是从过程里面把参数保存到变量中，交给外部使用，传入的必须是变量

如果传入的out变量在外部有数据，那么在进入过程之后，第一件事就是被清空，null。

#### inout

数据可以从外部传入内部使用，同时内部操作之后，又会将数据返还给外部







在创建过程语句中

型参 ： 型参类型 变量名 数据类型 





## 触发器







触发器本质上是存储过程,触发器被关联到一个表的数据对象，触发器是不需要手动调用的，当出现一个表的特殊操作它就会被激活



创建触发器

```mysql
create trigger 触发器名 触发时机 触发事件
      on 表名 for each row 触发动作

```



触发事件（增删改）

1. insert
2. update
3. delete或replace

触发时机

1. after   在事件之后触发
2. befor  在事件之前触发



变量

new ,old



```mysql
delimiter //
create trigger table_trigger after delete on student for each row
begin 
	update from class set class_number =class_number-1 where id=old.class_id;
end //
delimiter ;


```







触发器的删除

```mysql
drop trigger 触发器名字

```

