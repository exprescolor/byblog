---
layout:     post
title:      够不够你说了算(中)
subtitle:   golang的小基础，闲来翻看一下
date:       2019-08-05
author:     HH
header-img: img/post-bg-golang.png
catalog: true
tags:
    - Golang
    - 语言基础
---

# 简介

> 从微信公众号`Go程序员开发`搬过来的，一些小基础，闲暇之时可以翻看巩固基础。

## 前言：为什么一定要学Go

>Go语言是谷歌2009发布的第二款开源编程语言。
>Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

#### 与其他语言相比的优势

**学习曲线**

它包含了类C语法、GC内置和工程工具。这一点非常重要，因为Go语言容易学习，所以一个普通的大学生花一个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。

**效率**

Go拥有接近C的运行效率和接近PHP的开发效率，这就很有利的支撑了上面大家追求快速的需求。

**出身名门、血统纯正**

之所以说Go语言出身名门，是因为我们知道Go语言出自Google公司，这个公司在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。我们看看Go语言的主要创造者，血统纯正这点就可见端倪了。

**自由高效：组合的思想、无侵入式的接口**

Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程以及函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。

**强大的标准库**

这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。

**部署方便：二进制文件、Copy部署**

我相信这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。

**简单的并发**

它包含了降低心智的并发和简易的数据同步，我觉得这是Go最大的特色。之所以写正确的并发、容错和可扩展的程序如此之难，是因为我们用了错误的工具和错误的抽象，Go可以说这一块做的相当简单。

**稳定性**

Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。

#### Go语言适合用来做什么？

- 服务器编程：以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。
- 分布式系统：数据库代理器等。
- 网络编程：这一块目前应用最广，包括Web应用、API应用、下载应用、内存数据库。
- 云平台：google开发的groupcache，couchbase的部分组建云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。

#### Go语言成功的项目

>nsq：bitly开源的消息队列系统，性能非常高，目前他们每天处理数十亿条的消息
>docker：基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建
>packer：用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者
>skynet：分布式调度框架
>Doozer：分布式同步工具，类似ZooKeeper
>Heka：mazila开源的日志处理系统
>cbfs：couchbase开源的分布式文件系统
>tsuru：开源的PAAS平台，和SAE实现的功能一模一样
>groupcache：memcahe作者写的用于Google下载系统的缓存系统
>god：类似redis的缓存系统，但是支持分布式和扩展性
>gor：网络流量抓包和重放工具

#### 哪些大公司在用go语言？

- Google
  这个不用多做介绍，作为开发Go语言的公司，当仁不让。Google基于Go有很多优秀的项目，比如：[kubernetes](https://github.com/kubernetes/kubernetes)  ，大家也可以在[Github](https://github.com/google/)上  查看更多Google的Go开源项目。

- Facebook
  Facebook也在用，为此他们还专门在Github上建立了一个开源组织[facebookgo](https://github.com/facebookgo)，大家可以通过  访问查看facebook开源的项目，比如著名的是平滑升级的grace。

- 腾讯
  腾讯作为国内的大公司，还是敢于尝试的，尤其是[Docker](http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice)容器化这一块，他们在15年已经做了docker万台规模的实践，具体可以参考

- 百度
  目前所知的百度的使用是在运维这边，是百度运维的一个[BFE](http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend)项目，负责前端流量的接入。他们的负责人在2016年有分享，大家可以看下这个

- 阿里
  阿里巴巴具体的项目不太清楚，不过听说其系统部门、CDN(Content Delivery Network)等正在招Go方面的人。

- 京东
  京东云消息推送系统、云存储，以及京东商城等都有使用Go做开发。

- 小米
  小米对Golang的支持，莫过于[运维监控系统](http://open-falcon.com/)的开源，此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。

- 360
  360对Golang的使用也不少，一个是开源的日志搜索系统[Poseidon](https://github.com/Qihoo360/poseidon)，托管在Github上。

## 第四章 Go语言基本类型

#### Go语言fmt包详解

**格式化输出函数**

```
func Print(a ...interface{}) (n int, err error)
```

Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格，返回写入的字节数和遇到的任何错误。

```
func Printf(format string, a ...interface{}) (n int, err error)
```

Printf根据format参数生成格式化的字符串并写入标准输出，返回写入的字节数和遇到的任何错误。

```
func Println(a ...interface{}) (n int, err error)
```

Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符，返回写入的字节数和遇到的任何错误。

**常用的格式化**

Go语言的标准输出流在打印到屏幕时有些参数跟别的语言（比如C#和Java）不同，下面是我整理的一些常用的格式化操作。

- 普通占位符

| 占位符 | 说明                               | 举例                    |
| :----- | :--------------------------------- | :---------------------- |
| %v     | 以默认的方式打印变量的值           | fmt.Printf("%v", site)  |
| %+v    | 在打印结构体时，会添加字段名       | fmt.Printf("%+v", site) |
| %#v    | 在打印结构体时，会添加字段名和包名 | fmt.Printf("%#v", site) |
| %T     | 打印变量的类型                     | fmt.Printf("%T", site)  |
| %%     | 字面上的百分号，并非值的占位符     | fmt.Printf("%%")        |

- 布尔占位符

| 占位符 | 说明            | 举例                   |
| :----- | :-------------- | :--------------------- |
| %t     | 打印true或false | fmt.Printf("%t", true) |

- 整数占位符

| 占位符 | 说明                                                         | 举例                     |
| :----- | :----------------------------------------------------------- | :----------------------- |
| %b     | 表示为二进制 binary                                          | fmt.Printf("%b", 100)    |
| %c     | 该值对应的unicode码值                                        | fmt.Printf("%c", 0x4E2D) |
| %d     | 表示为十进制                                                 | fmt.Printf("%d", 10)     |
| %o     | 表示为八进制                                                 | fmt.Printf("%o", 0x12)   |
| %q     | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 | fmt.Printf("%q", 0x4E2D) |
| %x     | 十六进制表示，字母形式为小写 a-f                             | fmt.Printf("%x", 13)     |
| %X     | 十六进制表示，字母形式为大写 A-F                             | fmt.Printf("%x", 13)     |
| %U     | 表示为Unicode格式：U+1234，等价于"U+%04X"                    | fmt.Printf("%U", 0x4E2D) |

- 浮点数和复数的组成部分（实部和虚部）

| 占位符 | 说明                                                  | 举例                       |
| :----- | :---------------------------------------------------- | :------------------------- |
| %e     | (=%.6e) 6位小数点 科学计数法，例如 -1234.456e+78      | fmt.Printf("%e", 10.2)     |
| %E     | 科学计数法，例如 -1234.456E+78                        | fmt.Printf("%e", 10.2)     |
| %f     | (=%.6f) 6位小数点 有小数点而无指数，例如 123.456      | fmt.Printf("%f", 10.2)     |
| %g     | 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 | fmt.Printf("%g", 10.20)    |
| %G     | 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 | fmt.Printf("%G", 10.20+2i) |

- 字符串与字节切片 %cap.len

| 占位符  | 说明                                           | 举例                                |
| :------ | :--------------------------------------------- | :---------------------------------- |
| %s      | 输出字符串表示（string类型或[]byte)            | fmt.Printf("%s", []byte("lemonhh")) |
| %10s    | 输出字符串最小宽度为10(右对齐)                 | fmt.Printf("%10s", "lemonhh")       |
| %-10s   | 输出字符串最小宽度为10(左对齐)                 | fmt.Printf("%-10s", "lemonhh")      |
| %.5s    | 输出字符串最大宽度为5                          | fmt.Printf("%.5s", "lemonhh")       |
| %5.10s  | 输出字符串最小宽度为5，最大宽度为10            | fmt.Printf("%5.10s", "lemonhh")     |
| %-5.10s | 输出字符串最小宽度为5，最大宽度为10(左对齐)    | fmt.Printf("%-5.10s", "lemonhh")    |
| %5.3s   | 输出字符串宽度为5,如果原字符串宽度大于3,则截断 | fmt.Printf("%5.3s", "lemonhh")      |
| %010s   | 如果宽度小于10，就会在字符串前面补零           | fmt.Printf("%010s", "lemonhh")      |
| %q      | 双引号围绕的字符串，由Go语法安全地转义         | fmt.Printf("%q", "oldboy")          |
| %x      | 十六进制，小写字母，每字节两个字符             | fmt.Printf("%x", "oldboy")          |
| %X      | 十六进制，大写字母，每字节两个字符             | fmt.Printf("%X", "oldboy")          |

- 指针

| 占位符 | 说明                  | 举例                     |
| :----- | :-------------------- | :----------------------- |
| %p     | 十六进制表示，前缀 0x | fmt.Printf("%p", &site)  |
| %#p    | 不带前缀 0x           | fmt.Printf("%#p", &site) |

#### Go语言字符串

Go语言的字符串是一个用UTF-8编码的变宽字符序列，它的每一个字符都用一个或多个字节表示 。

在Go语言中，没有字符类型，字符类型是rune类型，rune是int32的别称。可使用 []byte() 获取字节，使用 []rune() 获取字符，可对中文进行转换。

**定义字符串**

第一种，双引号，用来创建可解析的字符串字面量 (支持转义，但不能用来引用多行)；

```
str := "Go语言字符串\n不能跨行赋值"
```

第二种，反引号，用来创建原生的字符串字面量 ，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。

```
str := `Go原生原格式字符串
            可以跨行`
```

**注意：**单引号不能用于定义字符串，单引号用于定义Go语言的一个特殊类型 rune，类似其他语言的byte但又不完全一样，是指码点字面量（Unicode code point），不做任何转义的原始内容。

**连接字符串**

第一种，直接使用 "+" 运算符链接

```
str := "hello" + "lemonhh"
```

golang 里面的字符串都是不可变的，每次运算都会产生一个新的字符串，所以会产生很多临时的无用的字符串，不仅没有用，还会给 gc 带来额外的负担，所以性能比较差。

**注意：**连接跨行字符串时，"+" 必须在上一行末尾，否则导致编译错误。

第二种，使用 fmt.Sprintf() 链接

```
str := fmt.Sprintf("%s,%s", "hello", "lemonhh")
```

内部使用 []byte 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 interface，所以性能也不是很好。

第三种，使用 strings.Join() 链接

```
str := strings.Join([]string{"hello", "oldboy"}, ",")
```

join会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小。

第四种，使用 buffer.WriteString() 链接

```
var buffer bytes.Buffer
buffer.WriteString("hello")
buffer.WriteString(",")
buffer.WriteString("oldboy")
str := buffer.String()
```

这个比较理想，可以当成可变字符使用，对内存的增长也有优化。

**总结：**

1. 在已有字符串数组的场合，使用 strings.Join() 能有比较好的性能；

2. 在一些性能要求较高的场合，尽量使用 buffer.WriteString() 以获得更好的性能；

3. "+" 运算符在较少字符串连接的场景下性能最好，而且代码更简短清晰，可读性更好；

4. 如果需要拼接的不仅仅是字符串，还有数字之类的其他需求的话，可以考虑 fmt.Sprintf()。

**字符串长度**

第一种，将字符串转换为 []rune 后调用 len 函数进行统计

```
package main

import (
    "fmt"
)

func main() {
    str := "hello lemonhh"
    length := len([]rune(str))
    fmt.Println(length)
}
```

在 Golang 中，如果字符串中出现中文字符不能直接调用 len 函数来统计字符串字符长度，这是因为在 Go 中，字符串是以 UTF-8 为格式进行存储的，在字符串上调用 len 函数，取得的是字符串包含的 byte 的个数。

第二种，使用 bytes.Count() 统计

```
func Count(s, sep []byte) int
```

计算字节切片sep在字节切片s中非重叠显示的个数，如果 sep 为 nil，则返回 s 中的字节个数 + 1。

```
package main

import (
    "bytes"
    "fmt"
)

func main() {
    str := "hello lemonhh"
    length := bytes.Count([]byte(str), nil) - 1
    fmt.Println(length)
}
```

第三种，使用 strings.Count() 统计

```
func Count(s, sep string) int
```

判断字符sep在字符串s中出现的次数，没有找到则返回-1，如果为空字符串("")则返回字符串的长度+1。

```
package main

import (
    "fmt"
    "strings"
)

func main() {
    str := "hello lemonhh"
    length := strings.Count(str, "") - 1
    fmt.Println(length)
}
```

第四种，使用 utf8.RuneCountInString() 统计

```
func RuneCountInString(s string) (n int)
```

返回 s 字符串长度，可以正常解析中文，一个中文被当做一个字符。

```
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    str := "hello lemonhh"
    length := utf8.RuneCountInString(str)
    fmt.Println(length)
}
```

**字符串操作**

使用索引号 "[ ]" 返回子串。 返回的字符串依然指向原字节数组，仅修改了指针和长度属性。实例如下：

```
package main

import (
    "fmt"
)

func main() {
    str := "hello, lemonhh"
    s1 := str[0:5]
    s2 := str[7:14]
    fmt.Println(s1, s2)
}
```

运行结果：

```
hello lemonhh
```

修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。实例如下：

```
package main

import "fmt"

func main() {
    str1 := "hello lemonhh"
    s1 := []byte(str1)
    s1[0] = 'H'
    fmt.Println(string(s1))

    str2 := "鸟宿池边树，僧推月下门。"
    s2 := []rune(str2)
    s2[7] = '敲'
    fmt.Println(string(s2))
}
```

运行结果：

```
Hello oldboy
鸟宿池边树，僧敲月下门。
```

#### Go语言string包详解

strings包实现了用于操作字符的简单函数。

**查找操作**

判断给定字符串s中是否包含子串substr, 找到返回true, 找不到返回false

```
func Contains(s, substr string) bool
```

实例如下：

```
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("包含子串返回：", strings.Contains("lemonhh", "lemon"))
    fmt.Println("不包含子串返回：", strings.Contains("lemonhh", "sweet"))
    fmt.Println("子字符串是空字符串返回：", strings.Contains("lemonhh", ""))
    fmt.Println("原字符串、子字符串都是空字符串返回：", strings.Contains("", ""))
    fmt.Println("中文字符串包含子串返回：", strings.Contains("柠檬精浩浩", "柠檬"))
}
```

运行结果：

```
包含子串返回： true
不包含子串返回： false
子字符串是空字符串返回： true
原字符串、子字符串都是空字符串返回： true
中文字符串包含子串返回： true
```

在字符串s中查找sep所在的位置, 返回位置值, 找不到返回-1

```
func Index(s, sep string) int
```

实例如下：

```
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("存在返回第一个匹配字符的位置：", strings.Index("lemonhh", "hh"))
    fmt.Println("不存在返回：", strings.Index("lemonhh", "gg"))
    fmt.Println("中文字符串存在返回：", strings.Index("柠檬精浩浩", "柠檬"))
}
```

运行结果：

```
存在返回第一个匹配字符的位置： 5
不存在返回： -1
中文字符串存在返回： 0
```

统计给定子串sep的出现次数, sep为空时, 返回字符串的长度 + 1

```
func Count(s, sep string) int
```

实例如下：

```
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("子字符串出现次数：", strings.Count("lemonhh", "o"))
    fmt.Println("子字符串为空时, 返回：", strings.Count("lemonhh", ""))
}
```

运行结果：

```
子字符串出现次数： 1
子字符串为空时, 返回： 8
```

**重复操作**
重复s字符串count次, 最后返回新生成的重复的字符串

```
func Repeat(s string, count int) string
```

实例如下：

```
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(strings.Repeat("嘀嗒", 4), "时针它不停在转动")
}
```

运行结果：

```
嘀嗒嘀嗒嘀嗒嘀嗒 时针它不停在转动
```

**替换操作**
在s字符串中, 把old字符串替换为new字符串，n表示替换的次数，如果n<0会替换所有old子串。

```
func Replace(s, old, new string, n int) string
```

实例如下：

```
package main
import (
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println(strings.Replace("luck luck luck", "k", "ky", 2))
    fmt.Println(strings.Replace("luck luck luck", "k", "ky", -1))
}
```

运行结果：

```
lucky lucky luck
lucky lucky lucky
```

**删除操作**
删除在s字符串的头部和尾部中由cutset指定的字符, 并返回删除后的字符串

```
func Trim(s string, cutset string) string
```

实例如下：

```
package main
import (    
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println(strings.Trim("   lemonhh   ", " "))
}
```

运行结果：

```
lemonhh
```

**大小写转换**
给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)

```
func Title(s string) string
```

返回将所有字母都转为对应的小写版本的拷贝

```
func ToLower(s string) string
```

返回将所有字母都转为对应的大写版本的拷贝

```
func ToUpper(s string) string
```

实例如下：

```
package main
import (    
    "fmt"    
    "strings")
func main() {    
    fmt.Println(strings.Title("It is never too late to learn.")) 
    fmt.Println(strings.ToLower("It Is Never Too Late To Learn."))  
    fmt.Println(strings.ToUpper("It is never too late to learn."))}
```

运行结果：

```
It Is Never Too Late To Learn.
it is never too late to learn.
IT IS NEVER TOO LATE TO LEARN.
```

**字符串前缀后缀**判断字符串是否包含前缀prefix，大小写敏感

```
func HasPrefix(s, prefix string) bool
```

判断s是否有后缀字符串suffix，大小写敏感

```
func HasSuffix(s, suffix string) bool
```

实例如下：

```
package main
import (    
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println("前缀是以lemonhh开头的：", strings.HasPrefix("lemonhh", "lemon")) 
    fmt.Println("后缀是以hh结尾的：", strings.HasSuffix("lemonhh", "hh"))
}
```

运行结果：

```
前缀是以lemonhh开头的： true
后缀是以hh结尾的： true
```

**字符串分割**

用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。

```
func Split(s, sep string) []string
```

返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。

```
func Fields(s string) []string
```

实例如下：

```
package main
import (    
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println("Split 函数的用法")    
    fmt.Printf("%q\n", strings.Split("Linux,Python,Golang,Java", ","))    
    fmt.Printf("%q\n", strings.Split("a mountain a temple", "a "))    
    fmt.Printf("%q\n", strings.Split(" abc ", ""))    
    fmt.Printf("%q\n", strings.Split("", "lemonhh"))    
    fmt.Println("Fields 函数的用法")    
    fmt.Printf("Fields are: %q\n", strings.Fields(" Linux Python Golang  Java "))
}
```

运行结果：

```
Split 函数的用法
["Linux" "Python" "Golang" "Java"]
["" "mountain " "temple"]
[" " "a" "b" "c" " "]
[""]
Fields 函数的用法
Fields are: ["Linux" "Python" "Golang" "Java"]
```

#### Go语言数组

**数组**是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。

在Go语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从0开始。

数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可以让它在CPU缓存中待更久，所以迭代数组和移动元素都会非常迅速。

**数组定义**

第一种，通过指定数据类型和元素个数（数组长度）来声明数组。

声明一个长度为5的整数数组：

```
var array [5]int
```

声明一个长度为5的整数数组并初始化：

```
var array [5]int =[5]int{1,2,3,4,5}
```

第二种，一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型。声明一个长度为5的字符串数组并初始化每个元素：

```
array := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
```

第三种，如果你把长度写成…，Go编译器将会根据你的元素来推导出长度。通过初始化值的个数来推导出数组容量：

```
array := [...]int{1, 2, 3, 4, 5}
```

第四种，如果我们知道想要数组的长度，但是希望对指定位置元素初始化。声明一个长度为5的整数数组，为索引为1和3的位置指定元素初始化，剩余元素为该元素类型的默认值：

```
array := [5]int{1: 1, 3: 3}
```

注意：当一个数组被声明时，它里面包含的每个元素都会被初始化为该元素类型的默认值。一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。

**数组操作**

使用内置函数len()和cap()返回数组长度和数组容量。实例如下：

```
package main

import "fmt"

func main() {
    array := [2]int{}
    fmt.Printf("数组长度：%d，数组容量：%d\n", len(array), cap(array))
}
```

运行结果：

```
数组长度：2，数组容量：2
```

使用 [] 操作符来访问数组元素：改变索引为2的元素的值：

```
array := [5]int{1, 2, 3, 4, 5}
array[2] = 100
```

注意：数组可以通过下标进行访问，数组下标是从0开始，最后一个元素下标是：len(array)-1。如果下标在数组合法范围之外，则触发访问越界。实例如下：

```
package main

func main() {
    array := [5]int{1, 2, 3, 4, 5}
    array[5] = 100
}
```

编译错误：

```
./main.go:5:7: invalid array index 5 (out of bounds for 5-element array)
```

数组赋值操作，一个数组可以被赋值给任意相同类型的数组：

```
var arr1 [5]string
arr2 := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
arr1 = arr2
```

注意：

数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，实例如下：

```
package main

import "fmt"

func main() {
    var arr1 [3]string
    arr2 := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
    arr1 = arr2
    fmt.Println(arr1)
}
```

编译错误：

```
./main.go:8:7: cannot use arr2 (type [5]string) as type [3]string in assignment
```

**多维数组**

数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：

声明一个二维数组

```
var array [3][6]int
```

使用数组字面值声明并初始化

```
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
```

指定外部数组索引位置初始化

```
array := [4][2]int{1: {20, 21}, 3: {40, 41}}
```

同时指定内外部数组索引位置初始化

```
array := [4][2]int{1: {20, 21}, 3: {40, 41}}
```

使用内置函数len()和cap()返回多维数组长度和多维数组容量。实例如下：

```
package main

import "fmt"

func main() {
    array := [3][6]int{}
    fmt.Printf("数组长度：%d，数组容量：%d\n", len(array), cap(array))
}
```

运行结果：

```
数组长度：3，数组容量：3
```

通过 [] 操作符来访问数组元素：

```
var array [2][2]int
array[0][0] = 0
array[0][1] = 1
array[1][0] = 2
array[1][1] = 3
```

相同类型的多维数组相互赋值：

```
var arr1 [2][2]int
var arr2 [2][2]int
arr2[0][0] = 0
arr2[0][1] = 1
arr2[1][0] = 2
arr2[1][1] = 3
arr1 = arr2
```

#### Go语言类型转换

类型转换用于将一种数据类型的变量转换为另外一种类型的变量。

Go语言类型转换基本格式如下：表达式 T(v) 将值 v 转换为类型 T 。

Go语言各种类型转换及函数的高级用法：strconv包实现了基本数据类型和其字符串表示的相互转换。

**转字节**

字符串转字节

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var str string = "lemonhh"
    result := []byte(str)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is [108 101 109 111 110 104 104] , result type is []uint8
```

32位整形转字节

```
package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "reflect"
)

func main() {
    var x int32
    x = 100
    bytesBuffer := bytes.NewBuffer([]byte{})
    binary.Write(bytesBuffer, binary.BigEndian, x)
    result := bytesBuffer.Bytes()
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果

```
result is [0 0 0 100] , result type is []uint8
```

**转字符串**

字节转字符串

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var b []byte = []byte{108, 101, 109, 111, 110, 104, 104}
    result := string(b)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is lemonhh , result type is string
```

整形转字符串

```
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var x int
    x = 100
    result := strconv.Itoa(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is 100 , result type is string
```

FormatInt 将 int 型整数 i 转换为字符串形式 
base：进位制（2 进制到 36 进制） 大于 10 进制的数，返回值使用小写字母 ‘a’ 到 ‘z’

```
func FormatInt(i int64, base int) string
```

Itoa 相当于 FormatInt(i, 10)

64位整形转字符串

```
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var i int64
    i = 0x100
    result := strconv.FormatInt(i, 10)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is 256 , result type is string
```

布尔值转字符串

```
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    t := strconv.FormatBool(true)
    f := strconv.FormatBool(false)
    fmt.Printf("t is %v , t type is %v\n", t, reflect.TypeOf(t))
    fmt.Printf("f is %v , f type is %v\n", f, reflect.TypeOf(f))
}
```

输出结果

```
t is true , t type is string
f is false , f type is string
```

浮点数转字符串

```
strconv.FormatFloat(f,fmt,prec,bitSize)
f：要转换的浮点数 
fmt：格式标记（b、e、E、f、g、G） 
prec：精度（数字部分的长度，不包括指数部分） 
bitSize：指定浮点类型（32:float32、64:float64）

格式标记： 
‘b’ (-ddddp±ddd，二进制指数) 
‘e’ (-d.dddde±dd，十进制指数) 
‘E’ (-d.ddddE±dd，十进制指数) 
‘f’ (-ddd.dddd，没有指数) 
‘g’ (‘e’:大指数，’f’:其它情况) 
‘G’ (‘E’:大指数，’f’:其它情况)

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    f := 100.12345678901234567890123456789
    result := strconv.FormatFloat(f, 'e', 30, 32)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

结果输出

```
result is 1.001234588623046875000000000000e+02 , result type is string
```

**转整形**

int转int64

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 100
    result := int64(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is 100 , result type is int64
```

字符串转整形

```
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var str string
    str = "100"
    result, _ := strconv.Atoi(str)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果

```
result is 100 , result type is int
```

字节转32位整形

```
package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "reflect"
)

func main() {
    b := []byte{0x00, 0x00, 0x03, 0xe8}
    bytesBuffer := bytes.NewBuffer(b)

    var result int32
    binary.Read(bytesBuffer, binary.BigEndian, &result)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

结果输出

```
result is 1000 , result type is int32
```

**转浮点型**

float32转float64

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float32 = 100
    result := float64(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

整型转浮点型

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 100
    result := float32(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

字符串转浮点数

```
strconv.ParseFloat(str,bitSize)
str：要转换的字符串
bitSize：指定浮点类型（32:float32、64:float64）
如果 str 是合法的格式，而且接近一个浮点值，
则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准）
如果 str 不是合法的格式，则返回“语法错误”
如果转换结果超出 bitSize 范围，则返回“超出范围”

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var str string = "0.12345678901234567890"
    result, _ := strconv.ParseFloat(str, 32)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

**转布尔值**

字符串转布尔值

```
ParseBool 将字符串转换为布尔值 
它接受真值：1, t, T, TRUE, true, True 
它接受假值：0, f, F, FALSE, false, False. 
其它任何值都返回一个错误

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    result, _ := strconv.ParseBool("1")
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

```
result is true , result type is bool
```

注意：Go语言不能将其他类型当 bool 值使用。

```
package main

func main() {
    a := 100
    if a {
    }
}
```

编译错误：

```
./main.go:5:2: non-bool a (type int) used as if condition
```

## 第五章 Go语言引用类型

#### Go语言切片

Go语言切片是对数组的抽象。数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片（"动态数组"），与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。

**切片定义**

第一种，声明一个切片：

```
var slice []int
```

切片定义并初始化

```
var slice0 []int = []int{1,2,3}
var slice1 = []int{1,2,3}
```

第二种，通过make来创建切片

```
var slice0 []int = make([]int,10)
var slice1 = make([]int,10)
var slice2 = make([]int,10,10)
```

