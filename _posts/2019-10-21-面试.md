---
layout:     post 
title:      杂谈1021
subtitle:   练习题
date:       2019-10-21
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.如下代码中一共有几个构造方法？

```java
public class Test
{
    private int x;
    public Test()
    {
        x = 35;
    }
 
    public void Test(double f)
    {
        this.x = (int)f;
    }
 
    public Test(double f)
    {
        this.x = (int)f;
    }
 
    public Test(String s) {}
}
```

- 答案：3个
- 构造方法形式：类名([形式参数表])。构造方法没有返回值，不能添加void，构造方法可以被重载

#### 2.如下代码输出结果是什么？

```java
class A{
    public A(String str){
         
    }
}
public class Test{
    public static void main(String[] args) {
        A classa=new A("he");
        A classb=new A("he");
        System.out.println(classa==classb);
    }
}
```

- false
- 这题不管是`==`还是equals输出结果都为false。因为equals没有被重写时默认调用`==`进行比较。`==`表示的是是否指向同一个内存。

#### 3.如下代码的结果是什么？

```java
public class Test {
    static int x=10;
    static {x+=5;}
    public static void main(String[] args) //4
        {
        System.out.println("x="+x);
    }
    static{x/=3;};
}//9
```

- 编译通过，执行的结果是：x=5
- 首先进行静态成员初始化，之后进行静态代码块初始化，静态方法一般在最后
- 具体例子见下述代码

```java
class A{
    static {
        System.out.println("父类静态代码块");
    }
    public A(){
        System.out.println("父类构造方法");
    }
    {
        System.out.println("父类初始化块");
    }
}
public class B extends A{
    static{
        System.out.println("子类静态代码块");
    }
    public B(){
        System.out.println("子类构造方法");
    }
    {
        System.out.println("子类初始化块");
    }
    public static void main(String[] args){
        new B();
    }
}
```

#### 4.什么运算符把其操作数中所有值为0和所有值为1的位分别在结果的相应中设置1和0？

- `~`
- `~`是位运算符，意义是取反

#### 5.null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量，例如int、double、float、boolean

#### 6.stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。

#### 7.下面哪些是interface中合法方法定义的？

1. `public void main(String [] args);`
2. `private int getSum();`
3. `boolean setFlag(Boolean [] test);`
4. `public float get(int x);`

- 答案：1，3，4
- 接口中的方法必须是public的，方法默认为public abstract，变量默认为public static final

#### 8.以下代码的结果是什么？

```java
1+”10”+3+”2”
```

- "11032"

```java
System.out.println(1+"10"+3+"2");//11032
System.out.println(1+2+"10"+3+"2");//31032
System.out.println(1+"10"+3+1+"2");//110312
```

#### 9.java如何接受request域中的参数？

- 答案：`request.getParameter()`
- request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。

#### 10.JSP页面中的静态include和动态include的区别？

- 动态include用jsp:include动作实现	 <jsp:include page="included.jsp" flush="true" /> ，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数，各个文件分别先编译，然后组合成一个文件
- 静态include用include伪码实现，并不会检查所含文件的变化， 适合用于包含静态页面<%@ include file="included.htm" %>。先将文件的代码原封不动的加入到主页面从而合成一个文件，然后进行翻译，此时不允许有相同的变量。
- 两者的区别：
   - 执行时间上：
      - <%@ include file="relativeURI"%> 是在翻译阶段执行
      - <jsp:include page="relativeURI" flush="true" /> 在请求处理阶段执行
   - 引入内容的不同
      - <%@ include file="relativeURI"%>：引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 
      - <jsp:include page="relativeURI" flush="true" /> ：引入执行页面或 servlet 所生成的应答文本 

#### 11.如果一个list初始化为{5，3，1}，执行以下代码后，其结果为多少？

```java
nums.add(6);
nums.add(0,4);
nums.remove(1);
```

- 答案：4，3，1，6
- 先在最后一位后添加一个6，然后在第0位添加一个4，整体变为{4，5，3，1，6}。之后删除地址位1的数字，剩下{4，3，1，6}

#### 12.假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？

```java
public class Base
{
   public void methodOne()
   {
      System.out.print("A");
      methodTwo();
   }
 
   public void methodTwo()
   {
      System.out.print("B");
   }
}
 
public class Derived extends Base
{
   public void methodOne()
   {
      super.methodOne();
      System.out.print("C");
   }
 
   public void methodTwo()
   {
      super.methodTwo();
      System.out.print("D");
   }
}
```

- 答案：ABDC
- 本题是向上转型，父类只能调用父类方法或者子类重写后的方法，而子类中的单独方法是没有办法调用的
- 所以调用的顺序是：1，2，3，4，5，6，7.得到的结果是ABDC

```java
class Base
{ public void methodOne()  // (3)
    {
        System.out.print("A");
        methodTwo();  //执行到这里的时候调用子类的覆盖方法 (4)
    } public void methodTwo() // (7)
    {
        System.out.print("B");
    }
} 
 class Derived extends Base { public void methodOne() // (1)
    { super.methodOne();   // (2)
        System.out.print("C");
    } public void methodTwo()  //该方法为重写了父类的方法 （5）
    { super.methodTwo(); //(6)
        System.out.print("D");
    }
}
```

#### 13.访问权限：public>protected>默认(包访问权限)>private

#### 14.已知有下列Test类的说明，在该类的main方法内，则下列哪个语句是正确的？

```java
public class Test
{
private float f = 1.0f;
int m = 12;
static int n = 1;
public static void main (String args[])
{
Test t = new Test();
}
}
```

1. t.f;
2. this.n;
3. Test.m
4. Test.f

- 答案：1
- this不能在static的方法中使用，所以不能选择第二个。

#### 15.多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改成什么？

- 同步
- 对该数据加锁，放在同步代码块中synchronize(){}
   - 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个 处理机 上运行。其中两种并发关系分别是同步和互斥
   - 互斥：进程间相互排斥的使用临界资源的现象，就叫互斥
   - 同步： 进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。
   - 并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
   - 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。
   - 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
   - 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。

#### 16.以下哪一个不是赋值符号？

1. `+=`
2. `<<=`
3. `<<<=`
4. `>>>=`

- 答案：4
- `<<=`左移赋值
- `>>>=`右移赋值，左边空出的位以0填充