---
layout:     post 
title:      杂谈1021
subtitle:   练习题
date:       2019-10-21
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.如下代码中一共有几个构造方法？

```java
public class Test
{
    private int x;
    public Test()
    {
        x = 35;
    }
 
    public void Test(double f)
    {
        this.x = (int)f;
    }
 
    public Test(double f)
    {
        this.x = (int)f;
    }
 
    public Test(String s) {}
}
```

- 答案：3个
- 构造方法形式：类名([形式参数表])。构造方法没有返回值，不能添加void，构造方法可以被重载

#### 2.如下代码输出结果是什么？

```java
class A{
    public A(String str){
         
    }
}
public class Test{
    public static void main(String[] args) {
        A classa=new A("he");
        A classb=new A("he");
        System.out.println(classa==classb);
    }
}
```

- false
- 这题不管是`==`还是equals输出结果都为false。因为equals没有被重写时默认调用`==`进行比较。`==`表示的是是否指向同一个内存。

#### 3.如下代码的结果是什么？

```java
public class Test {
    static int x=10;
    static {x+=5;}
    public static void main(String[] args) //4
        {
        System.out.println("x="+x);
    }
    static{x/=3;};
}//9
```

- 编译通过，执行的结果是：x=5
- 首先进行静态成员初始化，之后进行静态代码块初始化，静态方法一般在最后
- 具体例子见下述代码

```java
class A{
    static {
        System.out.println("父类静态代码块");
    }
    public A(){
        System.out.println("父类构造方法");
    }
    {
        System.out.println("父类初始化块");
    }
}
public class B extends A{
    static{
        System.out.println("子类静态代码块");
    }
    public B(){
        System.out.println("子类构造方法");
    }
    {
        System.out.println("子类初始化块");
    }
    public static void main(String[] args){
        new B();
    }
}
```

#### 4.什么运算符把其操作数中所有值为0和所有值为1的位分别在结果的相应中设置1和0？

- `~`
- `~`是位运算符，意义是取反

#### 5.null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量，例如int、double、float、boolean

#### 6.stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。

#### 7.下面哪些是interface中合法方法定义的？

1. `public void main(String [] args);`
2. `private int getSum();`
3. `boolean setFlag(Boolean [] test);`
4. `public float get(int x);`

- 答案：1，3，4
- 接口中的方法必须是public的，方法默认为public abstract，变量默认为public static final

#### 8.以下代码的结果是什么？

```java
1+”10”+3+”2”
```

- "11032"

```java
System.out.println(1+"10"+3+"2");//11032
System.out.println(1+2+"10"+3+"2");//31032
System.out.println(1+"10"+3+1+"2");//110312
```

#### 9.java如何接受request域中的参数？

- 答案：`request.getParameter()`
- request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。

#### 10.JSP页面中的静态include和动态include的区别？

- 动态include用jsp:include动作实现	 <jsp:include page="included.jsp" flush="true" /> ，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数，各个文件分别先编译，然后组合成一个文件
- 静态include用include伪码实现，并不会检查所含文件的变化， 适合用于包含静态页面<%@ include file="included.htm" %>。先将文件的代码原封不动的加入到主页面从而合成一个文件，然后进行翻译，此时不允许有相同的变量。
- 两者的区别：
   - 执行时间上：
      - <%@ include file="relativeURI"%> 是在翻译阶段执行
      - <jsp:include page="relativeURI" flush="true" /> 在请求处理阶段执行
   - 引入内容的不同
      - <%@ include file="relativeURI"%>：引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 
      - <jsp:include page="relativeURI" flush="true" /> ：引入执行页面或 servlet 所生成的应答文本 

#### 11.如果一个list初始化为{5，3，1}，执行以下代码后，其结果为多少？

```java
nums.add(6);
nums.add(0,4);
nums.remove(1);
```

- 答案：4，3，1，6
- 先在最后一位后添加一个6，然后在第0位添加一个4，整体变为{4，5，3，1，6}。之后删除地址位1的数字，剩下{4，3，1，6}

#### 12.假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？

```java
public class Base
{
   public void methodOne()
   {
      System.out.print("A");
      methodTwo();
   }
 
   public void methodTwo()
   {
      System.out.print("B");
   }
}
 
public class Derived extends Base
{
   public void methodOne()
   {
      super.methodOne();
      System.out.print("C");
   }
 
   public void methodTwo()
   {
      super.methodTwo();
      System.out.print("D");
   }
}
```

- 答案：ABDC
- 本题是向上转型，父类只能调用父类方法或者子类重写后的方法，而子类中的单独方法是没有办法调用的
- 所以调用的顺序是：1，2，3，4，5，6，7.得到的结果是ABDC

```java
class Base
{ public void methodOne()  // (3)
    {
        System.out.print("A");
        methodTwo();  //执行到这里的时候调用子类的覆盖方法 (4)
    } public void methodTwo() // (7)
    {
        System.out.print("B");
    }
} 
 class Derived extends Base { public void methodOne() // (1)
    { super.methodOne();   // (2)
        System.out.print("C");
    } public void methodTwo()  //该方法为重写了父类的方法 （5）
    { super.methodTwo(); //(6)
        System.out.print("D");
    }
}
```

#### 13.访问权限：public>protected>默认(包访问权限)>private

#### 14.已知有下列Test类的说明，在该类的main方法内，则下列哪个语句是正确的？

```java
public class Test
{
private float f = 1.0f;
int m = 12;
static int n = 1;
public static void main (String args[])
{
Test t = new Test();
}
}
```

1. t.f;
2. this.n;
3. Test.m
4. Test.f

- 答案：1
- this不能在static的方法中使用，所以不能选择第二个。

#### 15.多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改成什么？

- 同步
- 对该数据加锁，放在同步代码块中synchronize(){}
   - 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个 处理机 上运行。其中两种并发关系分别是同步和互斥
   - 互斥：进程间相互排斥的使用临界资源的现象，就叫互斥
   - 同步： 进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。
   - 并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
   - 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。
   - 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
   - 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。

#### 16.以下哪一个不是赋值符号？

1. `+=`
2. `<<=`
3. `<<<=`
4. `>>>=`

- 答案：4
- `<<=`左移赋值
- `>>>=`右移赋值，左边空出的位以0填充

#### 17.以下代码的运行结果是什么？

```java
package algorithms.com.guan.javajicu; 
public class Example { 
  String str = new String("good"); 
  char[] ch = {'a','b','c'}; 
  public static void main(String[] args) { 
     Example ex = new Example(); 
     ex.change(ex.str, ex.ch); 
     System.out.print(ex.str +"and"); 
     System.out.print(ex.ch);  
  } 
    
  public void change(String str, char ch[]){ 
     str= "test ok"; 
     ch[0]= 'g'; 
  } 
} 
```

- 结果：goodandgbc
- String是不可修改的，所以结果为goodandgbc

#### 18.建立Statement对象的作用是什么？

- Statement对象用于执行不带参数的简单SQL语句。 
- Prepared Statement 对象用于执行预编译SQL语句。
- Callable Statement对象用于执行对存储过程的调用。

#### 19.在Java的多态调用中，new的是哪一个类就是调用的哪一个类的方法。这句话是对的吗？

- 不对
- Java多态有两种情况：重载和重写
   - 在重写中，运用的是动态单分配，是根据new的类型确定对象，从而确定调用的方法
   - 在重载中，运用的是静态多分配，即根据静态类型确定对象，因此不是根据new的类型确定调用的方法

- 例子：

```java
public class Father {
    public void say(){
        System.out.println("father");
    }
    public static void action(){
        System.out.println("爸爸打儿子！");
    }
}
public class Son extends Father{
    public void say() {
        System.out.println("son");
    }
   public static void action(){
        System.out.println("打打！");
    }
    public static void main(String[] args) {
        Father f=new Son();
        f.say();
        f.action();
    }
}
```

- 输出：son/n爸爸打儿子！
- 当调用say方法执行的是Son的方法，也就是重写的say方法。而当调用action方法时，执行的是father的方法。

#### 20.表达式`(short)10/10.2*2`运算后结果是什么类型？

- double
- 强制类型转换的优先级高于`+ - * /`，java 黙认浮点类型为double

#### 下面代码为true的是什么？

```java
Integer i = 42;
Long l = 42l;
Double d = 42.0;
```

1. (i == l)
2. (i == d)
3. (l == d)
4. i.equals(d)
5. d.equals(l)
6. i.equals(l)
7. l.equals(42L)

- 答案：7
- 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱
- 包装类的equals()方法不处理数据转型
- 不同类型引用的 == 比较，会出现编译错误
- 基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；

```java
 int a = 220;
 Integer b = 220;
 System.out.println(a==b);//true
```

-  两个Integer类型进行“==”比较， 如果其值在-128至127  ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。

```java
Integer c=3;
Integer h=3;
Integer e=321;
Integer f=321;
System.out.println(c==h);//true
System.out.println(e==f);//false
```

- 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。

```java
Integer a=1;
Integer b=2;
Integer c=3;
System.out.println(c.equals(a+b));//true
```

- 基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较

```java
int i=1;
int j = 2;
Integer c=3;
System.out.println(c.equals(i+j));//true
```