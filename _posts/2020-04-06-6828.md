---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partA(1)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-06 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# Lab3 用户环境

更新一下我们的文件，发现多了一些：

| `inc/`  | `env.h`       | Public definitions for user-mode environments                |
| ------- | ------------- | ------------------------------------------------------------ |
|         | `trap.h`      | Public definitions for trap handling                         |
|         | `syscall.h`   | Public definitions for system calls from user environments to the kernel |
|         | `lib.h`       | Public definitions for the user-mode support library         |
| `kern/` | `env.h`       | Kernel-private definitions for user-mode environments        |
|         | `env.c`       | Kernel code implementing user-mode environments              |
|         | `trap.h`      | Kernel-private trap handling definitions                     |
|         | `trap.c`      | Trap handling code                                           |
|         | `trapentry.S` | Assembly-language trap handler entry-points                  |
|         | `syscall.h`   | Kernel-private definitions for system call handling          |
|         | `syscall.c`   | System call implementation code                              |
| `lib/`  | `Makefrag`    | Makefile fragment to build user-mode library, `obj/lib/libjos.a` |
|         | `entry.S`     | Assembly-language entry-point for user environments          |
|         | `libmain.c`   | User-mode library setup code called from `entry.S`           |
|         | `syscall.c`   | User-mode system call stub functions                         |
|         | `console.c`   | User-mode implementations of `putchar` and `getchar`, providing console I/O |
|         | `exit.c`      | User-mode implementation of `exit`                           |
|         | `panic.c`     | User-mode implementation of `panic`                          |
| `user/` | `*`           | Various test programs to check kernel lab 3 code             |

## Part A: User Environments and Exception Handling

​		新文件inc/env.h包含了JOS中用户环境的基本定义。用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境，内核使用Env数据结构来跟踪每个用户环境。在这个实验室中，我们最初将只创建一个环境，但是需要设计JOS内核来支持多个环境。

​		以在kern/env.c中看到内核维护与环境相关的三个主要全局变量:

```
struct Env *envs = NULL;		// 所有env结构体
struct Env *curenv = NULL;		// 目前正在运行的用户环境
static struct Env *env_free_list;	// 还没有被使用的env结构体链表
```

​		一旦JOS启动并运行，envs指针指向一个Env结构数组，该数组表示系统中的所有环境。在我们的设计中，JOS内核将支持最多的NENV并发活动环境，尽管在任何给定时间内运行的环境通常要少得多。(NENV在inc/env.h中是一个常量#defined)一旦它被分配，envs数组将为每个NENV可能的环境包含一个Env数据结构实例。

​		JOS内核将所有不活动的Env结构保存在env_free_list中。这种设计允许轻松地分配和释放环境，因为它们只需添加到空闲列表或从空闲列表中删除即可。

​		内核使用curenv符号在任何给定时间跟踪当前执行的环境。在启动期间，在第一个环境运行之前，curenv最初设置为NULL。

### Environment State

Env结构在inc/ Env .h中定义如下：

```
struct Env {
	struct Trapframe env_tf;	// Saved registers
	struct Env *env_link;		// Next free Env
	envid_t env_id;			// Unique environment identifier
	envid_t env_parent_id;		// env_id of this env's parent
	enum EnvType env_type;		// Indicates special system environments
	unsigned env_status;		// Status of the environment
	uint32_t env_runs;		// Number of times environment has run

	// Address space
	pde_t *env_pgdir;		// Kernel virtual address of page dir
};
```

以下是Env字段的解释:

env_tf:

　　这个类型的结构体在inc/trap.h文件中被定义，里面存放着当用户环境暂停运行时，所有重要寄存器的值。内核也会在系统从用户态切换到内核态时保存这些值，这样的话用户环境可以在之后被恢复，继续执行。

env_link:

　　这个指针指向在env_free_list中，该结构体的后一个free的Env结构体。当然前提是这个结构体还没有被分配给任意一个用户环境时，该域才有用。

env_id:

　　这个值可以唯一的确定使用这个结构体的用户环境是什么。当这个用户环境终止，内核会把这个结构体分配给另外一个不同的环境，这个新的环境会有不同的env_id值。

env_parent_id:

　　创建这个用户环境的父用户环境的env_id

env_type:

　　用于区别出来某个特定的用户环境。对于大多数环境来说，它的值都是 ENV_TYPE_USER.

env_status:

　　这个变量存放以下可能的值

　　ENV_FREE: 代表这个结构体是不活跃的，应该在链表env_free_list中。

　　ENV_RUNNABLE: 代表这个结构体对应的用户环境已经就绪，等待被分配处理机。

　　ENV_RUNNING: 代表这个结构体对应的用户环境正在运行。

　　ENV_NOT_RUNNABLE: 代表这个结构体所代表的是一个活跃的用户环境，但是它不能被调度运行，因为它在等待其他环境传递给它的消息。

　　ENV_DYING: 代表这个结构体对应的是一个僵尸环境。一个僵尸环境在下一次陷入内核时会被释放回收。

env_pgdir:

　　这个变量存放着这个环境的页目录的虚拟地址

​		与Unix进程一样，JOS环境将“线程”和“地址空间”的概念结合在一起。线程主要由保存的寄存器(env_tf字段)定义，地址空间由env_pgdir指向的页目录和页表定义。要运行一个环境，内核必须使用保存的寄存器和适当的地址空间来设置CPU。

​		我们的struct Env与xv6中的struct proc类似。这两种结构都能保持环境的平衡。在Trapframe结构中的用户模式寄存器状态。在JOS，各个环境不像xv6中的进程那样拥有自己的内核堆栈。一次在内核中只能有一个活动的JOS环境，因此JOS只需要一个内核堆栈。

### Allocating the Environments Array

在lab2中，我们为pages[]数组在mem_init()中分配了内存，用于记录内核中所有页的信息。现在需要进一步修改mem_init()来分配一个类似的Env结构数组(称为envs)。

### 练习1

修改kern/pmap.c中的mem_init()来分配和映射envs数组。这个数组正好由Env结构的NENV实例组成。与页面数组一样，支持envs的内存也应该在UENVS(在inc/memlayout.h中定义)上将用户映射为只读，这样用户进程就可以从这个数组中读取数据。

用check_kern_pgdir()来检查。

我们只需要像在Lab2里面分配pages数组那样，分配一个Env数组给指针envs就可以了。

```c
// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
// LAB 3: Your code here.
envs = (struct Env*)boot_alloc(sizeof(struct Env) * NENV);
memset(envs, 0, sizeof(struct Env) * NENV);

// Map the 'envs' array read-only by the user at linear address UENVS
// (ie. perm = PTE_U | PTE_P).
// Permissions:
//    - the new image at UENVS  -- kernel R, user R
//    - envs itself -- kernel RW, user NONE
// LAB 3: Your code here.
boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);
```

### Creating and Running Environments

​		现在，我们将用kern/env.c编写运行用户环境所需的代码。因为我们还没有文件系统，所以我们将设置内核来加载嵌入在内核本身中的静态二进制映像。JOS将此二进制文件作为ELF可执行映像嵌入到内核中。

​		lab3 GNUmakefile在obj/user/目录中生成许多二进制映像。如果您查看kern/Makefrag，您会注意到一些神奇的地方，它们将这些二进制文件直接链接到内核可执行文件中，就好像它们是.o文件一样。linker命令行上的-b二进制选项导致这些文件被链接为“原始的”未解释的二进制文件，而不是编译器生成的常规.o文件。

在kern/init.c的i386_init()中，我们将看到在环境中运行这些二进制映像之一的代码。但是，建立用户环境的关键功能还不完善;我们需要把它们填上。

### 练习2

在文件 env.c中，完成下列函数：

env_init(): 初始化所有的在envs数组中的 Env结构体，并把它们加入到 env_free_list中。 还要调用 env_init_percpu，这个函数要配置段式内存管理系统，让它所管理的段，可能具有两种访问优先级其中的一种，一个是内核运行时的0优先级，以及用户运行时的3优先级。

env_setup_vm(): 为一个新的用户环境分配一个页目录表，并且初始化这个用户环境的地址空间中的和内核相关的部分。

region_alloc(): 为用户环境分配物理地址空间

load_icode(): 分析一个ELF文件，类似于boot loader做的那样，我们可以把它的内容加载到用户环境下。

env_create(): 利用env_alloc函数和load_icode函数，加载一个ELF文件到用户环境中

env_run(): 在用户模式下，开始运行一个用户环境。

**env_init():**

作用：初始化envs数组，构建env_free_list链表，遍历 envs 数组中的所有 Env 结构体，把每一个结构体的 env_id 字段置0，因为要求所有的 Env 在 env_free_list 中的顺序，要和它在 envs 中的顺序一致，所以需要采用头插法，envs[0]应该在链表头部位置。实现如下：

```c
void
env_init(void)
{
	// Set up envs array
	// LAB 3: Your code here.
	env_free_list = NULL;
	for (int i = NENV - 1; i >= 0; i--) {	//前插法构建链表
		envs[i].env_id = 0;
		envs[i].env_link = env_free_list;
		env_free_list = &envs[i];
	}

	// Per-CPU part of the initialization
	env_init_percpu();    //加载全局描述符表(GDT)
}
```

**env_setup_vm():**

初始化新的用户环境的页目录表，不过只设置页目录表中和操作系统内核跟内核相关的页目录项，用户环境的页目录项不要设置，因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址UVPT，这个也会单独进行设置），所以我们可以参照 kern_pgdir 中的内容来设置 env_pgdir 中的内容。

```c
// 初始化环境e的内核虚拟内存布局。分配一个页面目录，相应地设置e->env_pgdir，并初始化新环境地址空间的内核部分。
//不要(现在)将任何内容映射到环境的虚拟地址空间的用户部分

static int
env_setup_vm(struct Env *e)
{
	int i;
	struct PageInfo *p = NULL;

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;

	// Now, set e->env_pgdir and initialize the page directory.
	//
	// Hint:
	//    - The VA space of all envs is identical above UTOP
	//	(except at UVPT, which we've set below).
	//	See inc/memlayout.h for permissions and layout.
	//	Can you use kern_pgdir as a template?  Hint: Yes.
	//	(Make sure you got the permissions right in Lab 2.)
	//    - The initial VA below UTOP is empty.
	//    - You do not need to make any more calls to page_alloc.
	//   -注意:一般情况下，pp_ref不会对只映射在UTOP之上的物理页面进行维护，但env_pgdir是一个例外—您需要为env_free增加env_pgdir的pp_ref以使其正确工作。

	// LAB 3: Your code here.

 	p->pp_ref++;
    	e->env_pgdir = (pde_t *)page2kva(p);  //刚分配的物理页作为页目录使用
    	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);  //继承内核页目录

     	// UVPT maps the env's own page table read-only.
     	// Permissions: kernel R, user R
     	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;  //唯一需要修改的是UVPT需要映射到当前环境的页目录物理地址e->env_pgdir处，而不是内核的页目录物理地址kern_pgdir处

	return 0;
}

```

**region_alloc():**

参数：

1. struct Env *e：需要操作的用户环境
2. void *va：虚拟地址
3. size_t len：长度

作用：操作e->env_pgdir，为[va, va+len)分配物理空间。

```c
// 为环境env分配len字节的物理内存，并将其映射到环境的地址空间中的虚拟地址va。
//不为零或以其他方式以任何方式初始化映射页。
//页面应该是可写的用户和内核。
static void
region_alloc(struct Env *e, void *va, size_t len)
{
	// LAB 3: Your code here.
	// (But only if you need it for load_icode.)
	//
	// 提示:如果调用者可以传递没有页面对齐的'va'和'len'值，那么使用region_alloc会更容易。你应该把va四舍五入，把(va + len)四舍五入
	void *begin = ROUNDDOWN(va, PGSIZE), *end = ROUNDUP(va + len, PGSIZE);
    	for (; begin < end; begin += PGSIZE) {
        	struct PageInfo *p = page_alloc(0);  //分配一个物理页
        	if (!p) panic("env region_alloc failed");
        	page_insert(e->env_pgdir, p, begin, PTE_W | PTE_U);//修改e->env_pgdir，建立线性地址begin到物理页pg的映射关系
    	}   
}
```

**load_icode():**

参数：

1. struct Env *e：需要操作的用户环境
2. uint8_t *binary：可执行用户代码的起始地址

作用：加载binary地址开始处的ELF文件,为每一个用户进程设置它的初始代码区，堆栈以及处理器标识位。每个用户程序都是ELF文件，所以我们要解析该ELF文件。。

为用户进程设置初始程序二进制、堆栈和处理器标志。此函数仅在运行第一个用户模式环境之前的内核初始化期间调用。此函数从ELF二进制映像加载所有可加载段到环境的用户内存中，从ELF程序头中指定的适当虚拟地址开始。与此同时，它清除这些段的任何部分，这些部分在程序头中被标记为被映射，但实际上不存在于ELF文件中。

```c
static void
load_icode(struct Env *e, uint8_t *binary)
{
    struct Elf *env_elf;
    struct Proghdr *ph, *eph;
    env_elf = (struct Elf*)binary;
    ph = (struct Proghdr*)((uint8_t*)(env_elf) + env_elf->e_phoff);
    eph = ph + env_elf->e_phnum;

    lcr3(PADDR(e->env_pgdir));

    for (; ph < eph; ph++) {
        if(ph->p_type == ELF_PROG_LOAD) {  //只加载LOAD类型的Segment
            region_alloc(e, (void *)ph->p_va, ph->p_memsz);
            memcpy((void*)ph->p_va, (void *)(binary+ph->p_offset), ph->p_filesz);  //因为这里需要访问刚分配的内存，所以之前需要切换页目录
            memset((void*)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);  //应该有如下关系：ph->p_filesz <= ph->p_memsz。搜索BSS段
        }
    }

    e->env_tf.tf_eip = env_elf->e_entry;
    lcr3(PADDR(kern_pgdir));

    // Now map one page for the program's initial stack
    // at virtual address USTACKTOP - PGSIZE.
    region_alloc(e, (void *)(USTACKTOP-PGSIZE), PGSIZE);
}
```

**env_create():**

参数：

1. uint8_t *binary：将要加载的可执行文件的起始位置
2. enum EnvType type：用户环境类型

作用：首先调用env_alloc分配 struct Env结构以及页目录，然后调用load_icode加载进程代码。

```c
void
env_create(uint8_t *binary, enum EnvType type)
{
    struct Env *e;
    env_alloc(&e, 0);
    e->env_type = type;
    load_icode(e, binary);  //加载从binary地址开始处的ELF可执行文件到该Env结构
}
```

**env_run(struct Env \*e):**

参数：

1. struct Env *e：需要执行的用户环境

作用：在用户模式运行用户进程

```c
void
env_run(struct Env *e)
{
    // panic("env_run not yet implemented");
    if (curenv && curenv->env_status == ENV_RUNNING) {
        curenv->env_status = ENV_RUNNABLE;
    }
    curenv = e;
    curenv->env_status = ENV_RUNNING;
    curenv->env_runs++;
    lcr3(PADDR(curenv->env_pgdir));   //加载线性地址空间
    env_pop_tf(&curenv->env_tf);  //弹出env_tf结构到寄存器
}
```

下面是调用用户代码之前的代码调用图。确保你理解了每一步的目的。

start (kern/entry.S)

i386_init (kern/init.c)

　　cons_init

​    　mem_init

　　env_init

　　trap_init （目前还未实现）

　　env_create

　　env_run

　　env_pop_tf

​		一旦你完成上述子函数的代码，并且在QEMU下编译运行，系统会进入用户空间，并且开始执行hello程序，直到它做出一个系统调用指令int。但是这个系统调用指令不能成功运行，因为到目前为止，JOS还没有设置相关硬件来实现从用户态向内核态的转换功能。当CPU发现，它没有被设置成能够处理这种系统调用中断时，它会触发一个保护异常，然后发现这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，我们把这个叫做"triple fault"。通常来说，接下来CPU会复位，系统会重启。

　　所以我们马上要来解决这个问题，不过解决之前我们可以使用调试器来检查一下程序要进入用户模式时做了什么。使用make qemu-gdb 并且在 env_pop_tf 处设置断点，这条指令应该是即将进入用户模式之前的最后一条指令。然后进行单步调试，处理会在执行完 iret 指令后进入用户模式。然后依旧可以看到进入用户态后执行的第一条指令了，该指令是一个cmp指令，开始于文件 lib/entry.S 中。 现在使用 b *0x... 设置一个断点在hello文件（obj/user/hello.asm）中的sys_cputs函数中的 int $0x30 指令处。这个int指令是一个系统调用，用来展示一个字符到控制台。如果你的程序运行不到这个int指令，说明有错误。

### 处理中断和异常

到目前为止，当程序运行到第一个系统调用 int $0x30 时，就会进入错误的状态，因为现在系统无法从用户态切换到内核态。所以你需要实现一个基本的异常/系统调用处理机制，使得内核可以从用户态转换为内核态。你应该先熟悉一下X86的异常中断机制。

### Basics of Protected Control Transfer

​		异常和中断都是“受保护的控制传输”，它导致处理器从用户模式切换到内核模式(CPL=0)，而不给用户模式代码任何机会来干扰内核或其他环境的功能。在Intel的术语中，中断是受保护的控制传输，它是由通常位于处理器外部的异步事件引起的，例如外部设备I/O活动的通知。相反，一个例外是当前运行的代码同步地引起的受保护的控制传输，例如由于除0或无效的内存访问。

​		为了确保这些受保护的控制传输实际上是受保护的，处理器的中断/异常机制被设计成当中断或异常发生时，当前运行的代码不会随意选择内核的输入位置或方式。相反，处理器确保只能在严格控制的条件下输入内核。在x86上，有两种机制共同提供这种保护:

1. **中断描述符表**。处理器确保中断和异常只能在内核本身确定的几个特定的、定义良好的入口点上输入内核，而不能由在中断或异常发生时运行的代码来输入。

   x86允许内核中最多256个不同的中断或异常入口点，每个都有不同的中断向量。向量是0到255之间的数字。中断的向量是由中断的源决定的:不同的设备、错误条件和对内核的应用程序请求用不同的向量产生中断。CPU使用这个向量作为到处理器的中断描述符表(IDT)的索引，内核将IDT设置在内核专用内存中，非常类似于GDT。从该表中适当的条目，处理器加载:

   - 加载到指令指针(EIP)寄存器的值，指向指定处理该类型异常的内核代码。
   - 要加载到代码段(CS)寄存器中的值，该寄存器以0-1位的形式包含要运行异常处理程序的特权级别。(在JOS，所有异常都在内核模式下处理，特权级别为0。)

2. **任务状态段** 

   处理器需要一个地方保存旧处理器中断或异常发生前的状态,如EIP的原始值和CS在处理器调用异常处理程序之前,所以老状态的异常处理程序可以稍后恢复和恢复中断的代码从那里离开。但这对旧处理器状态保存区反过来必须免受未经授权的用户模式代码;否则，有bug或恶意的用户代码可能危及内核。

   因此，当x86处理器发生中断或陷阱，导致从用户到内核模式的权限级别发生变化时，它还会切换到内核内存中的堆栈。称为任务状态段(TSS)的结构指定该堆栈所在的段选择器和地址。处理器(在这个新堆栈上)推送SS、ESP、EFLAGS、CS、EIP和一个可选的错误代码。然后从中断描述符中加载CS和EIP，并设置ESP和SS以引用新堆栈。

   尽管TSS很大，并且可能有多种用途，但是JOS只使用它来定义处理器从用户模式转换到内核模式时应该切换到的内核堆栈。由于JOS中的“内核模式”是x86上的特权级别0，所以在进入内核模式时，处理器使用TSS的ESP0和SS0字段来定义内核堆栈。JOS不使用任何其他TSS字段。

### 异常和中断的类型

​		x86处理器可以在内部生成的所有同步异常都使用0到31之间的中断向量，因此映射到IDT条目0-31。例如，页面错误总是通过vector 14导致异常。大于31的中断向量仅用于软件中断，软件中断可由int指令生成，或外部设备在需要注意时引起的异步硬件中断。

​		在本节中，我们将扩展JOS来处理0-31向量中内部生成的x86异常。在下一节中，我们将让JOS处理软件中断向量48 (0x30)，它是JOS(相当随意地)使用的系统调用中断向量。在实验室4中，我们将扩展JOS来处理外部产生的硬件中断，如时钟中断。

#### 一个例子

​		让我们将这些片段放在一起，并通过一个示例进行跟踪。假设处理器在用户环境中执行代码，遇到一条试图除0的divide指令。

1. 处理器切换到由TSS的SS0和ESP0字段定义的堆栈，在JOS中，这两个字段分别包含GD_KD和KSTACKTOP值。

2. 处理器将异常参数推入内核堆栈，从地址KSTACKTOP开始:

   ```
    +--------------------+ KSTACKTOP             
                        | 0x00000 | old SS   |     " - 4
                        |      old ESP       |     " - 8
                        |     old EFLAGS     |     " - 12
                        | 0x00000 | old CS   |     " - 16
                        |      old EIP       |     " - 20 <---- ESP 
                        +--------------------+             
   ```

3. 因为我们正在处理一个分割错误，也就是x86上的中断向量0，所以处理器读取IDT条目0并设置CS:EIP来指向条目所描述的处理函数。

4. 处理程序函数接受控制并处理异常，例如通过终止用户环境。

对于某些类型的x86异常，除了上面的“标准”之外，处理器还会将另一个包含错误代码的字推到堆栈上。页面错误异常(编号14)是一个重要的示例。请参阅80386手册，以确定处理器为哪个异常号推送错误代码，以及在这种情况下错误代码的含义。当处理器推送错误代码时，从用户模式进入异常处理程序时，堆栈将如下图所示:

```
  +--------------------+ KSTACKTOP             
                     | 0x00000 | old SS   |     " - 4
                     |      old ESP       |     " - 8
                     |     old EFLAGS     |     " - 12
                     | 0x00000 | old CS   |     " - 16
                     |      old EIP       |     " - 20
                     |     error code     |     " - 24 <---- ESP
                     +--------------------+             
```

### 嵌套异常和中断

​		处理器可以从内核和用户模式获取异常和中断。但是，只有在从用户模式进入内核时，x86处理器才会在将旧的寄存器状态推入堆栈并通过IDT调用适当的异常处理程序之前自动切换堆栈。如果在发生中断或异常时处理器已经处于内核模式(CS寄存器的低2位已经为零)，那么CPU只是在相同的内核堆栈上推送更多的值。通过这种方式，内核可以优雅地处理由类中的代码引起的嵌套异常。

​		如果处理器已经处于内核模式并接受嵌套异常，因为它不需要切换堆栈，所以它不会保存旧的SS或ESP寄存器。对于不推送错误代码的异常类型，内核堆栈因此在异常处理程序的入口看起来像下面这样:

```
   +--------------------+ <---- old ESP
                     |     old EFLAGS     |     " - 4
                     | 0x00000 | old CS   |     " - 8
                     |      old EIP       |     " - 12
                     +--------------------+             
```

​		对于推送错误代码的异常类型，处理器会像以前一样，在旧的EIP之后立即推送错误代码。

​		对于处理器的嵌套异常功能有一个重要的警告。如果处理器在已经处于内核模式时发生异常，并且由于缺乏堆栈空间等原因无法将其旧状态推入内核堆栈，那么处理器就无法进行任何恢复，因此它只能重置自己。不用说，内核的设计应该避免这种情况的发生。

### 设置IDT

​		现在我们应该拥有了设置IDT和处理JOS中的异常所需的基本信息。现在，我们将设置IDT来处理中断向量0-31(处理器异常)。我们将在稍后的实验室中处理系统调用中断，并在稍后的实验室中添加32-47中断(设备IRQs)。

​		头文件inc/trap.h和kern/trap.h包含与中断和异常相关的重要定义，我们需要熟悉这些定义。文件kern/trap.h包含对内核严格私有的定义，而inc/trap.h包含对用户级程序和库可能也有用的定义。

​		注意:0-31范围内的一些异常由Intel定义并保留。因为它们永远不会由处理器生成，所以如何处理它们并不重要。

​		整体控制流程如下:

```
      IDT                   trapentry.S         trap.c
   
+----------------+                        
|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)
|                |             // do stuff      {
|                |             call trap          // handle the exception/interrupt
|                |             // ...           }
+----------------+
|   &handler2    |--------> handler2:
|                |            // do stuff
|                |            call trap
|                |            // ...
+----------------+
       .
       .
       .
+----------------+
|   &handlerX    |--------> handlerX:
|                |             // do stuff
|                |             call trap
|                |             // ...
+----------------+
```

​		每个异常或中断在trapentry.S和trap_init()中都应该有自己的处理程序。应该使用这些处理程序的地址初始化IDT。每个处理程序都应该在堆栈上构建一个struct Trapframe(参见inc/trap.h)，并使用指向Trapframe的指针调用trap()(在trap.c中)。然后，trap()处理异常/中断或分派到特定的处理程序函数。

#### 练习4

编辑trapentry.S和inc/trap.h并实现上述功能。宏TRAPHANDLER和TRAPHANDLER_NOEC在trapentry.S中。我们需要在trapentry中添加一个入口点。为inc/trap中定义的每个陷阱(使用那些宏)。我们必须提供TRAPHANDLER宏所引用的_alltraps。还需要修改trap_init()来初始化idt，使其指向trapentre . s中定义的每个入口点;SETGATE宏在这里会有帮助。

_alltraps应该:

1. 把值压入堆栈使堆栈看起来像一个结构体 Trapframe

 2. 加载 GD_KD 的值到 %ds, %es寄存器中

 3. 把%esp的值压入，并且传递一个指向Trapframe的指针到trap()函数中。

 4. 调用trap

考虑使用pushal指令，它会很好的和结构体 Trapframe 的布局配合好。

trapentry.S的代码为：

```c
/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
//使用TRAPHANDLER和TRAPHANDLER_NOEC宏创建0~16号中断的中断处理函数。TRAPHANDLER和TRAPHANDLER_NOEC创建的函数都会跳转到_alltraps处
TRAPHANDLER_NOEC(handler0, T_DIVIDE)
TRAPHANDLER_NOEC(handler1, T_DEBUG)
TRAPHANDLER_NOEC(handler2, T_NMI)
TRAPHANDLER_NOEC(handler3, T_BRKPT)
TRAPHANDLER_NOEC(handler4, T_OFLOW)
TRAPHANDLER_NOEC(handler5, T_BOUND)
TRAPHANDLER_NOEC(handler6, T_ILLOP)
TRAPHANDLER(handler7, T_DEVICE)
TRAPHANDLER_NOEC(handler8, T_DBLFLT)
TRAPHANDLER(handler10, T_TSS)
TRAPHANDLER(handler11, T_SEGNP)
TRAPHANDLER(handler12, T_STACK)
TRAPHANDLER(handler13, T_GPFLT)
TRAPHANDLER(handler14, T_PGFLT)
TRAPHANDLER_NOEC(handler16, T_FPERR)
TRAPHANDLER_NOEC(handler48, T_SYSCALL)

/*
 * Lab 3: Your code here for _alltraps
 */
    //参考inc/trap.h中的Trapframe结构。tf_ss，tf_esp，tf_eflags，tf_cs，tf_eip，tf_err在中断发生时由处理器压入，所以现在只需要压入剩下寄存器（%ds,%es,通用寄存器）
	//切换到内核数据段
_alltraps:
        pushl %ds 
        pushl %es 
        pushal
        movw $GD_KD, %ax
        movw %ax, %ds 
        movw %ax, %es 
        pushl %esp
        call trap /*never return*/
```

trap_init()函数中将会对系统的IDT表进行初始化设置,代码为：

```c
void
trap_init(void)
{
    extern struct Segdesc gdt[];

    // LAB 3: Your code here.
    void handler0();
    void handler1();
    void handler2();
    void handler3();
    void handler4();
    void handler5();
    void handler6();
    void handler7();
    void handler8();
    void handler10();
    void handler11();
    void handler12();
    void handler13();
    void handler14();
    void handler15();
    void handler16();
    void handler48();

    SETGATE(idt[T_DIVIDE], 0, GD_KT, handler0, 0); 
    SETGATE(idt[T_DEBUG], 0, GD_KT, handler1, 0); 
    SETGATE(idt[T_NMI], 0, GD_KT, handler2, 0); 

    // T_BRKPT DPL 3
    SETGATE(idt[T_BRKPT], 0, GD_KT, handler3, 3); 

    SETGATE(idt[T_OFLOW], 0, GD_KT, handler4, 0); 
    SETGATE(idt[T_BOUND], 0, GD_KT, handler5, 0); 
    SETGATE(idt[T_ILLOP], 0, GD_KT, handler6, 0); 
    SETGATE(idt[T_DEVICE], 0, GD_KT, handler7, 0); 
    SETGATE(idt[T_DBLFLT], 0, GD_KT, handler8, 0); 
    SETGATE(idt[T_TSS], 0, GD_KT, handler10, 0); 
    SETGATE(idt[T_SEGNP], 0, GD_KT, handler11, 0); 
    SETGATE(idt[T_STACK], 0, GD_KT, handler12, 0); 
    SETGATE(idt[T_GPFLT], 0, GD_KT, handler13, 0); 
    SETGATE(idt[T_PGFLT], 0, GD_KT, handler14, 0); 
    SETGATE(idt[T_FPERR], 0, GD_KT, handler16, 0); 

    // T_SYSCALL DPL 3
    SETGATE(idt[T_SYSCALL], 0, GD_KT, handler48, 3); 

    // Per-CPU setup 
    trap_init_percpu();
}
```

make一下通过了

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdmm9jjcypj30gd054q3b.jpg)

# partB 页面错误、断点异常和系统调用

### 处理页面错误

​		页面错误异常，中断向量14 (T_PGFLT)，是一个特别重要的异常，我们将在这个实验和下一个实验中大量使用它。当处理器出现页面错误时，它会存储线性地址即在一个特殊的处理器控制寄存器CR2中引起错误的地址。在trap.c中，我们提供了一个特殊函数page_fault_handler()的开头，用于处理页面错误异常。

#### 练习5

修改一下 trap_dispatch 函数，使系统能够把缺页异常引导到 page_fault_handler() 上执行。在修改完成后，运行 make grade，出现的结果应该是你修改后的 JOS 可以成功运行 faultread，faultreadkernel，faultwrite，faultwritekernel 测试程序。

Trapframe 中的 tf_trapno 成员代表这个中断的中断码。我们判断这个中断是否是缺页中断：

```c
static void
trap_dispatch(struct Trapframe *tf)
{
    // Handle processor exceptions.
    // LAB 3: Your code here.
    if (tf->tf_trapno == T_PGFLT) {
        return page_fault_handler(tf);
    }   

    // Unexpected trap: The user process or the kernel has a bug.
    print_trapframe(tf);
    if (tf->tf_cs == GD_KT)
        panic("unhandled trap in kernel");
    else {
        env_destroy(curenv);
        return;
    }   
}
```

### 断点异常

​		断点异常，中断向量3 (T_BRKPT)，通常被用来允许调试器通过临时用特殊的1字节int3软件中断指令替换相关的程序指令来在程序代码中插入断点。在JOS中，我们将略微滥用这个异常，将它转换成一个原始的伪系统调用，任何用户环境都可以使用它来调用JOS内核监视器。如果我们将JOS内核监视器看作原始调试器，那么这种用法实际上是适当的。lib/panic中的panic()的用户模式实现。例如，c在显示其panic消息后执行int3。

### 练习6

修改trap_dispatch()以使断点异常调用内核监视器。您现在应该能够在断点测试中获得成功。

判断中断是否为断点中断 (T_BRKPT)，然后调用monitor.c中的内核监视器。

```c
if (tf->tf_trapno == T_BRKPT) {
	return monitor(tf);
}   
```

### 系统调用

​		用户进程通过调用系统调用来请求内核为它们做一些事情。当用户进程调用系统调用时，处理器进入内核模式，处理器和内核协同保存用户进程的状态，内核执行适当的代码来执行系统调用，然后恢复用户进程。用户进程如何获得内核的注意，以及它如何指定希望执行哪个调用的具体细节因系统而异。

​		在JOS内核中，我们将使用int指令，这将导致处理器中断。特别是，我们将使用int $0x30作为系统调用中断。我们已经为您定义了常数T_SYSCALL为48 (0x30)。您必须设置中断描述符，以允许用户进程引起中断。注意，硬件不能生成0x30中断，所以允许用户代码生成它不会造成歧义。

​		应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中进行查找。系统调用号将在%eax中，参数(最多5个)将分别在%edx、%ecx、%ebx、%edi和%esi中。内核将返回值传回%eax。已经在lib/syscall.c的syscall()中为您编写了调用系统调用的汇编代码。

### 练习7

给中断向量T_SYSCALL编写一个中断处理函数。你需要去编辑kern/trapentry.S和kern/trap.c中的trap_init()函数。你也需要去修改trap_dispatch()函数，使他能够通过调用syscall()（在kern/syscall.c中定义的）函数处理系统调用中断。最终你需要去实现kern/syscall.c中的syscall()函数。确保这个函数会在系统调用号为非法值时返回-E_INVAL。你应该充分理解lib/syscall.c文件。我们要处理在inc/syscall.h文件中定义的所有系统调用。

在内核下运行user/hello程序。它应该在控制台中打印“hello, world”，然后在用户模式中导致页面错误。

内核态的系统调用：此时调用了一个系统调用，比如 sys_cputs 函数时，此时不会触发中断，那么系统会直接执行定义在 lib/syscall.c 文件中的 sys_cputs，我们可以看一下这个文件，可以发现这个文件中定义了几个比较常用的系统调用，包括 sys_cputs, sys_cgetc 等等。我们还会发现他们都是统一调用一个 syscall 函数，通过这个函数的代码发现其实它是执行了一个汇编指令。所以最终是这个函数完成了系统调用。

而我们要实现的，是用户态的系统调用，首先有一个软中断，所以我们要编写一个中断处理函数，在kern/trapentry.S中声明它：

`TRAPHANDLER_NOEC(handler48, T_SYSCALL)` 

然后在trap.c中声明声，门的DPL定义为3：

`SETGATE(idt[T_SYSCALL], 0, GD_KT, handler48, 3); `

当系统发生调用中断时，就可以捕捉到这个中断，然后调用_alltraps代码块，来到trap()函数然后进入trap_dispatch函数，在这个函数中，我们要实现对syscall的调用。

在trap_dispatch()中判断中断号如果是T_SYSCALL，调用定义在kern/syscall.c中的syscall()函数，并将syscall()保存的返回值保存到tf->tf_regs.reg_eax等将来恢复到eax寄存器中。

```c
static void
trap_dispatch(struct Trapframe *tf)
{
	// Handle processor exceptions.
	// LAB 3: Your code here.
	if (tf->tf_trapno == T_PGFLT) {
        	return page_fault_handler(tf);
    	}   

    	if (tf->tf_trapno == T_BRKPT) {
        	return monitor(tf);
    	}   
	if (tf->tf_trapno == T_SYSCALL) {  //如果是系统调用，从寄存器中取出系统调用号和五个参数，传给kern/syscall.c中的syscall()，并将返回值保存到tf->tf_regs.reg_eax
        	tf->tf_regs.reg_eax = syscall(
            		tf->tf_regs.reg_eax,
            		tf->tf_regs.reg_edx,
            		tf->tf_regs.reg_ecx,
            		tf->tf_regs.reg_ebx,
            		tf->tf_regs.reg_edi,
            		tf->tf_regs.reg_esi
        	);  
        	return;
 	}   
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
	if (tf->tf_cs == GD_KT)
		panic("unhandled trap in kernel");
	else {
		env_destroy(curenv);
		return;
	}
}
   
```

修改kern/syscall.c中的syscall()函数，使能处理定义在inc/syscall.h中的所有系统调用。

```c
int32_t
syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.
	
	panic("syscall not implemented");
	switch (syscallno) {
    		case SYS_cputs:
        		sys_cputs((char *)a1, a2);
        		return 0;
    		case SYS_cgetc:
        		return sys_cgetc();
    		case SYS_getenvid:
        		return sys_getenvid();
    		case SYS_env_destroy:
        		return sys_env_destroy(a1);
    		default:
        		return -E_INVAL;
    		}
	
}
```

现在回顾一下系统调用的完成流程：以user/hello.c为例，其中调用了cprintf()，注意这是lib/print.c中的cprintf，该cprintf()最终会调用lib/syscall.c中的sys_cputs()，sys_cputs()又会调用lib/syscall.c中的syscall()，该函数将系统调用号放入%eax寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令int 0x30，发生中断后，去IDT中查找中断处理函数，最终会走到kern/trap.c的trap_dispatch()中，我们根据中断号0x30，又会调用kern/syscall.c中的syscall()函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用kern/print.c中的cprintf()函数，该函数最终调用kern/console.c中的cputchar()将字符串打印到控制台。当trap_dispatch()返回后，trap()会调用`env_run(curenv);`，该函数前面讲过，会将curenv->env_tf结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。

### 用户模式启动

用户程序在lib/entry.S的顶部开始运行。经过一些设置之后，这段代码调用lib/libmain.c中的libmain()。我们修改libmain()来初始化全局指针thisenv，使其指向envs[]数组中的环境结构Env。

然后，libmain()调用umain，在hello程序中，它位于user/hello.c中。注意，在打印“hello, world”之后，它尝试访问thisenv->env_id。这就是它之前出现故障的原因。已经正确地初始化了thisenv，它应该不会出错。如果它仍然出错，可能还没有映射UENVS区域的用户可读部分(回到pmap.c的A部分;这是我们第一次真正使用UENVS区域)。

### 练习8

将所需的代码添加到用户库中，然后引导内核。你应该看到user/hello打印“hello, world”，然后打印“i am environment 00001000”。然后，用户/hello尝试通过调用sys_env_destroy()来“退出”(参见lib/libmain.c和lib/exit.c)。因为内核目前只支持一个用户环境，所以它应该报告它已经破坏了唯一的环境，然后放入内核监视器。

`thisenv = &envs[ENVX(sys_getenvid())];`

然后我们重新make一下：

```
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
Incoming TRAP frame at 0xefffffbc
hello, world
Incoming TRAP frame at 0xefffffbc
i am environment 00001000
Incoming TRAP frame at 0xefffffbc
[00001000] exiting gracefully
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
Welcome to the JOS kernel monitor!
```

得到user_hello的输出

### 页面错误和内存保护

​		内存保护是操作系统的一个重要特性，可以确保一个程序中的错误不会破坏其他程序或破坏操作系统本身。

​		操作系统通常依赖于硬件支持来实现内存保护。操作系统让硬件知道哪些虚拟地址是有效的，哪些不是。当一个程序试图访问一个无效地址或一个它没有权限的地址时，处理器会在导致错误的指令处停止程序，然后将有关尝试操作的信息捕获到内核中。如果错误是可修复的，内核可以修复它并让程序继续运行。如果错误不可修复，则程序无法继续，因为它将永远无法通过导致错误的指令。

​		作为一个可修复错误的示例，考虑一个自动扩展堆栈。在许多系统中，内核最初分配一个堆栈页面，然后如果程序错误地访问了堆栈下面的页面，内核将自动分配这些页面，并让程序继续运行。通过这样做，内核只分配程序需要的堆栈内存，但是程序可以在拥有任意大的堆栈的假象下工作。

​		系统调用为内存保护带来了一个有趣的问题。大多数系统调用接口允许用户程序向内核传递指针。这些指针指向要读写的用户缓冲区。然后内核在执行系统调用时取消对这些指针的引用。这里有两个问题:

1. 内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核页面在操作自己的数据结构时出错，这就是内核错误，而错误处理程序应该使内核(以及整个系统)感到恐慌。但是，当内核取消引用用户程序给它的指针时，它需要一种方法来记住，这些取消引用导致的任何页面错误实际上都是代表用户程序的。
2. 内核通常比用户程序拥有更多的内存权限。用户程序可能会传递一个指向系统调用的指针，该系统调用指向内核可以读写但程序不能读写的内存。内核必须小心，不要被欺骗而取消对这样一个指针的引用，因为那样可能会暴露私有信息或破坏内核的完整性。

由于这两个原因，内核在处理用户程序提供的指针时必须非常小心。

​		现在，我们将使用一个机制来解决这两个问题，该机制检查从用户空间传递到内核的所有指针。当程序向内核传递一个指针时，内核将检查地址是否在地址空间的用户部分，并且页表将允许内存操作。

​		因此，内核将永远不会因为取消对用户提供的指针的引用而出现页面错误。如果内核发生了页面错误，那么它应该会终止。

### 练习9

修改kern/trap.c文件，使其能够实现：当在内核模式下发现页错，trap.c 文件会panic。

提示：

为了能够判断这个page fault是出现在内核模式下还是用户模式下，我们应该检查 tf_cs 的低几位。

阅读 user_mem_assert （在 kern/pmap.c），并且实现 user_mem_check;

修改一下 kern/syscall.c 去检查输入参数。

启动内核后，运行 user/buggyhello 程序，用户环境可以被销毁，内核不可以panic，你应该看到：

[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!

最后，将kern/kdebug.c中的debuginfo_eip更改为在usd、stabs和stabstr上调用user_mem_check。如果现在运行user/breakpoint，我们应该能够从内核监视器运行回溯，并在内核出现页面错误之前看到回溯遍历到lib/libmain.c。

题目要求我们要能够判断page fault是出现在内核模式还是用户模式，检查tf_cs的低几位，代码如下：

```c
void
page_fault_handler(struct Trapframe *tf)
{
	uint32_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if ((tf->tf_cs & 3) == 0) {    //根据 CS 段寄存器的低2位，这两位的名称叫做 CPL 位，表示当前运行的代码的访问权限级别，0代表是内核态，3代表是用户态。
        	panic("kernel page fault at:%x\n", fault_va);
    	}   
	// We've already handled kernel-mode exceptions, so if we get here,
	// the page fault happened in user mode.

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
		curenv->env_id, fault_va, tf->tf_eip);
	print_trapframe(tf);
	env_destroy(curenv);
}
```

user_mem_check 函数的功能是检查一下当前用户态程序是否有对虚拟地址空间 [va, va+len] 的 perm| PTE_P 访问权限。

我们要先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项，然后再去看一下这个页表项中有关访问权限的字段，是否包含 perm | PTE_P，只要有一个页表项是不包含的，就代表程序对这个范围的虚拟地址没有 perm|PTE_P 的访问权限。

```c
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
    uint32_t begin = (uint32_t)ROUNDDOWN(va, PGSIZE), end = (uint32_t)ROUNDUP(va + len, PGSIZE);
    int check_perm = (perm | PTE_P);
    uint32_t check_va = (uint32_t)va;

    for (; begin < end; begin += PGSIZE) {
        pte_t *pte = pgdir_walk(env->env_pgdir, (void *)begin, 0);
        if ((begin >= ULIM) || !pte || (*pte & check_perm) != check_perm) {  //具体检测规则
            user_mem_check_addr = (begin >= check_va ? begin : check_va);  //记录无效的那个线性地址
            return -E_FAULT;
        }    
    }    

    return 0;
}
```

我们还要补全 kern/syscall.c 文件中的一部分内容，即 sys_cputs 函数，这个函数要求检查用户程序对虚拟地指空间 [s, s+len] 是否有访问权限，所以我们恰好可以使用刚刚写好的函数 user_mem_assert() 来实现。

```c
static void
sys_cputs(const char *s, size_t len)
{
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, s, len, 0);
	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
}
```

完成代码之后：

```
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
Incoming TRAP frame at 0xefffffbc
hello, world
Incoming TRAP frame at 0xefffffbc
i am environment 00001000
Incoming TRAP frame at 0xefffffbc
[00001000] exiting gracefully
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
```

这也是练习10的输出。

#Lab 4: Preemptive Multitasking

在这个实验中，我们将在多个同时活动的用户模式环境中实现先发制人的多任务处理。

在第A部分中，我们将向jos添加多处理器支持、实现循环调度并添加基本的环境管理系统调用(创建和破坏环境的调用以及分配/映射内存的调用)。

在第B部分中，我们将实现一个类unix的fork()，它允许用户模式环境创建自身的副本。

最后，在第C部分中，我们将添加对进程间通信(IPC)的支持，允许不同的用户模式环境显式地相互通信和同步。我们还将添加对硬件时钟中断和抢占的支持。

在切换分支时，我遇到了一个问题：

```
s-seven@sseven-virtual-machine:~/lab$ git pull
error: 您尚未结束您的合并（存在 MERGE_HEAD）。
提示：请在合并前先提交您的修改。
fatal: 因为存在未完成的合并而退出。
```

搜索相关问题后输入`rm .git/MERGE_HEAD`解决这个

```
git checkout -b lab4 origin/lab4
error: 您对下列文件的本地修改将被检出操作覆盖：
	kern/env.c
	kern/pmap.c
	kern/syscall.c
	kern/trap.c
	kern/trapentry.S
	lib/printfmt.c
请在切换分支前提交或贮藏您的修改。
终止中
```

原来我这些没有提交，

```
s-seven@sseven-virtual-machine:~/lab$ git stash
保存工作目录和索引状态 WIP on lab3: a9d7717 Lab 3
```

保存一下就好了

悲伤的是，微博图床不能用了。。。

然后发现多了下面的内容：

| `kern/cpu.h`      | Kernel-private definitions for multiprocessor support        |
| ----------------- | ------------------------------------------------------------ |
| `kern/mpconfig.c` | Code to read the multiprocessor configuration                |
| `kern/lapic.c`    | Kernel code driving the local APIC unit in each processor    |
| `kern/mpentry.S`  | Assembly-language entry code for non-boot CPUs               |
| `kern/spinlock.h` | Kernel-private definitions for spin locks, including the big kernel lock |
| `kern/spinlock.c` | Kernel code implementing spin locks                          |
| `kern/sched.c`    | Code skeleton of the scheduler that you are about to implement |

## Part A: 多处理器支持和多任务协作

​		在本实验的第一部分中，我们将首先扩展JOS，使其在多处理器系统上运行，然后实现一些新的JOS内核系统调用，以允许用户级环境创建额外的新环境。我们还将实现协作循环调度，允许内核在当前环境自动放弃CPU(或退出)时从一个环境切换到另一个环境。在C部分的后面部分，您将实现抢占式调度，它允许内核在经过一段时间之后，即使环境不合作，也可以从环境中重新获得对CPU的控制。

### Multiprocessor Support

​		我们将使JOS支持“对称多处理”(SMP)，这是一种多处理器模型，其中所有cpu都可以对系统资源(如内存和I/O总线)进行等效访问。虽然SMP中的所有cpu在功能上都是相同的，但在引导过程中它们可以分为两种类型:引导处理器(bootstrap processor, BSP)负责初始化系统和引导操作系统;只有在操作系统启动并运行之后，BSP才会激活应用程序处理器(APs)。哪个处理器是BSP是由硬件和BIOS决定的。到目前为止，您所有现有的JOS代码都是在BSP上运行的。

​		在SMP系统中，每个CPU都有一个相应的本地APIC (LAPIC)单元。LAPIC单位负责在整个系统中提供中断。LAPIC还为其连接的CPU提供唯一的标识符。在本实验室，我们利用了LAPIC单元的以下基本功能(以kern/ LAPIC .c表示):

- 读取LAPIC标识符(APIC ID)来告诉我们的代码当前在哪个CPU上运行(参见cpunum())。

- 将启动处理器间中断(IPI)从BSP发送到APs以打开其他cpu(参见lapic_startap())。

- 在第C部分中，我们对LAPIC的内置计时器进行编程，以触发时钟中断来支持先发制人的多任务处理(参见apic_init())。

处理器使用内存映射I/O (MMIO)访问它的LAPIC。在MMIO中，物理内存的一部分被硬连接到一些I/O设备的寄存器，因此通常用于访问内存的加载/存储指令也可以用于访问设备寄存器。我们已经看到了物理地址0xA0000处的一个IO漏洞(我们使用它来写入VGA显示缓冲区)。LAPIC位于一个从物理地址0xFE000000开始的洞中(32MB短于4GB)，因此对于我们使用通常的KERNBASE直接映射访问它太高了。JOS虚拟内存映射在MMIOBASE留下了4MB的空白，所以我们有地方来映射这样的设备。由于后来的实验引入了更多的MMIO区域，我们将编写一个简单的函数来从这个区域分配空间并将设备内存映射到它。

### 练习1

在kern/pmap.c中实现mmio_map_region。要了解如何使用它，请查看kern/lapic.c中lapic_init的开头。在运行mmio_map_region测试之前，您还必须进行下一个练习。

所以我们先看一看kern/lapic.c中的lapic_init（）：

```c
void
lapic_init(void)
{
	if (!lapicaddr)
		return;

	// lapicaddr是LAPIC的4K MMIO区域的物理地址。将它映射到虚拟内存中，以便我们可以访问它。
	lapic = mmio_map_region(lapicaddr, 4096);

	// APIC;设置伪中断向量。
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));

	// 定时器从lapic[TICR]开始以总线频率重复地倒数，然后发出一个中断。如果我们更关心精确的计时，TICR将使用外部时间源进行校准。
	lapicw(TDCR, X1);
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
	lapicw(TICR, 10000000); 

	// 让BSP的LINT0处于启用状态，这样它就可以从8259A芯片获得中断。
	// 根据Intel MP规范，BIOS应该在虚拟线模式下初始化BSP的本地APIC，其中8259A的INTR实际上连接到BSP的LINTIN0。在这种模式下，我们不需要对IOAPIC进行编程。
	if (thiscpu != bootcpu)
		lapicw(LINT0, MASKED);

	// 在所有cpu上禁用NMI (LINT1)
	lapicw(LINT1, MASKED);

	// 在提供中断项的计算机上禁用性能计数器溢出中断。
	if (((lapic[VER]>>16) & 0xFF) >= 4)
		lapicw(PCINT, MASKED);

	// 将错误中断映射到IRQ_ERROR。
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);

	// 清除错误状态寄存器(需要连续写操作)。
	lapicw(ESR, 0);
	lapicw(ESR, 0);

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
	lapicw(ICRLO, BCAST | INIT | LEVEL);
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
```

mmio_map_region实现了分配空间并映射设备内存。

在lapic_init的开始，调用了mmio_map_region(lapicaddr, 4096)映射了4k的MMIO区域的物理空间到内存，然后我们实现这个函数，参考boot_map_region：

```c
void *
mmio_map_region(physaddr_t pa, size_t size)
{
	// 从哪里开始下一个区域。最初，这是MMIO区域的开始。因为它是静态的，所以在调用mmio_map_region之间会保留它的值(就像boot_alloc中的nextfree一样)。
	static uintptr_t base = MMIOBASE;

	// 保留从基址开始的虚拟内存大小字节，并将物理页[pa,pa+size]映射到虚拟地址[base,base+size]。因为这是设备内存而不是普通的DRAM，你必须告诉CPU缓存访问这个内存是不安全的。幸运的是，页表为此提供了位;除了PTE_W之外，只需使用PTE_PCD|PTE_PWT (cache-disable和write-through)创建映射
	// 确保将size四舍五入为PGSIZE的倍数，并处理该保留是否会溢出MMIOLIM。
	size_t begin = ROUNDDOWN(pa, PGSIZE), end = ROUNDUP(pa + size, PGSIZE);
    size_t map_size = end - begin;
    if (base + map_size >= MMIOLIM) {
        panic("overflow MMIOLIM");
    }    
    boot_map_region(kern_pgdir, base, map_size, pa, PTE_PCD|PTE_PWT|PTE_W);
    uintptr_t result = base;
    base += map_size;
    return (void *)result;
}
```

我们现在还不能进行测试，要做完下一个练习才行。

###Application Processor Bootstrap

​		在启动APs之前，BSP应该首先收集关于多处理器系统的信息，例如cpu的总数、它们的APIC id和LAPIC单元的MMIO地址。kern/mpconfig.c中的mp_init()函数通过读取驻留在BIOS内存区域中的MP配置表来检索这些信息。

​		boot_aps()函数(在kern/init.c中)驱动AP引导进程。APs以实际模式启动，与boot/boot.S中的bootloader启动方式非常相似。因此，boot_aps()将AP条目代码(kern/mpentry.S)复制到一个在实际模式中可寻址的内存位置。与引导加载程序不同，我们可以控制AP从哪里开始执行代码;我们将条目代码复制到0x7000 (MPENTRY_PADDR)，但是任何未使用的、页面对齐的物理地址低于640KB都可以工作。

​		在此之后，boot_aps()将启动后的IPIs发送到相应AP的LAPIC单元，并将初始CS:IP地址(在我们的示例中，AP应该在这个地址上开始运行其条目代码(MPENTRY_PADDR)，从而逐个激活AP。输入码在kern/mpentry。S与boot/boot.S非常相似。经过一些简单的设置之后，它将AP置于启用分页的保护模式，然后调用C设置例程mp_main()(也在kern/init.c中)。boot_aps()等待AP在其结构CpuInfo的cpu_status字段中发出CPU_STARTED标志的信号，然后继续唤醒下一个标记。

### 练习2

在kern/init中读取boot_aps()和mp_main()。和汇编代码的kern/mpentry.S。确保您了解在APs引导期间的控制流传输。然后在kern/pmap.c中修改page_init()的实现，以避免将MPENTRY_PADDR页面添加到空闲列表中，这样我们就可以安全地复制并运行该物理地址上的AP引导代码。

```
void
page_init(void)
{
	...
	    for (i = 1; i < npages_basemem; i++) {
		if (i == PGNUM(MPENTRY_PADDR)) continue;  //在这里检测MPENTRY_PADDR
        	pages[i].pp_ref = 0;
        	pages[i].pp_link = page_free_list;
        	page_free_list = &pages[i];
    	}
    ...
}
```

后面测试的时候发现昨天在切换lab4分支的时候，并没有将lab3的内容合并过来，所以很多函数该补全的内容都没有，返回分支3发现前面的内容没了，还好昨天把虚拟机快照了一下，恢复快照之后把lab3的内容重新提交，合并的时候提示有冲突（感觉哪里怪怪的），发现多了几个====和<<<<<，我就直接把这几行删了。然后重新提交：

[![Gvr7Of.jpg](https://s1.ax1x.com/2020/04/13/Gvr7Of.jpg)](https://imgchr.com/i/Gvr7Of)

提示有一个崩溃，找一下这一行发现是check_kern_pgdir(void)这个函数的，也就是题目说的那个，所以不管。

（我的微博图床bug找到了，提示错误码-5是因为账号异常，好像是太久不用微博被黑了，sad，申诉中）