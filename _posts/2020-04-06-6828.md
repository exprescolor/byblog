---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partA(1)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-05 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# Lab3 用户环境

更新一下我们的文件，发现多了一些：

| `inc/`  | `env.h`       | Public definitions for user-mode environments                |
| ------- | ------------- | ------------------------------------------------------------ |
|         | `trap.h`      | Public definitions for trap handling                         |
|         | `syscall.h`   | Public definitions for system calls from user environments to the kernel |
|         | `lib.h`       | Public definitions for the user-mode support library         |
| `kern/` | `env.h`       | Kernel-private definitions for user-mode environments        |
|         | `env.c`       | Kernel code implementing user-mode environments              |
|         | `trap.h`      | Kernel-private trap handling definitions                     |
|         | `trap.c`      | Trap handling code                                           |
|         | `trapentry.S` | Assembly-language trap handler entry-points                  |
|         | `syscall.h`   | Kernel-private definitions for system call handling          |
|         | `syscall.c`   | System call implementation code                              |
| `lib/`  | `Makefrag`    | Makefile fragment to build user-mode library, `obj/lib/libjos.a` |
|         | `entry.S`     | Assembly-language entry-point for user environments          |
|         | `libmain.c`   | User-mode library setup code called from `entry.S`           |
|         | `syscall.c`   | User-mode system call stub functions                         |
|         | `console.c`   | User-mode implementations of `putchar` and `getchar`, providing console I/O |
|         | `exit.c`      | User-mode implementation of `exit`                           |
|         | `panic.c`     | User-mode implementation of `panic`                          |
| `user/` | `*`           | Various test programs to check kernel lab 3 code             |

## Part A: User Environments and Exception Handling

​		新文件inc/env.h包含了JOS中用户环境的基本定义。用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境，内核使用Env数据结构来跟踪每个用户环境。在这个实验室中，我们最初将只创建一个环境，但是需要设计JOS内核来支持多个环境。

​		以在kern/env.c中看到内核维护与环境相关的三个主要全局变量:

```
struct Env *envs = NULL;		// 所有env结构体
struct Env *curenv = NULL;		// 目前正在运行的用户环境
static struct Env *env_free_list;	// 还没有被使用的env结构体链表
```

​		一旦JOS启动并运行，envs指针指向一个Env结构数组，该数组表示系统中的所有环境。在我们的设计中，JOS内核将支持最多的NENV并发活动环境，尽管在任何给定时间内运行的环境通常要少得多。(NENV在inc/env.h中是一个常量#defined)一旦它被分配，envs数组将为每个NENV可能的环境包含一个Env数据结构实例。

​		JOS内核将所有不活动的Env结构保存在env_free_list中。这种设计允许轻松地分配和释放环境，因为它们只需添加到空闲列表或从空闲列表中删除即可。

​		内核使用curenv符号在任何给定时间跟踪当前执行的环境。在启动期间，在第一个环境运行之前，curenv最初设置为NULL。

### Environment State

Env结构在inc/ Env .h中定义如下：

```
struct Env {
	struct Trapframe env_tf;	// Saved registers
	struct Env *env_link;		// Next free Env
	envid_t env_id;			// Unique environment identifier
	envid_t env_parent_id;		// env_id of this env's parent
	enum EnvType env_type;		// Indicates special system environments
	unsigned env_status;		// Status of the environment
	uint32_t env_runs;		// Number of times environment has run

	// Address space
	pde_t *env_pgdir;		// Kernel virtual address of page dir
};
```

以下是Env字段的解释:

env_tf:

　　这个类型的结构体在inc/trap.h文件中被定义，里面存放着当用户环境暂停运行时，所有重要寄存器的值。内核也会在系统从用户态切换到内核态时保存这些值，这样的话用户环境可以在之后被恢复，继续执行。

env_link:

　　这个指针指向在env_free_list中，该结构体的后一个free的Env结构体。当然前提是这个结构体还没有被分配给任意一个用户环境时，该域才有用。

env_id:

　　这个值可以唯一的确定使用这个结构体的用户环境是什么。当这个用户环境终止，内核会把这个结构体分配给另外一个不同的环境，这个新的环境会有不同的env_id值。

env_parent_id:

　　创建这个用户环境的父用户环境的env_id

env_type:

　　用于区别出来某个特定的用户环境。对于大多数环境来说，它的值都是 ENV_TYPE_USER.

env_status:

　　这个变量存放以下可能的值

　　ENV_FREE: 代表这个结构体是不活跃的，应该在链表env_free_list中。

　　ENV_RUNNABLE: 代表这个结构体对应的用户环境已经就绪，等待被分配处理机。

　　ENV_RUNNING: 代表这个结构体对应的用户环境正在运行。

　　ENV_NOT_RUNNABLE: 代表这个结构体所代表的是一个活跃的用户环境，但是它不能被调度运行，因为它在等待其他环境传递给它的消息。

　　ENV_DYING: 代表这个结构体对应的是一个僵尸环境。一个僵尸环境在下一次陷入内核时会被释放回收。

env_pgdir:

　　这个变量存放着这个环境的页目录的虚拟地址

​		与Unix进程一样，JOS环境将“线程”和“地址空间”的概念结合在一起。线程主要由保存的寄存器(env_tf字段)定义，地址空间由env_pgdir指向的页目录和页表定义。要运行一个环境，内核必须使用保存的寄存器和适当的地址空间来设置CPU。

​		我们的struct Env与xv6中的struct proc类似。这两种结构都能保持环境的平衡。在Trapframe结构中的用户模式寄存器状态。在JOS，各个环境不像xv6中的进程那样拥有自己的内核堆栈。一次在内核中只能有一个活动的JOS环境，因此JOS只需要一个内核堆栈。

### Allocating the Environments Array

在lab2中，我们为pages[]数组在mem_init()中分配了内存，用于记录内核中所有页的信息。现在需要进一步修改mem_init()来分配一个类似的Env结构数组(称为envs)。

### 练习1

修改kern/pmap.c中的mem_init()来分配和映射envs数组。这个数组正好由Env结构的NENV实例组成。与页面数组一样，支持envs的内存也应该在UENVS(在inc/memlayout.h中定义)上将用户映射为只读，这样用户进程就可以从这个数组中读取数据。

用check_kern_pgdir()来检查。

我们只需要像在Lab2里面分配pages数组那样，分配一个Env数组给指针envs就可以了。

```c
// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
// LAB 3: Your code here.
envs = (struct Env*)boot_alloc(sizeof(struct Env) * NENV);
memset(envs, 0, sizeof(struct Env) * NENV);

// Map the 'envs' array read-only by the user at linear address UENVS
// (ie. perm = PTE_U | PTE_P).
// Permissions:
//    - the new image at UENVS  -- kernel R, user R
//    - envs itself -- kernel RW, user NONE
// LAB 3: Your code here.
boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);
```

### Creating and Running Environments

​		现在，我们将用kern/env.c编写运行用户环境所需的代码。因为我们还没有文件系统，所以我们将设置内核来加载嵌入在内核本身中的静态二进制映像。JOS将此二进制文件作为ELF可执行映像嵌入到内核中。

​		lab3 GNUmakefile在obj/user/目录中生成许多二进制映像。如果您查看kern/Makefrag，您会注意到一些神奇的地方，它们将这些二进制文件直接链接到内核可执行文件中，就好像它们是.o文件一样。linker命令行上的-b二进制选项导致这些文件被链接为“原始的”未解释的二进制文件，而不是编译器生成的常规.o文件。

在kern/init.c的i386_init()中，我们将看到在环境中运行这些二进制映像之一的代码。但是，建立用户环境的关键功能还不完善;我们需要把它们填上。

