---
layout:     post   				    # 使用的布局（不需要改）
title:      828-lab1-part3(2)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-30 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# part 3

##栈

​		x86堆栈指针(esp寄存器)指向当前正在使用的堆栈的最低位置。该位置以下为堆栈保留的区域中，所有内容都是空闲的。将一个值压入堆栈时，堆栈指针要减1，然后将该值写入堆栈指针指向的位置。从堆栈弹出一个值时，先读取堆栈指针的值，然后增加堆栈指针。在32位模式下，堆栈的操作都是32位的，esp的值总是能被4整除。各种x86指令(如call)都是“硬连接”的，以使用堆栈指针寄存器。

​		ebp(基本指针)寄存器记录每一个程序的栈帧信息。在进入C函数时，要运行的代码通常通过将前一个函数的ebp的值压入堆栈来保存它，然后在函数执行期间将当前的esp值复制到ebp中。如果所有的功能在程序遵守这样的规则,在程序的执行期间的任意一点时,可以通过在堆栈中保存的一系列ebp寄存器的值来回溯，弄清楚是怎样的一个函数调用序列使我们的程序运行到当前的这个点。这个功能特别有用，例如，当一个特定的函数由于传递了错误的参数而导致assert失败或恐慌时，但是我们不确定是谁传递了错误的参数。堆栈回溯可以让我们找到有问题的函数。

### 练习10

​		Q：要熟悉x86上的C调用约定，在obj/kern/kernel.asm中查找test_backtrace函数的地址。在这里设置一个断点，并检查内核启动后每次调用它时发生了什么。test_backtrace的每个递归嵌套在堆栈上压了多少个32位的信息，这些信息是什么?

```
f0100040 <test_backtrace>:
#include <kern/console.h>

// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
	cprintf("entering test_backtrace %d\n", x);
	if (x > 0)
		test_backtrace(x-1);
	else
		mon_backtrace(0, 0, 0);
	cprintf("leaving test_backtrace %d\n", x);
}
```

​		我们找到这个函数的地址，在asm文件中扣出c代码，发现这是一个循环调用的函数，打印的信息就像栈一样先进后出，然后我们下个断点：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdbwpyult4j30j409yt9h.jpg)

​		设置断点后运行到test_backtrace处停下，查看此时寄存器信息，此时esp存放的是i386_init的返回地址0xf010ffdc，ebp则是栈帧的顶部。然后往下走si：

​		mov %esp,%ebp这句将esp的值赋给ebp，这也正是上面说的回溯应该遵循的准则

​		push   %esi  将esi的值压栈，

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdbxzd82sjj30h705laab.jpg)

​		push   %ebx  将ebx的值压栈![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdbxyjcrdlj30gx05ower.jpg)

执行完第一次循环时

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdby1m8c26j30kw05ogm2.jpg)

然后来到第二次循环时的断点，x=4时：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdby2myminj30is083q3d.jpg)

x=3时：

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdby3b4z3nj30ge05vaab.jpg)

可见，每次循环时在堆栈上压了两个32位的信息。

​		上面的练习给我们提供实现堆栈回溯函数所需的信息，该函数称为mon_backtrace()。这个函数的原型已经在kern/monitor.c中声明了。你可以用C来实现，但是你会发现inc/x86.h中的read_ebp()函数很有用。将这个新函数挂接到内核监视器的命令列表中，以便用户可以交互地调用它。

​		backtrace函数应该以如下格式显示函数调用帧的列表:

```
Stack backtrace:
  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031
  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061
  ...
```

​		每行包含一个ebp、eip和args。ebp值表示该函数使用的堆栈基指针。所列出的eip值是函数的返回指令指针。返回指令指针通常指向调用指令之后的指令。最后，args之后列出的5个十六进制值是函数的前5个参数，这些参数在调用函数之前会被压入堆栈。当然，如果调用函数的参数少于5个，那么这5个值并不都有用。

几点要注意的：

​		如果int* p = (int*)100，那么(int)p + 1和(int)(p + 1)是不同的数字:第一个是101，第二个是104。在向指针添加整数时(如第二种情况)，该整数将隐式地乘以指针指向的对象的大小。

​		p[i]被定义为与*(p+i)相同，指的是p指向的内存中的第i个对象。当对象大于一个字节时，上面的加法规则可以帮助这个定义工作。

​		&p[i]与(p+i)相同，产生由p指向的内存中的第i个对象的地址。

​		尽管大多数C程序从不需要在指针和整数之间进行转换，但是操作系统经常需要这样做。无论何时看到涉及内存地址的加法，都要问问自己它是整数加法还是指针加法，并确保所添加的值相乘是否正确。

### 练习11

​		Q：实现上面指定的回溯函数。使用与示例中相同的格式，否则评分脚本会混淆。

​		如果您使用read_ebp()，请注意GCC可能会在mon_backtrace()的函数序言之前生成调用read_ebp()的“优化”代码，这将导致不完整的堆栈跟踪(最近一次函数调用的堆栈帧丢失)。虽然我们试图禁用导致这种重新排序的优化，但是您可能希望检查mon_backtrace()的程序集，并确保在函数序言之后调用read_ebp()。

​		 这个程序的功能就是要显示当前正在执行的程序的栈帧信息。包括当前的ebp寄存器的值（该子程序的栈帧的最高地址），eip的值（子程序执行完成之后要返回调用它的子程序时，下一个要执行的指令地址）。args的值（子程序接受的来自调用它的子程序传递给它的输入参数）。

​		我们要做的就是根据ebp推导出这些信息:

```
int mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
	// Your code here.
	int i;
	uint32_t eip;
	uint32_t* ebp = (uint32_t *)read_ebp();

	while (ebp) {
		eip = *(ebp + 1);
		cprintf("ebp %x eip %x args", ebp, eip);
		uint32_t *args = ebp + 2;
		for (i = 0; i < 5; i++) {
			uint32_t argi = args[i];
			cprintf(" %08x ", argi);
		}
		cprintf("\n");
		ebp = (uint32_t *) *ebp;
	}
	return 0;
}
```

运行之后的输出：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdcbg369o1j30ry0eqwh3.jpg)

make一下：

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdcbgv0yggj30hn09ngm0.jpg)

​		此时，backtrace函数应该可以提供导致执行mon_backtrace()函数的函数地址。但是，在实践中，我们通常希望知道与这些地址对应的函数名。

​		为了实现此功能，我们提供了函数debuginfo_eip()，它在符号表中查找eip并返回该地址的调试信息。这个函数在kern/kdebug.c中定义。



