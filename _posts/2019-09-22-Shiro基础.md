---
layout:     post 
title:      Shiro基础0922
subtitle:   实现授权Realm、Shiro标签、Shiro权限注解、从数据表中初始化资源和权限、会话管理、SessionDao、会话验证、缓存、记住我
date:       2019-09-22
author:     张鹏
header-img: img/post-bg-YesOrNo.jpg
catalog: true   
tags:                         
    - Shiro
---

#### 实现授权Realm
- 实现步骤

1. 从PrincipalCollection中来获取登陆用户的信息
2. 利用登录的用户信息来获取当前用户的角色或权限（可能需要查询数据库）
3. 创建SimpleAuthorizationInfo，并设置其roles属性
4. 返回SimpleAuthorizationInfo对象

- ShiroRealm.java


```java
	@Override
	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
		//1.从PrincipalCollection中来获取登陆用户的信息
		Object principal=principals.getPrimaryPrincipal();
		//2.利用登录的用户信息来获取当前用户的角色或权限（可能需要查询数据库）
		Set<String> roles=new HashSet<>();
		roles.add("user");
		if ("admin".equals(principal)) {
			roles.add("admin");
		}
		//3.创建SimpleAuthorizationInfo，并设置其roles属性
		SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles);
		//4.返回SimpleAuthorizationInfo对象
		return info;
	}
```

- 实现结果：用户输入的用户名是admin时，可以访问adminpage和userpage；用户输入的用户名是user时，只能访问userpage

#### Shiro标签

- Shiro提供了JSTL标签用于在JSP页面进行权限控制，如根据用户登陆显示相应的页面按钮

1. guest标签：用户没有身份验证时显示相应信息，即游客访问信息

```jsp
<shiro:guest>
欢迎游客访问，<a href="login.jsp">登陆</a>
</shiro:guest>
```

2. user标签：用户已经经过认证/**记住我**登陆后显示相应的信息

```jsp
<shiro:user>
欢迎[<shiro:principal/>]登陆，<a href="logout">退出</a>
</shiro:user>
```

3. authenticated标签：用户已经身份验证通过，即Subject.login登陆成功，**不是记住我登陆的**

```jsp
<shiro:authenticated>
用户[<shiro:principal/>]已身份验证通过
</shiro:authenticated>
```

4. notAuthenticated标签：用户未进行身份验证，即没有调用Subject.login进行登陆，**包括记住我自动登录**的也属于未进行身份验证

```jsp
<shiro:notAuthenticated>
未身份验证（包括记住我）
</shiro:notAuthenticated/>
```

5. principal标签：显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal

```jsp
<shiro:principal property="username"/>
```

6. hasRole标签：如果当前Subject有角色将显示body体内容

```jsp
<shiro:hasRole name="admin">
用户[<shrio:principal/>]拥有角色admin<br/>
</shiro:hasRole>
```

7. hasAnyRoles标签：如果当前Subject有任意一个角色（或的关系）将显示body体内容

```jsp
<shiro:hasAnyRoles name="admin,user">
用户[<shiro:principal/>]拥有角色admin或user<br/>
</shiro:hasAnyRoles>
```

- 实现的结果：用户登陆身份为admin时，显示admin.jsp、user.jsp、logout.jsp三个按钮；用户登陆身份为user，显示user.jsp、logout.jsp两个按钮

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    <%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<h4>list page</h4>

Welcome:<shiro:principal></shiro:principal>

<shiro:hasRole name="admin">
<br><br>
<a href="admin.jsp">adminPage</a>
</shiro:hasRole>

<shiro:hasRole name="user">
<br><br>
<a href="user.jsp">userPage</a>
</shiro:hasRole>
<br><br>
<a href="shiro/logout">Logout</a>
</body>
</html>
```
- 结果示意
- admin

![adminpage](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20104532.png)

- user

![userpage](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20104556.png)

#### Shiro权限注解

1. `@RequiresAuthentication`：表示当前Subject已经通过login进行了身份验证；即`Subject.isAuthenticated()`返回true。
2. `@RequiresUser`：表示当前Subject已经身份验证或者通过**记住我登陆的**
3. `@RequiresGuest`：表示当前Subject没有身份验证或未通过记住我登录过，即是游客身份
4. `@RequiresRoles(value={"admin","user"},logical=Logical.AND)`：表示当前Subject需要**角色**admin和user
5. `@RequiresPermissions(value={"user:a","user:b"},logical=Logical.OR)`：表示当前Subject需要**权限**user:a或user:b

- **注意！！**：在开发的时候一般会在Service层加上@Transactional注解（即让Service方法开始的时候会有事务产生，这时候的Service已经是一个代理对象了），这时候就不能在Service层加Shiro的权限注解了，需要加在Controller层（因为不能够让Service称为代理的代理，这样做的话，在注入的时候会发生类型转换异常）

- 例子：
- ShiroService.java

```java
package com.sc.service;

import java.util.Date;

import org.apache.shiro.authz.annotation.RequiresRoles;

public class ShiroService {
	@RequiresRoles({"admin"})
	public void testMethod() {
		System.out.println("testMethod,tiem:"+new Date());
	}
}
```
- applicationContext.xml

```xml
<bean id="shiroService" class="com.sc.service.ShiroService"></bean>
```

- list.jsp

```jsp
<a href="shiro/testShiroAnnotation">Test ShiroAnnotation</a>
```

- ShiroHandler.java

```java
@Autowired
	private ShiroService shiroService;
	
	@RequestMapping("/testShiroAnnotation")
	public String testShiroAnnotation() {
		shiroService.testMethod();
		return "redirect:/list.jsp";
		
	}
```

- 显示结果：
- 用户登陆身份为admin时，可以调用ShiroService中的testMethod方法；用户登陆身份为user时，点击testMethod会报异常，显示没有admin权限

![展示页面](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20113642.png)

![报错页面](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20113601.png)

#### 从数据表中初始化资源和权限

- 按照以前配置权限的方法可能太过于麻烦（在applicationContext.xml中一个一个的配置），直接从map中获取会更方便
- 步骤：

1. 把原来的filterChainDefinitions更改为filterChainDefinitionMap

```xml
<property name="filterChainDefinitionMap" ref="filterChainDefinitionMap"></property>
```

2. 配置一个bean，该bean实际上是一个Map，通过实例工厂方法的方式

```xml
<bean id="filterChainDefinitionMap" factory-bean="filterChainDefinitionMapBuilder" factory-method="buildfilterChainDefinitionMap"></bean>
    <bean id="filterChainDefinitionMapBuilder" class="com.sc.factory.FilterChainDefinitionMapBuilder"></bean>
```

3. 创建一个工厂类FilterChainDefinitionMapBuilder.java

```java
package com.sc.factory;

import java.util.LinkedHashMap;

public class FilterChainDefinitionMapBuilder {
	public LinkedHashMap<String, String> buildfilterChainDefinitionMap(){
		LinkedHashMap<String, String> map=new LinkedHashMap<>();
		//添加权限的顺序应该注意，否则会相互覆盖
		map.put("/login.jsp", "anon");
		map.put("/shiro/login", "anon");
		map.put("/shiro/logout", "logout");
		map.put("/**", "authc");
		return map;
	}
}

```

- 项目结构：

![项目结构](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20120825.png)

#### 会话管理

- Shiro提供了完整的企业级会话管理功能，**不依赖于底层容器（如web容器tomcat），不管是JavaSE还是JavaEE环境都可以使用**，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对web的透明支持、SSO单点登录的支持等特性。

- 会话相关的API

1. `Subject.getSession()`：即可获取会话，相当于`Subject.getSession(true)`,即没有创建Session对象会创建一个；`Subject.getSession(false)`，没有创建Session则返回null
2. `session.getId()`：获取当前会话的唯一标识
3. `session.getHost()`：获取当前Subject的主机地址
4. `session.getTimeOUt() & session.setTimeOut(毫秒)`：获取/设置当前Session的过期时间
5. `session.getStartTimestamp() & session.getLastAccessTime()`：获取会话的启动时间以及最后的访问时间；如果是JavaSE应用则需要自己定期调用`session.touch()`去更新最后访问时间；如果是web应用，每次进入ShiroFilter都会自动调用`session.touch`来更新最后访问时间
6. `session.touch() & session.stop()`：更新会话最后访问时间以及销毁会话；当`Subject,logout()`时会自动调用stop方法来销毁会话。如果在web中，调用`HttpSession.invalidate()`也会自动调用Shiro `Session.stop()`方法进行销毁Shiro的会话
7. `session.setAttribute(key,val) & session.getAttribute(key) & session.removeAttribute(key)`：设置/获取/删除会话属性；在整个会话范围内都可以对这些属性进行操作

- 会话监听器
   - 会话监听器用于监听会话创建、过期及停止事件
   - `onStart(Session):void`
   - `onStop(Session):void`
   - `onExpiration(Session):void`

- 在web层（Handler层）推荐使用传统的HttpSession。使用Shiro Session可以在Service层访问到session中的数据
- 例子：
- ShiroHandler.java

```java
@Autowired
	private ShiroService shiroService;
	
	@RequestMapping("/testShiroAnnotation")
	public String testShiroAnnotation(HttpSession session) {
		session.setAttribute("key", "value123456");
		shiroService.testMethod();
		return "redirect:/list.jsp";
		
	}
```

- ShiroService.java

```java
package com.sc.service;

import java.util.Date;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authz.annotation.RequiresRoles;
import org.apache.shiro.session.Session;

public class ShiroService {
	@RequiresRoles({ "admin" })
	public void testMethod() {
		System.out.println("testMethod,tiem:" + new Date());

		Session session = SecurityUtils.getSubject().getSession();
		Object val = session.getAttribute("key");
		System.out.println("Service Session:" + val);
	}

}
```

- 运行结果：

![运行结果](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20131033.png)

#### SessionDao

- SessionDao可以把Session写到数据库中，然后对Session进行增删改查操作

![SessionDao](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20131641.png)

1. `AbstractSessionDAO`提供了`SessionDao`的**基础实现**，如生成会话ID等
2. `CachingSessionDAO`提供了对开发者透明的**会话缓存的功能**，需要设置相应的CacheManager
3. `MemorySessionDAO`直接在**内存中进行会话维护**
4. `EnterpriseCacheSessionDAO`提供了缓存功能的会话维护，**默认情况下使用MapCache实现**，内部使用ConcurrentHashMap保存缓存的会话

#### 会话验证

- Shiro提供了会话验证调度器，用于定期验证会话是否已经过期，如果会话过期则停止会话。
- 出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如果在web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro提供了会话验证调度器`SessionValidationScheduler`
- Shiro也提供了使用Quartz会话验证调度器：`QuartzSessionValidationScheduler`

#### 缓存

- CacheManagerAware接口
   - Shiro内部的组件（DefaultSecurityManager）会自动检测相应的对象（如Realm）**是否实现了CacheManagerAware并自动注入相应的CacheManager**。

- Realm缓存
   - Shiro提供了CachingRealm，其实现了CacheManagerAware接口，提供了缓存的一些基础实现
   - `AuthentiactingRealm`及`AuthorizingRealm`也分别提供了对`AuthenticationInfo`和`AuthorizationInfo`信息的缓存

#### RememberMe（记住我）

- Shiro提供了记住我（rememberme）的功能，具体流程如下：
   - 首先在登陆页面选择RememberMe然后登陆成功；如果是浏览器登陆，一般会把RememberMe的Cookie写到客户端并保存下来
   - 关闭浏览器再重新打开；会发现浏览器还是记住你的
   - 访问一般的网页端还是知道你是谁，且能够正常访问
   - 但是比如我们访问淘宝时，如果要**查看我的订单或进行支付时，此时还是需要再进行身份验证的，以确保当前用户还是你**

- 认证和记住我的区别
   - `subject.isAuthenticated()`表示用户进行了身份验证登陆的，即使有`Subject.login`进行了登录
   - `subject.isRemembered()`表示用户是通过记住我登陆的，此时你可能并不是真正的你在访问的
   - 两者二选一，即`subject.isAuthenticated()==true`则`subject.isRemembered()==false`。反之一样