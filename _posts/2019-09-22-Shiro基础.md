---
layout:     post 
title:      Shiro基础0922
subtitle:   实现授权Realm、Shiro标签、Shiro权限注解、从数据表中初始化资源和权限
date:       2019-09-22
author:     张鹏
header-img: img/post-bg-YesOrNo.jpg
catalog: true   
tags:                         
    - Shiro
---

#### 实现授权Realm
- 实现步骤

1. 从PrincipalCollection中来获取登陆用户的信息
2. 利用登录的用户信息来获取当前用户的角色或权限（可能需要查询数据库）
3. 创建SimpleAuthorizationInfo，并设置其roles属性
4. 返回SimpleAuthorizationInfo对象

- ShiroRealm.java


```java
	@Override
	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
		//1.从PrincipalCollection中来获取登陆用户的信息
		Object principal=principals.getPrimaryPrincipal();
		//2.利用登录的用户信息来获取当前用户的角色或权限（可能需要查询数据库）
		Set<String> roles=new HashSet<>();
		roles.add("user");
		if ("admin".equals(principal)) {
			roles.add("admin");
		}
		//3.创建SimpleAuthorizationInfo，并设置其roles属性
		SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles);
		//4.返回SimpleAuthorizationInfo对象
		return info;
	}
```

- 实现结果：用户输入的用户名是admin时，可以访问adminpage和userpage；用户输入的用户名是user时，只能访问userpage

#### Shiro标签

- Shiro提供了JSTL标签用于在JSP页面进行权限控制，如根据用户登陆显示相应的页面按钮

1. guest标签：用户没有身份验证时显示相应信息，即游客访问信息

```jsp
<shiro:guest>
欢迎游客访问，<a href="login.jsp">登陆</a>
</shiro:guest>
```

2. user标签：用户已经经过认证/**记住我**登陆后显示相应的信息

```jsp
<shiro:user>
欢迎[<shiro:principal/>]登陆，<a href="logout">退出</a>
</shiro:user>
```

3. authenticated标签：用户已经身份验证通过，即Subject.login登陆成功，**不是记住我登陆的**

```jsp
<shiro:authenticated>
用户[<shiro:principal/>]已身份验证通过
</shiro:authenticated>
```

4. notAuthenticated标签：用户未进行身份验证，即没有调用Subject.login进行登陆，**包括记住我自动登录**的也属于未进行身份验证

```jsp
<shiro:notAuthenticated>
未身份验证（包括记住我）
</shiro:notAuthenticated/>
```

5. principal标签：显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal

```jsp
<shiro:principal property="username"/>
```

6. hasRole标签：如果当前Subject有角色将显示body体内容

```jsp
<shiro:hasRole name="admin">
用户[<shrio:principal/>]拥有角色admin<br/>
</shiro:hasRole>
```

7. hasAnyRoles标签：如果当前Subject有任意一个角色（或的关系）将显示body体内容

```jsp
<shiro:hasAnyRoles name="admin,user">
用户[<shiro:principal/>]拥有角色admin或user<br/>
</shiro:hasAnyRoles>
```

- 实现的结果：用户登陆身份为admin时，显示admin.jsp、user.jsp、logout.jsp三个按钮；用户登陆身份为user，显示user.jsp、logout.jsp两个按钮

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    <%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
<h4>list page</h4>

Welcome:<shiro:principal></shiro:principal>

<shiro:hasRole name="admin">
<br><br>
<a href="admin.jsp">adminPage</a>
</shiro:hasRole>

<shiro:hasRole name="user">
<br><br>
<a href="user.jsp">userPage</a>
</shiro:hasRole>
<br><br>
<a href="shiro/logout">Logout</a>
</body>
</html>
```
- 结果示意
- admin

![adminpage](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20104532.png)

- user

![userpage](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20104556.png)

#### Shiro权限注解

1. `@RequiresAuthentication`：表示当前Subject已经通过login进行了身份验证；即`Subject.isAuthenticated()`返回true。
2. `@RequiresUser`：表示当前Subject已经身份验证或者通过**记住我登陆的**
3. `@RequiresGuest`：表示当前Subject没有身份验证或未通过记住我登录过，即是游客身份
4. `@RequiresRoles(value={"admin","user"},logical=Logical.AND)`：表示当前Subject需要**角色**admin和user
5. `@RequiresPermissions(value={"user:a","user:b"},logical=Logical.OR)`：表示当前Subject需要**权限**user:a或user:b

- **注意！！**：在开发的时候一般会在Service层加上@Transactional注解（即让Service方法开始的时候会有事务产生，这时候的Service已经是一个代理对象了），这时候就不能在Service层加Shiro的权限注解了，需要加在Controller层（因为不能够让Service称为代理的代理，这样做的话，在注入的时候会发生类型转换异常）

- 例子：
- ShiroService.java

```java
package com.sc.service;

import java.util.Date;

import org.apache.shiro.authz.annotation.RequiresRoles;

public class ShiroService {
	@RequiresRoles({"admin"})
	public void testMethod() {
		System.out.println("testMethod,tiem:"+new Date());
	}
}
```
- applicationContext.xml

```xml
<bean id="shiroService" class="com.sc.service.ShiroService"></bean>
```

- list.jsp

```jsp
<a href="shiro/testShiroAnnotation">Test ShiroAnnotation</a>
```

- ShiroHandler.java

```java
@Autowired
	private ShiroService shiroService;
	
	@RequestMapping("/testShiroAnnotation")
	public String testShiroAnnotation() {
		shiroService.testMethod();
		return "redirect:/list.jsp";
		
	}
```

- 显示结果：
- 用户登陆身份为admin时，可以调用ShiroService中的testMethod方法；用户登陆身份为user时，点击testMethod会报异常，显示没有admin权限

![展示页面](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20113642.png)

![报错页面](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E6%89%B9%E6%B3%A8%202019-09-22%20113601.png)

#### 从数据表中初始化资源和权限

- 按照以前配置权限的方法可能太过于麻烦（在applicationContext.xml中一个一个的配置），直接从map中获取会更方便
- 步骤：

1. 把原来的filterChainDefinitions更改为filterChainDefinitionMap

```xml
<property name="filterChainDefinitionMap" ref="filterChainDefinitionMap"></property>
```

2. 配置一个bean，该bean实际上是一个Map，通过实例工厂方法的方式

```xml
<bean id="filterChainDefinitionMap" factory-bean="filterChainDefinitionMapBuilder" factory-method="buildfilterChainDefinitionMap"></bean>
    <bean id="filterChainDefinitionMapBuilder" class="com.sc.factory.FilterChainDefinitionMapBuilder"></bean>
```

3. 创建一个工厂类FilterChainDefinitionMapBuilder.java

```java
package com.sc.factory;

import java.util.LinkedHashMap;

public class FilterChainDefinitionMapBuilder {
	public LinkedHashMap<String, String> buildfilterChainDefinitionMap(){
		LinkedHashMap<String, String> map=new LinkedHashMap<>();
		//添加权限的顺序应该注意，否则会相互覆盖
		map.put("/login.jsp", "anon");
		map.put("/shiro/login", "anon");
		map.put("/shiro/logout", "logout");
		map.put("/**", "authc");
		return map;
	}
}

```

- 项目结构：

![项目结构]()