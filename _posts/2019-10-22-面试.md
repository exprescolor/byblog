---
layout:     post 
title:      杂谈1022
subtitle:   Synchronized、ReenTrantLock、线程方法
date:       2019-10-22
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.线程中的sleep()、join（）、yield（）方法有什么区别？

- **sleep()**
   - sleep方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步代码块，其他线程仍然不能访问共享数据。
- **wait()**
   - wait()方法需要和notify()和notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块中使用，也就是说，调用wait()，notify()，notifyAll()的任务在调用这些方法前必须拥有对象的锁。
   - **他们都是Object类的方法，而不是Thread类的方法**
   - wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一个对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，他们随时准备争夺锁的所有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。
   - 除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池
   - 此外，wait()，notify()和notifyAll()只能在synchronized语句中使用，但如果使用的是ReenTrantLock实现同步，应使用`ReenTrantLock.newCondition()`获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面三种方法
- **yield()**
   - yield()和sleep()方法类似，也不会释放锁标志，区别在于，他没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或高优先级的线程得到执行机会，这也和sleep()方法不同
- **join()**
   - join()方法会使当前线程等待到正在调用join()方法的线程结束后才能继续执行

#### 2.Java中的ReentrantLock和synchronized两种锁定机制的对比

##### 线程同步问题的产生
   - Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据的不准确，相互之间产生冲突。
   - 如下例：假设有一个卖票系统，一共有100张票，有4个窗口同时卖

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;

    public void run() {
        while (true) {
            if (num > 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                // 输出卖票信息
                System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
            }
        }
    }
}

public static void main(String[] args) {
Ticket t = new Ticket();//创建一个线程任务对象。
//创建4个线程同时卖票 
Thread t1 = new Thread(t);
Thread t2 = new Thread(t);
Thread t3 = new Thread(t);
Thread t4 = new Thread(t); 
//启动线程
t1.start(); 
t2.start(); 
t3.start(); 
t4.start();
}
```

- 部分输出结果：

```java
Thread-1.....sale....2
Thread-0.....sale....3
Thread-2.....sale....1
Thread-0.....sale....0
Thread-1.....sale....0
Thread-3.....sale....1
```

- 显然上述结果是不合理的，对于同一张票进行了多次售出。这就是在多线程的情况下， 出现了数据“脏读”情况。即多个线程访问余票num时，当一个线程获得余票的数量，要在此基础上进行减1的操作之前，其他线程可能已经卖出去了很多张票，导致获取到的num不是最新的，然后减1后更新的数据就有了错误，这就需要线程同步的实现了。
- 一共有两种锁，来解决线程同步问题：Synchronized和ReenTrantLock。
##### synchronized关键字

- Java中每个对象都可以作为锁，当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。synchronized实现同步的方式有以下三种
   - 同步普通方法：锁的是当前对象
   - 同步静态方法：锁的是当前class
   - 同步块：锁的是`{}`中的对象
- JVM是通过进入、退出对象监视器（Monitor）来实现对方法、同步块的同步的。具体实现是在编译之后在同步方法前加入一个monitor.entry指令，在退出方法和异常处插入monitor.exit的指令。其本质就是对一个对象监视器（Monitor）进行获取，而这个获取过程具有排他性从而达到同一时刻只能一个线程访问的目的。而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。流程图如下：
- ![]()