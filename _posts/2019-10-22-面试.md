---
layout:     post 
title:      杂谈1022
subtitle:   Synchronized、ReenTrantLock、线程方法
date:       2019-10-22
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.线程中的sleep()、join（）、yield（）方法有什么区别？

- **sleep()**
   - sleep方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步代码块，其他线程仍然不能访问共享数据。
- **wait()**
   - wait()方法需要和notify()和notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块中使用，也就是说，调用wait()，notify()，notifyAll()的任务在调用这些方法前必须拥有对象的锁。
   - **他们都是Object类的方法，而不是Thread类的方法**
   - wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一个对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，他们随时准备争夺锁的所有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。
   - 除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池
   - 此外，wait()，notify()和notifyAll()只能在synchronized语句中使用，但如果使用的是ReenTrantLock实现同步，应使用`ReenTrantLock.newCondition()`获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面三种方法
- **yield()**
   - yield()和sleep()方法类似，也不会释放锁标志，区别在于，他没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或高优先级的线程得到执行机会，这也和sleep()方法不同
- **join()**
   - join()方法会使当前线程等待到正在调用join()方法的线程结束后才能继续执行

#### 2.Java中的ReentrantLock和synchronized两种锁定机制的对比

##### 线程同步问题的产生
   - Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据的不准确，相互之间产生冲突。
   - 如下例：假设有一个卖票系统，一共有100张票，有4个窗口同时卖

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;

    public void run() {
        while (true) {
            if (num > 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                // 输出卖票信息
                System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
            }
        }
    }
}

public static void main(String[] args) {
Ticket t = new Ticket();//创建一个线程任务对象。
//创建4个线程同时卖票 
Thread t1 = new Thread(t);
Thread t2 = new Thread(t);
Thread t3 = new Thread(t);
Thread t4 = new Thread(t); 
//启动线程
t1.start(); 
t2.start(); 
t3.start(); 
t4.start();
}
```

- 部分输出结果：

```java
Thread-1.....sale....2
Thread-0.....sale....3
Thread-2.....sale....1
Thread-0.....sale....0
Thread-1.....sale....0
Thread-3.....sale....1
```

- 显然上述结果是不合理的，对于同一张票进行了多次售出。这就是在多线程的情况下， 出现了数据“脏读”情况。即多个线程访问余票num时，当一个线程获得余票的数量，要在此基础上进行减1的操作之前，其他线程可能已经卖出去了很多张票，导致获取到的num不是最新的，然后减1后更新的数据就有了错误，这就需要线程同步的实现了。
- 一共有两种锁，来解决线程同步问题：Synchronized和ReenTrantLock。
##### synchronized关键字

- Java中每个对象都可以作为锁，当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。synchronized实现同步的方式有以下三种
   - 同步普通方法：锁的是当前对象
   - 同步静态方法：锁的是当前class
   - 同步块：锁的是`{}`中的对象
- 把代码块声明为 synchronized，有两个重要后果，通常是指该代码具有 原子性（atomicity）和 可见性（visibility）。原子性意味着一个线程一次只能执行由一个指定监控对象（lock）保护的代码，从而防止多个线程在更新共享状态时相互冲突。可见性则更为微妙；它要对付内存缓存和编译器优化的各种反常行为。一般来说，线程以某种不必让其他线程立即可以看到的方式（不管这些线程在寄存器中、在处理器特定的缓存中，还是通过指令重排或者其他编译器优化），不受缓存变量值的约束，但是如果开发人员使用了同步，那么运行库将确保某一线程对变量所做的更新先于对现有 synchronized 块所进行的更新，当进入由同一监控器（Monitor）保护的另一个 synchronized 块时，将立刻可以看到这些对变量所做的更新。
- JVM是通过进入、退出对象监视器（Monitor）来实现对方法、同步块的同步的。具体实现是在编译之后在同步方法前加入一个monitor.entry指令，在退出方法和异常处插入monitor.exit的指令。其本质就是对一个对象监视器（Monitor）进行获取，而这个获取过程具有排他性从而达到同一时刻只能一个线程访问的目的。而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。流程图如下：
- ![synchronized](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/synchronized.jpg)
- 利用synchronized解决上述的同步问题

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;

    public void run() {
        while (true) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                synchronized (this) {
                    // 输出卖票信息
                    if(num>0){
                        System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
                    }
                    
                }
        }
    }
}
```

- 部分输出结果：

```java
Thread-2.....sale....10
Thread-1.....sale....9
Thread-3.....sale....8
Thread-0.....sale....7
Thread-2.....sale....6
Thread-1.....sale....5
Thread-2.....sale....4
Thread-1.....sale....3
Thread-3.....sale....2
Thread-0.....sale....1
```

- 可以看出实现了线程同步。同时改了一下逻辑，在进入到同步代码块的时候，先判断现在有没有票，然后再买票，防止出现没有票还要售出的情况。

##### ReenTrantLock类

- java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。
- ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。）
- Lock接口的主要方法：
   - **`void lock()`**：执行此方法时，如果锁处于空闲状态，当前线程将获取到锁；相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁
   - **`boolean tryLock()`**：如果锁可用，则获取锁，并立即返回true，否则返回false。该方法和lock()的区别是：tryLock()只是试图获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码；而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前，当前线程并不会向下执行。
   - **`void unlock()`**：执行此方法时，当前线程将释放持有的锁。锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生
   - **`Condition newCondition()`**：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。

##### ReenTrantLock的使用

- 只需要显式调用，获得同步锁，释放同步锁即可

```java
ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁    
 .....................    
lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果    
try {    
    //操作    
} finally {    
    lock.unlock();  //释放锁  
}  
```

- 针对开头的问题，利用ReenTrantLock解决

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;
    ReentrantLock lock = new ReentrantLock();

    public void run() {
        while (true) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
            }

            lock.lock();
            // 输出卖票信息
            if (num > 0) {
                System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
            }
            lock.unlock();

        }
    }
}
```

##### 重入锁

- 当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。具体概念就是：自己可以再次获取自己的内部锁。Java里面内置锁(synchronized)和Lock(ReenTrantLock)都是可以重入的