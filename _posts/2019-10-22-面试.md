---
layout:     post 
title:      杂谈1022
subtitle:   Synchronized、ReenTrantLock、线程方法
date:       2019-10-22
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.线程中的sleep()、join（）、yield（）方法有什么区别？

- **sleep()**
   - sleep方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步代码块，其他线程仍然不能访问共享数据。
- **wait()**
   - wait()方法需要和notify()和notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块中使用，也就是说，调用wait()，notify()，notifyAll()的任务在调用这些方法前必须拥有对象的锁。
   - **他们都是Object类的方法，而不是Thread类的方法**
   - wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一个对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，他们随时准备争夺锁的所有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。
   - 除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池
   - 此外，wait()，notify()和notifyAll()只能在synchronized语句中使用，但如果使用的是ReenTrantLock实现同步，应使用`ReenTrantLock.newCondition()`获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面三种方法
- **yield()**
   - yield()和sleep()方法类似，也不会释放锁标志，区别在于，他没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或高优先级的线程得到执行机会，这也和sleep()方法不同
- **join()**
   - join()方法会使当前线程等待到正在调用join()方法的线程结束后才能继续执行

#### 2.Java中的ReentrantLock和synchronized两种锁定机制的对比

##### 线程同步问题的产生
   - Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据的不准确，相互之间产生冲突。
   - 如下例：假设有一个卖票系统，一共有100张票，有4个窗口同时卖

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;

    public void run() {
        while (true) {
            if (num > 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                // 输出卖票信息
                System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
            }
        }
    }
}

public static void main(String[] args) {
Ticket t = new Ticket();//创建一个线程任务对象。
//创建4个线程同时卖票 
Thread t1 = new Thread(t);
Thread t2 = new Thread(t);
Thread t3 = new Thread(t);
Thread t4 = new Thread(t); 
//启动线程
t1.start(); 
t2.start(); 
t3.start(); 
t4.start();
}
```

- 部分输出结果：

```java
Thread-1.....sale....2
Thread-0.....sale....3
Thread-2.....sale....1
Thread-0.....sale....0
Thread-1.....sale....0
Thread-3.....sale....1
```

- 显然上述结果是不合理的，对于同一张票进行了多次售出。这就是在多线程的情况下， 出现了数据“脏读”情况。即多个线程访问余票num时，当一个线程获得余票的数量，要在此基础上进行减1的操作之前，其他线程可能已经卖出去了很多张票，导致获取到的num不是最新的，然后减1后更新的数据就有了错误，这就需要线程同步的实现了。
- 一共有两种锁，来解决线程同步问题：Synchronized和ReenTrantLock。
##### synchronized关键字

- Java中每个对象都可以作为锁，当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。synchronized实现同步的方式有以下三种
   - 同步普通方法：锁的是当前对象
   - 同步静态方法：锁的是当前class
   - 同步块：锁的是`{}`中的对象
- 把代码块声明为 synchronized，有两个重要后果，通常是指该代码具有 原子性（atomicity）和 可见性（visibility）。原子性意味着一个线程一次只能执行由一个指定监控对象（lock）保护的代码，从而防止多个线程在更新共享状态时相互冲突。可见性则更为微妙；它要对付内存缓存和编译器优化的各种反常行为。一般来说，线程以某种不必让其他线程立即可以看到的方式（不管这些线程在寄存器中、在处理器特定的缓存中，还是通过指令重排或者其他编译器优化），不受缓存变量值的约束，但是如果开发人员使用了同步，那么运行库将确保某一线程对变量所做的更新先于对现有 synchronized 块所进行的更新，当进入由同一监控器（Monitor）保护的另一个 synchronized 块时，将立刻可以看到这些对变量所做的更新。
- JVM是通过进入、退出对象监视器（Monitor）来实现对方法、同步块的同步的。具体实现是在编译之后在同步方法前加入一个monitor.entry指令，在退出方法和异常处插入monitor.exit的指令。其本质就是对一个对象监视器（Monitor）进行获取，而这个获取过程具有排他性从而达到同一时刻只能一个线程访问的目的。而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程monitor.exit之后才能尝试继续获取锁。流程图如下：
- ![synchronized](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/synchronized.jpg)
- 利用synchronized解决上述的同步问题

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;

    public void run() {
        while (true) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                synchronized (this) {
                    // 输出卖票信息
                    if(num>0){
                        System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
                    }
                    
                }
        }
    }
}
```

- 部分输出结果：

```java
Thread-2.....sale....10
Thread-1.....sale....9
Thread-3.....sale....8
Thread-0.....sale....7
Thread-2.....sale....6
Thread-1.....sale....5
Thread-2.....sale....4
Thread-1.....sale....3
Thread-3.....sale....2
Thread-0.....sale....1
```

- 可以看出实现了线程同步。同时改了一下逻辑，在进入到同步代码块的时候，先判断现在有没有票，然后再买票，防止出现没有票还要售出的情况。

##### ReenTrantLock类

- java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。
- ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，把更多时间用在执行线程上。）
- Lock接口的主要方法：
   - **`void lock()`**：执行此方法时，如果锁处于空闲状态，当前线程将获取到锁；相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁
   - **`boolean tryLock()`**：如果锁可用，则获取锁，并立即返回true，否则返回false。该方法和lock()的区别是：tryLock()只是试图获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码；而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前，当前线程并不会向下执行。
   - **`void unlock()`**：执行此方法时，当前线程将释放持有的锁。锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生
   - **`Condition newCondition()`**：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。

##### ReenTrantLock的使用

- 只需要显式调用，获得同步锁，释放同步锁即可

```java
ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁    
 .....................    
lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果    
try {    
    //操作    
} finally {    
    lock.unlock();  //释放锁  
}  
```

- 针对开头的问题，利用ReenTrantLock解决

```java
public class Ticket implements Runnable {
    // 当前拥有的票数
    private int num = 100;
    ReentrantLock lock = new ReentrantLock();

    public void run() {
        while (true) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
            }

            lock.lock();
            // 输出卖票信息
            if (num > 0) {
                System.out.println(Thread.currentThread().getName() + ".....sale...." + num--);
            }
            lock.unlock();

        }
    }
}
```

##### 重入锁

- 当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。具体概念就是：自己可以再次获取自己的内部锁。Java里面内置锁(synchronized)和Lock(ReenTrantLock)都是可以重入的
- synchronized的重入锁示例，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取：

```java
public class SynchronizedTest {
    public void method1() {
        synchronized (SynchronizedTest.class) {
            System.out.println("方法1获得synchronized的锁运行了");
            method2();
        }
    }
    public void method2() {
        synchronized (SynchronizedTest.class) {
            System.out.println("方法1里面调用的方法2重入锁,也正常运行了");
        }
    }
    public static void main(String[] args) {
        new SynchronizedTest().method1();
    }
}
```

- 运行结果：

```java
方法1获得synchronized的锁运行了
方法1里面调用的方法2重入锁,也正常运行了
```

- ReenTrantLock的重入锁示例，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。

```java
package redis;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest {
    private Lock lock = new ReentrantLock();
    public void method1() {
        lock.lock();
        try {
            System.out.println("方法1获得ReentrantLock锁运行了");
            method2();
        } finally {
            lock.unlock();
        }
    }
    public void method2() {
        lock.lock();
        try {
            System.out.println("方法1里面调用的方法2重入ReentrantLock锁,也正常运行了");
        } finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        new ReentrantLockTest().method1();
    }
}
```

- 运行结果：

```java
方法1获得ReentrantLock锁运行了
方法1里面调用的方法2重入ReentrantLock锁,也正常运行了
```

##### ReenTrantLock中的公平锁

- CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。
- ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。
- 例子：

```java
public class LockFairTest implements Runnable{
    //创建公平锁
    private static ReentrantLock lock=new ReentrantLock(true);
    public void run() {
        while(true){
            lock.lock();
            try{
                System.out.println(Thread.currentThread().getName()+"获得锁");
            }finally{
                lock.unlock();
            }
        }
    }
    public static void main(String[] args) {
        LockFairTest lft=new LockFairTest();
        Thread th1=new Thread(lft);
        Thread th2=new Thread(lft);
        th1.start();
        th2.start();
    }
}
```

- 部分运行结果，可看出两个线程是交替执行的，几乎不会出现同一个线程连续执行多次。：

```java
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
Thread-1获得锁
Thread-0获得锁
```

#### 总结

##### synchronized和ReentrantLock的比较

- ***区别***
   - Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现
   - synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
   - Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断
   - 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到
   - Lock可以提高多个线程进行读操作的效率
- ***两者在锁的相关概念上区别***
   - **可中断锁**
      - 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。lockInterruptibly()的用法体现了Lock的可中断性。
   - **公平锁**
      - 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。
      - 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。
      - 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。
   - **读写锁**
      - 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
      - 正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。
      - ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。
   - **绑定多个条件**
      - 一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。
- ***性能***
   - 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。