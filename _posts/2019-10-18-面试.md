---
layout:     post 
title:      杂谈1018
subtitle:   练习题
date:       2019-10-18
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.以下代码执行后，NumberList中的元素依次是什么？

```java
List<Integer> NumberList = new ArrayList<Integer>();
NumberList.add(2);
NumberList.add(4);
NumberList.add(1);
NumberList.add(3);
NumberList.add(5);
for(int i =0;i<NumberList.size();++i){
    int v = NumberList.get(i);
    if(v%2==0){
        NumberList.remove(v);
    }
}
System.out.println(NumberList);
```

- 会出现越界情况
- ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size()也会减小；
- remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素
- 对于List而言，想要移除元素，要不然就用迭代器。要不然就从后往前删除。

#### 2.以下代码的输出结果是什么？

```java
class Base{
    public Base(String s){
        System.out.print("B");
    }
}
public class Derived extends Base{
    public Derived (String s) {
        System.out.print("D");
    }
    public static void main(String[] args){
        new Derived("C");
    }
}
```

- 编译错误
- 在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用"super(参数或无参数)"指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。

#### 3.下面的对象创建方法中哪些会调用构造方法 ？

1. new语句创建对象
2. 调用Java.io.ObjectInputStream的readObject方法
3. java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法
4. 调用对象的clone()方法

- 答案：1，3
- 构造函数的作用是完成对象的初始化。当程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化。而选项2、4中，对象的初始化并不是通过构造函数完成的，而是读取别的内存区域中的对象的各个域来完成。

#### 4.关于Java中的数组，下面的一些描述，哪些描述是准确的？

1. 数组是一个对象，不同类型的数组具有不同的类
2. 数组长度是可以动态调整的
3. 数组是一个连续的存储结构
4. 一个固定长度的数组可类似这样定义: int array[100]
5. 两个数组用equals方法比较时，会逐个便利其中的元素，对每个元素进行比较
6. 可以二维数组，且可以有多维数组，都是在Java中合法的

- 正确答案：1，3，5
- 数组是对象，因为可以调用方法
- 数组长度是不能动态调整的
- Java中的数组中的数据是连续存储在一块内存中的，所以可以通过下标(即偏移量)的方式访问
- 数组的equals方法是object的equals，比较的是内存地址
- java可以有多维数组

####  5.Given the following code，Which statement at line 11 constructs an instance of the inner class?

```java
 import EnclosingOne.InsideOne
1.class Enclosingone
2.{
3.    public class InsideOne {}
4.
5.}
6.public class inertest
7.{
8.    public static void main(string[]args)
9.    {
10.        EnclosingOne eo = new EnclosingOne();
11.        //insert code here
12.    }
13.
14.}
```

1. `InsideOne ei=eo.new InsideOne();`
2. `eo.InsideOne ei=eo.new InsideOne();`
3. `InsideOne ei=EnclosingOne.new InsideOne();`
4. `EnclosingOne.InsideOne ei=eo.new InsideOne();`

- 答案：1，4
- 非静态内部类的对象的创建方法，如下

```java
public class Enclosingone {
    //非静态内部类
    public class InsideOne {}
    //静态内部类
    public static class InsideTwo{}
}
 
class Mytest02{
    public static void main(String args []){
        Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象
        Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象
    }
}
```

#### 6. 以下代码的运行结果是什么？

```java
public class P {
public static int abc = 123;
static{
System.out.println("P is init");
}
}
public class S extends P {
static{
System.out.println("S is init");
}
}
public class Test {
public static void main(String[] args) {
System.out.println(S.abc);
}
}
```

- 正确答案：`P is init<br />123`
- 子类引用父类的静态字段，只会触发子类的加载，父类的初始化，不会导致子类初始化
- 通过数组定义来引用类。不会触发此类的初始化
- 常量在编译阶段会进行常量优化，将常量存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

#### 7.线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现?

- HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。
- Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如
   - `List  list = Collections.synchronizedList(new ArrayList())`
   - `Set  set = Collections.synchronizedSet(new HashSet());`

#### 8.Java对象初始化顺序

1. 父类静态代码块，父类静态成员变量（同级，按代码顺序执行）
2. 子类静态代码块，子类静态成员变量（同级，按代码顺序执行）
3. 父类普通代码块，父类普通成员变量（同级，按代码顺序执行）
4. 父类构造方法
5. 子类普通代码块，子类普通成员变量（同级，按代码顺序执行）
6. 子类构造方法

- **注意**：
   - 静态内容只在类加载时执行一次，之后不再执行。
   - 默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。

- 运行如下程序进行了解

```java
class Father {
    public Father() {
        System.out.println("父类无参构造方法");
    }
    static {
        System.out.println("父类静态代码块1");
    }
    private static int a = Help.fatherStaticMemberVarInit();
    static {
        System.out.println("父类静态代码块2");
    }
    {
        System.out.println("父类普通代码块1");
    }
    private int b = Help.fatherMemberVarInit();
    {
        System.out.println("父类普通代码块2");
    }
    public Father(int v) {
        System.out.println("父类带参构造方法");
    }
}
 
class Son extends Father {
    static {
        System.out.println("子类静态代码块1");
    }
    private static int a = Help.sonStaticMemberVarInit();
    static {
        System.out.println("子类静态代码块2");
    }
    {
        System.out.println("子类普通代码块1");
    }
    private int b = Help.sonMemberVarInit();
    {
        System.out.println("子类普通代码块2");
    }
    public Son() {
        // super(2018);
        System.out.println("子类构造方法");
    }
}
 
class Help {
    public static int fatherStaticMemberVarInit() {
        System.out.println("父类静态成员变量");
        return 0;
    }
    public static int fatherMemberVarInit() {
        System.out.println("父类普通成员变量");
        return 0;
    }
    public static int sonStaticMemberVarInit() {
        System.out.println("子类静态成员变量");
        return 0;
    }
    public static int sonMemberVarInit() {
        System.out.println("子类普通成员变量");
        return 0;
    }
}
 
public class Test {
    public static void main(String[] args) {
        Son son1 = new Son();
        System.out.println("===================");
        Son son2 = new Son();
    }
}
```

#### 9.Java程序经编译后会产生byte code（字节码）

#### 10.异常分类

![异常分类](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E5%BC%82%E5%B8%B8.jpg)

- 粉红色的是受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守
- 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除...
- 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。

#### 11.从以下哪一个选项中可以获得Servlet的初始化参数?

1. Servlet
2. ServletContext
3. ServletConfig
4. GenericServlet

- 答案：3
- 通过ServletConfig接口的getInitParameter(java.lang.String name)方法
- ServletContext对象：servlet容器在启动时会加载web应用，并为每个web应用创建唯一的servlet context对象，可以把ServletContext看成是一个Web应用的服务器端组件的共享内存，在ServletContext中可以存放共享数据。ServletContext对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问。整个web应用只有唯一的一个ServletContext对象
- servletConfig对象：用于封装servlet的配置信息。从一个servlet被实例化后，对任何客户端在任何时候访问有效，但仅对servlet自身有效，一个servlet的ServletConfig对象不能被另一个servlet访问。

#### 12.依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁

#### 13.在try的括号里面有return一个值，那在哪里执行finally里的代码？

1. 不执行finally代码
2. return前执行
3. return后执行

- 答案：2
- 如果finally中没有return，那么在try中执行return，程序会先执行完finally后再return；如果finally中有return，那么finally中的return会覆盖掉try中的return。

#### 14.以下代码结果是？

```java
 public void test() {
        int a = 10;
        System.out.println(a++ + a--);
    }
```

- 21
- a++ 是先执行表达式后再自增，执行表达式时使用的是a的原值。所以a++是10，但是计算结果是11，也就是说a--是11，计算结果是10.所以最终结果是10+11=21
- ++a是先自增再执行表达式，执行表达式时使用的是自增后的a。

#### 15.以下代码的结果是什么？

```java
public class Person{
    private String name = "Person";
    int age=0;
}
public class Child extends Person{
    public String grade;
    public static void main(String[] args){
        Person p = new Child();
        System.out.println(p.name);
    }
}
```

- 结果：编译出错
- 在子类中试图访问父类的private字段，所以编译不通过，将private去掉就可访问，不是动态绑定的问题，它本来就属于静态绑定。

#### 16. hashmap采用拉链法解决哈希冲突！

#### 17.URL u =new URL("http://www.123.com");。如果www.123.com不存在，则返回什么？

- http://www.123.com
- 自己还以为是括号里面的网址是不存在的，以为会抛出异常；谁知道是这个网址指向的地址不存在。。。
- new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在。不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址

#### 18.以下程序的输出结果是什么？

```java
package Wangyi;
class Base
{
    public void method()
    {
        System.out.println("Base");
    } 
}
class Son extends Base
{
    public void method()
    {
        System.out.println("Son");
    }
     
    public void methodB()
    {
        System.out.println("SonB");
    }
}
public class Test01
{
    public static void main(String[] args)
    {
        Base base = new Son();
        base.method();
        base.methodB();
    }
}
```

- 结果：编译不通过
- 多态成员访问的特点：
   - 成员变量：编译看左边，运行看左边
   - 静态变量：编译看左边，运行看左边
   - 成员方法：编译看左边，运行看右边：意思编译时候，看左边有没有该方法，运行的时候结果看 new 的对象是谁，就调用的谁
   - 静态方法：编译看左边，运行看左边

- 这句new 了一个派生类，赋值给基类，所以下面的操作编译器认为base对象就是Base类型的
Base类中不存在methodB()方法，所以编译不通过

#### 19.Java 提供的事件处理模型是一种人机交互模型。它的三个基本要素分别是什么？

1.  事件源（Event Source）：即事件发生的场所，就是指各个组件，如按钮等，点击按钮其实就是组件上发生的一个事件；
2.  事件（Event）：事件封装了组件上发生的事情，比如按钮单击、按钮松开等等；
3.  事件监听器（Event Listener）：负责监听事件源上发生的特定类型的事件，当事件到来时还必须负责处理相应的事件；

#### 20.调用构造方法前要先初始化！！！！！

#### 21.对于代码 var a = 10.42; 取出 a 的整数部分，以下代码哪些是正确的？

1. parseInt(a);
2. Math.floor(a);
3. Math.ceil(a);
4. a.split('.')[0];

- split是对字符串的分割
- Math.floor();floor（地板）所以向下取整;Math.ceil(); ceiling（天花板） 所以向上取整
- parseInt是转换为整型
- 答案：1，2