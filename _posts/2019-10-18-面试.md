---
layout:     post 
title:      杂谈1018
subtitle:   练习题
date:       2019-10-18
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.以下代码执行后，NumberList中的元素依次是什么？

```java
List<Integer> NumberList = new ArrayList<Integer>();
NumberList.add(2);
NumberList.add(4);
NumberList.add(1);
NumberList.add(3);
NumberList.add(5);
for(int i =0;i<NumberList.size();++i){
    int v = NumberList.get(i);
    if(v%2==0){
        NumberList.remove(v);
    }
}
System.out.println(NumberList);
```

- 会出现越界情况
- ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size()也会减小；
- remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素
- 对于List而言，想要移除元素，要不然就用迭代器。要不然就从后往前删除。

#### 2.以下代码的输出结果是什么？

```java
class Base{
    public Base(String s){
        System.out.print("B");
    }
}
public class Derived extends Base{
    public Derived (String s) {
        System.out.print("D");
    }
    public static void main(String[] args){
        new Derived("C");
    }
}
```

- 编译错误
- 在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用"super(参数或无参数)"指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。

#### 3.下面的对象创建方法中哪些会调用构造方法 ？

1. new语句创建对象
2. 调用Java.io.ObjectInputStream的readObject方法
3. java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法
4. 调用对象的clone()方法

- 答案：1，3
- 构造函数的作用是完成对象的初始化。当程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化。而选项2、4中，对象的初始化并不是通过构造函数完成的，而是读取别的内存区域中的对象的各个域来完成。

#### 4.关于Java中的数组，下面的一些描述，哪些描述是准确的？

1. 数组是一个对象，不同类型的数组具有不同的类
2. 数组长度是可以动态调整的
3. 数组是一个连续的存储结构
4. 一个固定长度的数组可类似这样定义: int array[100]
5. 两个数组用equals方法比较时，会逐个便利其中的元素，对每个元素进行比较
6. 可以二维数组，且可以有多维数组，都是在Java中合法的

- 正确答案：1，3，5
- 数组是对象，因为可以调用方法
- 数组长度是不能动态调整的
- Java中的数组中的数据是连续存储在一块内存中的，所以可以通过下标(即偏移量)的方式访问
- 数组的equals方法是object的equals，比较的是内存地址
- java可以有多维数组

####  5.Given the following code，Which statement at line 11 constructs an instance of the inner class?

```java
 import EnclosingOne.InsideOne
1.class Enclosingone
2.{
3.    public class InsideOne {}
4.
5.}
6.public class inertest
7.{
8.    public static void main(string[]args)
9.    {
10.        EnclosingOne eo = new EnclosingOne();
11.        //insert code here
12.    }
13.
14.}
```

1. `InsideOne ei=eo.new InsideOne();`
2. `eo.InsideOne ei=eo.new InsideOne();`
3. `InsideOne ei=EnclosingOne.new InsideOne();`
4. `EnclosingOne.InsideOne ei=eo.new InsideOne();`

- 答案：1，4
- 非静态内部类的对象的创建方法，如下

```java
public class Enclosingone {
    //非静态内部类
    public class InsideOne {}
    //静态内部类
    public static class InsideTwo{}
}
 
class Mytest02{
    public static void main(String args []){
        Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象
        Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象
    }
}
```

#### 6. 以下代码的运行结果是什么？

```java
public class P {
public static int abc = 123;
static{
System.out.println("P is init");
}
}
public class S extends P {
static{
System.out.println("S is init");
}
}
public class Test {
public static void main(String[] args) {
System.out.println(S.abc);
}
}
```

- 正确答案：`P is init<br />123`
- 子类引用父类的静态字段，只会触发子类的加载，父类的初始化，不会导致子类初始化
- 通过数组定义来引用类。不会触发此类的初始化
- 常量在编译阶段会进行常量优化，将常量存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

#### 7.线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现?

- HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。
- Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如
   - `List  list = Collections.synchronizedList(new ArrayList())`
   - `Set  set = Collections.synchronizedSet(new HashSet());`

#### 8.Java对象初始化顺序

1. 父类静态代码块，父类静态成员变量（同级，按代码顺序执行）
2. 子类静态代码块，子类静态成员变量（同级，按代码顺序执行）
3. 父类普通代码块，父类普通成员变量（同级，按代码顺序执行）
4. 父类构造方法
5. 子类普通代码块，子类普通成员变量（同级，按代码顺序执行）
6. 子类构造方法

- **注意**：
   - 静态内容只在类加载时执行一次，之后不再执行。
   - 默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。

- 运行如下程序进行了解

```java
class Father {
    public Father() {
        System.out.println("父类无参构造方法");
    }
    static {
        System.out.println("父类静态代码块1");
    }
    private static int a = Help.fatherStaticMemberVarInit();
    static {
        System.out.println("父类静态代码块2");
    }
    {
        System.out.println("父类普通代码块1");
    }
    private int b = Help.fatherMemberVarInit();
    {
        System.out.println("父类普通代码块2");
    }
    public Father(int v) {
        System.out.println("父类带参构造方法");
    }
}
 
class Son extends Father {
    static {
        System.out.println("子类静态代码块1");
    }
    private static int a = Help.sonStaticMemberVarInit();
    static {
        System.out.println("子类静态代码块2");
    }
    {
        System.out.println("子类普通代码块1");
    }
    private int b = Help.sonMemberVarInit();
    {
        System.out.println("子类普通代码块2");
    }
    public Son() {
        // super(2018);
        System.out.println("子类构造方法");
    }
}
 
class Help {
    public static int fatherStaticMemberVarInit() {
        System.out.println("父类静态成员变量");
        return 0;
    }
    public static int fatherMemberVarInit() {
        System.out.println("父类普通成员变量");
        return 0;
    }
    public static int sonStaticMemberVarInit() {
        System.out.println("子类静态成员变量");
        return 0;
    }
    public static int sonMemberVarInit() {
        System.out.println("子类普通成员变量");
        return 0;
    }
}
 
public class Test {
    public static void main(String[] args) {
        Son son1 = new Son();
        System.out.println("===================");
        Son son2 = new Son();
    }
}
```

#### 9.