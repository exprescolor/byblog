---
layout:     post                        # 使用的布局（不需要改）
title:      JAVA8日期的操作和格式化              # 标题
subtitle:   
date:       2019-12-12                 # 时间
author:     AhogeK                      # 作者
header-img: img/post-bg-2019.jpg     # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - 学习笔记
    - JAVA8
---
### 日期的操作和格式化

#### 增加和减少日期

Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：

```java
LocalDate date = LocalDate.of(2019, 12, 12);          // 2019-12-12

LocalDate date1 = date.withYear(2018);              // 修改为 2018-12-12
LocalDate date2 = date.withMonth(11);                // 修改为 2018-11-12
LocalDate date3 = date.withDayOfMonth(11);           // 修改为 2018-11-11

LocalDate date4 = date.plusYears(1);                // 增加一年 2019-01-05
LocalDate date5 = date.minusMonths(2);              // 减少两个月 2019-09-11
LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2019-09-16
```

如果需要调整时间到下个工作日或下个月的最后一天，这时可以使用 ``with()`` 方法的另一个重载方法，它接收一个 ``TemporalAdjuster`` 参数，可以使我们更加灵活的调整日期：

```java
LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      // 返回下一个距离当前时间最近的星期日
LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   // 返回本月最后一个星期六
```

要使上面的代码正确编译，你需要使用静态导入 ``TemporalAdjusters`` 对象：

``import static java.time.temporal.TemporalAdjusters.*;``

``TemporalAdjusters`` 类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dayOfWeekInMonth</code></td>
<td>返回同一个月中每周的第几天</td>
</tr>
<tr>
<td><code>firstDayOfMonth</code></td>
<td>返回当月的第一天</td>
</tr>
<tr>
<td><code>firstDayOfNextMonth</code></td>
<td>返回下月的第一天</td>
</tr>
<tr>
<td><code>firstDayOfNextYear</code></td>
<td>返回下一年的第一天</td>
</tr>
<tr>
<td><code>firstDayOfYear</code></td>
<td>返回本年的第一天</td>
</tr>
<tr>
<td><code>firstInMonth</code></td>
<td>返回同一个月中第一个星期几</td>
</tr>
<tr>
<td><code>lastDayOfMonth</code></td>
<td>返回当月的最后一天</td>
</tr>
<tr>
<td><code>lastDayOfNextMonth</code></td>
<td>返回下月的最后一天</td>
</tr>
<tr>
<td><code>lastDayOfNextYear</code></td>
<td>返回下一年的最后一天</td>
</tr>
<tr>
<td><code>lastDayOfYear</code></td>
<td>返回本年的最后一天</td>
</tr>
<tr>
<td><code>lastInMonth</code></td>
<td>返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td><code>next / previous</code></td>
<td>返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td><code>nextOrSame / previousOrSame</code></td>
<td>返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody>
</table>

如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的 ``TemporalAdjuster`` 接口的实现，``TemporalAdjuster`` 也是一个函数式接口，所以我们可以使用Lambda表达式：

```java
@FunctionalInterface
public interface TemporalAdjuster {
    Temporal adjustInto(Temporal temporal);
}
```

比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：

```java
LocalDate date = LocalDate.of(2019, 12, 12);
date.with(temporal -> {
    // 当前日期
    DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));

    // 正常情况下，每次增加一天
    int dayToAdd = 1;

    // 如果是星期五，增加三天
    if (dayOfWeek == DayOfWeek.FRIDAY) {
        dayToAdd = 3;
    }

    // 如果是星期六，增加两天
    if (dayOfWeek == DayOfWeek.SATURDAY) {
        dayToAdd = 2;
    }

    return temporal.plus(dayToAdd, ChronoUnit.DAYS);
});
```

#### 格式化日期

新的日期 API 中提供了一个 ``DateTimeFormatter`` 类用于处理日期格式化操作，它被包含在 ``java.time.format`` 包中，Java 8的日期类有一个 ``format()`` 方法用于将日期格式化为字符串，该方法接收一个 ``DateTimeFormatter`` 类型参数：

```java
LocalDateTime dateTime = LocalDateTime.now();
String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    // 20191212
String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    // 2019-12-12
String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    // 17:04:22.999
String strDate4 = dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));   // 2019-12-12
String strDate5 = dateTime.format(DateTimeFormatter.ofPattern("今天是：YYYY年 MMMM DD日 E", Locale.CHINESE)); // 今天是：2019年 十二月 12日 星期四
```

同样，日期类也支持将一个字符串解析成一个日期对象，例如：

```java
String strDate6 = "2019-12-12";
String strDate7 = "2019-12-12 17:06:17";

LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
```

#### 时区

Java 8 中的时区操作被很大程度上简化了，新的时区类 ``java.time.ZoneId`` 是原有的 ``java.util.TimeZone`` 类的替代品。``ZoneId`` 对象可以通过 ``ZoneId.of()`` 方法创建，也可以通过 ``ZoneId.systemDefault()`` 获取系统默认时区：

```java
ZoneId shanghaiZoneId = ZoneId.of("Asia/Shanghai");
ZoneId systemZoneId = ZoneId.systemDefault();
```

``of()`` 方法接收一个“区域/城市”的字符串作为参数，你可以通过 ``getAvailableZoneIds()`` 方法获取所有合法的“区域/城市”字符串：

``Set<String> zoneIds = ZoneId.getAvailableZoneIds();``

对于老的时区类 ``TimeZone``，Java 8 也提供了转化方法：

``ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();``

有了 ``ZoneId``，我们就可以将一个 ``LocalDate`` 、``LocalTime`` 或 ``LocalDateTime`` 对象转化为 ``ZonedDateTime`` 对象：

```java
LocalDateTime localDateTime = LocalDateTime.now();
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);
```

将zonedDateTime打印到控制台为：

    2017-01-05T15:26:56.147+08:00[Asia/Shanghai]

``ZonedDateTime`` 对象由两部分构成，``LocalDateTime`` 和 ``ZoneId``，其中*2017-01-05T15:26:56.147* 部分为 ``LocalDateTime``，*+08:00[Asia/Shanghai]* 部分为 ``ZoneId``。

另一种表示时区的方式是使用 ``ZoneOffset`` ，它是以当前时间和世界标准时间 *（UTC）/格林威治时间（GMT）* 的偏差来计算，例如：

```java
ZoneOffset zoneOffset = ZoneOffset.of("+09:00");
LocalDateTime localDateTime = LocalDateTime.now();
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);
```

#### 其他历法

Java 中使用的历法是 ISO 8601 日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。

此外 Java 8 还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：

* ``ThaiBuddhistDate`` : 泰国佛教历
* ``MinguoDate`` : 中华民国历
* ``JapaneseDate`` : 日本历
* ``HijrahDate`` : 伊斯兰历

每个日期类都继承 ``ChronoLocalDate`` 类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。

这些不同的历法也可以用于向公历转换：

```java
LocalDate date = LocalDate.now();
JapaneseDate jpDate = JapaneseDate.from(date);
```

由于它们都继承 ``ChronoLocalDate`` 类，所以在不知道具体历法情况下，可以通过``ChronoLocalDate`` 类操作日期：

```java
Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);
ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();
```

**我们在开发过程中应该尽量避免使用 ``ChronoLocalDate``**，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有 12 个月，如果是中国农历中包含了闰月，一年有可能是 13 个月，但开发者认为是 12 个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。

**在实际开发过程中建议使用 ``LocalDate``**，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用 ``ChronoLocalDate`` 类。