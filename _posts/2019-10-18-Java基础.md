---
layout:     post 
title:      Java基础1018
subtitle:  Hash表拉链法解决冲突
date:       2019-10-18
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - Java
---

#### 散列表（HashTable）

- 也成为哈希表。是字典的一种抽象。比如说你要查一个字，是通过这个字的拼音首字母，找到这个字的页码，然后翻到那页找就可以了。这种方法直接把时间复杂度降到了常数。但是要牺牲一定的计算索引的时间。计算索引的那个函数称为哈希函数（散列函数）。如果两个不同的key算出了同一个索引，此时就要用到一定的方法来解决哈希冲突。
- 解决哈希冲突的三种方法：拉链法、开放地址法、再散列法

#### 装填因子

- 什么是装填因子？比如定义16的散列空间，存放了12个关键字 那么此时装填因子α=0.75 即，装填因子表示hash表中存放元素的填满程度。
- 为啥装填因子越小越好？打个比方，房间大小一定，住的人越少越舒坦。参考原因如下图
- 

#### 哈希函数

- 哈希函数一般具有以下特点：
   - 相等的key产生相等的哈希值
   - 计算简单方便
   - 哈希值分布均匀（若过度集中，则容易使效率降到O(n)）

#### 哈希冲突

- 若两个不相等的key产生了相等的哈希值，这时就产生了哈希冲突

#### 拉链法

- Java标准库的HashMap基本上就是拉链法实现的。拉链法的实现比较简单，将链表和数组结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加入到链表中即可。
- ![拉链法](https://github.com/Jokerboozp/Jokerboozp.github.io/raw/master/img/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81jpg.jpg)
- **实现步骤**
   - 得到一个key
   - 计算key的hashvalue
   - 根据hashvalue值定位到data[hashValue]。（data[hashValue]是一条链表）
   - 若data[hashValue]为空则直接插入
   - 不然则添加到链表末尾
- 需要注意的是，哈希函数必须保证哈希值的均匀分布，若全部集中在一条链表中，则时间复杂度和顺序链表相同。
- 还有一点是数组的大小，若你能估计数据的大小，则直接指定即可，否则就需要动态扩充数组

#### 利用一个不会动态开辟空间的静态哈希表做一个简单例子

```java
import java.util.Iterator;
import java.util.LinkedList;
 
interface HashFunctionHost {
    //接口约定根据index确定的hash值
    public <K,V> double hashFunction(HashTable<K,V> hashTable,K x);
}
public class HashTable<K, V> {
    public static class Entry<K, V>{
        private K key;
        private V value;
        public Entry(K key, V value){
            this.key = key;
            this.value = value;
        }
        public K getKey(){
            return key;
        }
        public V getValue(){
            return value;
        }
    }
    private LinkedList<Entry<K,V>>[] elements;
    private HashFunctionHost hashFunctionHost;
    private int capacity;
    public static final int DEFAULT_SIZE = 10;
    public static final HashFunctionHost DEFAULT_HASH_FUNCTION_HOST = new DivisionHashFunctionHost();
    @SuppressWarnings("unchecked")
    public HashTable(int size, HashFunctionHost hashFunctionHost){
        elements = new LinkedList[size];
        for(int i = 0 ; i < size ; i++)
            elements[i] = new LinkedList<Entry<K,V>>();
        this.hashFunctionHost = hashFunctionHost;
        capacity = 0;
    }
    public HashTable() {
        this(DEFAULT_SIZE, DEFAULT_HASH_FUNCTION_HOST);
    }
    private Entry<K,V> getEntry(K key){
        int index = (int) hashFunctionHost.hashFunction(this, key);
        Iterator<Entry<K, V>> iterator = elements[index].iterator();
        while(iterator.hasNext()){
            //找到了重复的key则直接修改entry中key对应的value
            Entry<K, V> temp = iterator.next();
            if(key.equals(temp.getKey())){
                return temp;
            }
        }
        return null;
    }
    public void put(K key ,V value){
        int index = (int) hashFunctionHost.hashFunction(this,key);
        Entry<K, V> newEntry = new Entry<K,V>(key,value);
        //没有哈希冲突
        if(elements[index].size()==0){
            elements[index].add(newEntry);
            capacity++;
        }
        //发生了哈希碰撞则需要遍历链表判断k值是不是已经存在了
        else{
            Entry<K,V> entry = getEntry(key);
            if(entry != null){
                entry.value = value;
                return;
            }
            //执行到这里说明没有发现重复的key 插在链表头部
            elements[index].addFirst(newEntry);
        }
    }
    public boolean delete(K key){
        int index = (int) hashFunctionHost.hashFunction(this, key);
        Iterator<Entry<K, V>> iterator = elements[index].iterator();
        while(iterator.hasNext()){
            Entry<K, V> entry = iterator.next();
            if(entry.getKey()==key){
                iterator.remove();
                return true;
            }
        }
        return false;
    }
    public V get(K key){
        Entry<K, V> entry = getEntry(key);
        if(entry == null)
            return null;
        return entry.getValue();
    }
    public int bucketNum(){
        return elements.length;
    }
    public int size(){
        return capacity;
    }
}
```

- **在上述代码中需要注意：**
   - 首先对于一个哈希表，我们可以自己传入一个哈希函数来完成我们的映射，但是Java不提供函数指针。这时候我们可以使用一个宿主类来包含这个我们想要传递的方法，通过传递宿主类来起传递方法的作用，也就是上述代码中的接口HashFunctionHost的实现类。
   - 在遍历数组中的链表的时候，我们不要使用for循环加上链表的get()方法，而是使用Iterator。看底层源码我们就会发现get()方法实际上会从头遍历一遍链表，知道找到对应元素，也就是说我们会做很多无用遍历。相反Iterator就不是这样，对于访问Iterator下一个元素的复杂度是O(1)
   - 我们在put的时候有三种情况，分别是**没有哈希冲突，直接插入；有哈希冲突，但是没有相同的key，插入到链表头部；有哈希冲突，而且存在相同key，我们就需要修改那个key对应的value**
   - 在比较key的时候使用equals而不是`==`，equals比较的是值，`==`比较的是内存地址。如果我们想在key值相等的时候就对value做出替换，那么我们就要使用equals了，并且要对存入哈希表的对象的equals方法进行重写