---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partB(2)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-10 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

### 练习7

给中断向量T_SYSCALL编写一个中断处理函数。你需要去编辑kern/trapentry.S和kern/trap.c中的trap_init()函数。你也需要去修改trap_dispatch()函数，使他能够通过调用syscall()（在kern/syscall.c中定义的）函数处理系统调用中断。最终你需要去实现kern/syscall.c中的syscall()函数。确保这个函数会在系统调用号为非法值时返回-E_INVAL。你应该充分理解lib/syscall.c文件。我们要处理在inc/syscall.h文件中定义的所有系统调用。

在内核下运行user/hello程序。它应该在控制台中打印“hello, world”，然后在用户模式中导致页面错误。

内核态的系统调用：此时调用了一个系统调用，比如 sys_cputs 函数时，此时不会触发中断，那么系统会直接执行定义在 lib/syscall.c 文件中的 sys_cputs，我们可以看一下这个文件，可以发现这个文件中定义了几个比较常用的系统调用，包括 sys_cputs, sys_cgetc 等等。我们还会发现他们都是统一调用一个 syscall 函数，通过这个函数的代码发现其实它是执行了一个汇编指令。所以最终是这个函数完成了系统调用。

而我们要实现的，是用户态的系统调用，首先有一个软中断，所以我们要编写一个中断处理函数，在kern/trapentry.S中声明它：

`TRAPHANDLER_NOEC(handler48, T_SYSCALL)` 

然后在trap.c中声明声，门的DPL定义为3：

`SETGATE(idt[T_SYSCALL], 0, GD_KT, handler48, 3); `

当系统发生调用中断时，就可以捕捉到这个中断，然后调用_alltraps代码块，来到trap()函数然后进入trap_dispatch函数，在这个函数中，我们要实现对syscall的调用。

在trap_dispatch()中判断中断号如果是T_SYSCALL，调用定义在kern/syscall.c中的syscall()函数，并将syscall()保存的返回值保存到tf->tf_regs.reg_eax等将来恢复到eax寄存器中。

```c
static void
trap_dispatch(struct Trapframe *tf)
{
	// Handle processor exceptions.
	// LAB 3: Your code here.
	if (tf->tf_trapno == T_PGFLT) {
        	return page_fault_handler(tf);
    	}   

    	if (tf->tf_trapno == T_BRKPT) {
        	return monitor(tf);
    	}   
	if (tf->tf_trapno == T_SYSCALL) {  //如果是系统调用，从寄存器中取出系统调用号和五个参数，传给kern/syscall.c中的syscall()，并将返回值保存到tf->tf_regs.reg_eax
        	tf->tf_regs.reg_eax = syscall(
            		tf->tf_regs.reg_eax,
            		tf->tf_regs.reg_edx,
            		tf->tf_regs.reg_ecx,
            		tf->tf_regs.reg_ebx,
            		tf->tf_regs.reg_edi,
            		tf->tf_regs.reg_esi
        	);  
        	return;
 	}   
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
	if (tf->tf_cs == GD_KT)
		panic("unhandled trap in kernel");
	else {
		env_destroy(curenv);
		return;
	}
}
   
```

修改kern/syscall.c中的syscall()函数，使能处理定义在inc/syscall.h中的所有系统调用。

```c
int32_t
syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.
	
	panic("syscall not implemented");
	switch (syscallno) {
    		case SYS_cputs:
        		sys_cputs((char *)a1, a2);
        		return 0;
    		case SYS_cgetc:
        		return sys_cgetc();
    		case SYS_getenvid:
        		return sys_getenvid();
    		case SYS_env_destroy:
        		return sys_env_destroy(a1);
    		default:
        		return -E_INVAL;
    		}
	
}
```

现在回顾一下系统调用的完成流程：以user/hello.c为例，其中调用了cprintf()，注意这是lib/print.c中的cprintf，该cprintf()最终会调用lib/syscall.c中的sys_cputs()，sys_cputs()又会调用lib/syscall.c中的syscall()，该函数将系统调用号放入%eax寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令int 0x30，发生中断后，去IDT中查找中断处理函数，最终会走到kern/trap.c的trap_dispatch()中，我们根据中断号0x30，又会调用kern/syscall.c中的syscall()函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用kern/print.c中的cprintf()函数，该函数最终调用kern/console.c中的cputchar()将字符串打印到控制台。当trap_dispatch()返回后，trap()会调用`env_run(curenv);`，该函数前面讲过，会将curenv->env_tf结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。

### 用户模式启动

用户程序在lib/entry.S的顶部开始运行。经过一些设置之后，这段代码调用lib/libmain.c中的libmain()。我们修改libmain()来初始化全局指针thisenv，使其指向envs[]数组中的环境结构Env。

然后，libmain()调用umain，在hello程序中，它位于user/hello.c中。注意，在打印“hello, world”之后，它尝试访问thisenv->env_id。这就是它之前出现故障的原因。已经正确地初始化了thisenv，它应该不会出错。如果它仍然出错，可能还没有映射UENVS区域的用户可读部分(回到pmap.c的A部分;这是我们第一次真正使用UENVS区域)。

### 练习8

将所需的代码添加到用户库中，然后引导内核。你应该看到user/hello打印“hello, world”，然后打印“i am environment 00001000”。然后，用户/hello尝试通过调用sys_env_destroy()来“退出”(参见lib/libmain.c和lib/exit.c)。因为内核目前只支持一个用户环境，所以它应该报告它已经破坏了唯一的环境，然后放入内核监视器。

`thisenv = &envs[ENVX(sys_getenvid())];`

然后我们重新make一下：

```
[00000000] new env 00001000
Incoming TRAP frame at 0xefffffbc
Incoming TRAP frame at 0xefffffbc
hello, world
Incoming TRAP frame at 0xefffffbc
i am environment 00001000
Incoming TRAP frame at 0xefffffbc
[00001000] exiting gracefully
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
Welcome to the JOS kernel monitor!
```

得到user_hello的输出