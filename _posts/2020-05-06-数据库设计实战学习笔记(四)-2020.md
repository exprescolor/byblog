---
layout:     post                        # 使用的布局（不需要改）
title:      数据库设计实战学习笔记(四)              # 标题
subtitle:   常见问题与企业级解决  # 副标题
date:       2020-05-06                  # 时间
author:     AhogeK                      # 作者
header-img:  https://tr3.cbsistatic.com/hub/i/r/2016/08/02/ffb48ac0-b355-4aec-b814-04c79e1e1bfd/resize/1200x/292c4adbf288356b843876804b244d69/mysqlhero.jpg    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - MySQL
    - 慕课学习笔记
---
### 主键用数字还是UUID？
#### 什么是UUID？
* UUID 是通过唯一识别码的缩写，其目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。
  * ![UUID](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2017-59-14.png)
  * ```sql
	# 生成UUID UUID()
	SELECT UUID();
	```

#### 为什么有人想要使用UUID？
* 在数据库集群中，为了避免每个MySQL各自生成的主键产生重复，所以有人考虑采用UUID方式

#### UUID主键的好处
* 使用UUID，分布式生成主键，降低了全局节点的压力，使得主键生成速度更快
* 使用UUID生成的主键值全局唯一
* 跨服务器合并数据很方便

#### UUID主键的缺点
* UUID占用16个字节，比4字节的INT类型和8字节的BIGINT类型更加占用存储空间
* UUID是字符串类型，查询速度很慢
* UUID不是顺序增长，作为主键，数据写入IO随机性很大

#### 主键自动增长的优点
* INT和BIGINT类型占用存储空间较小
* MySQL检索数字类型速度远快过字符串
* 主键值是自动增长的，所以IO写入连续性较好

#### 分布式环境下的主键自动增长
**虽然使用UUID在分布式环境下可以做到主键唯一，但其实可以通过中间件来保证主键自增长的唯一性**
![MyCat](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2018-12-11.png)

**无论什么场合，都不推荐使用UUID作为数据表的主键**

### 如何在线修改表结构？
#### 在线修改表结构必须慎重
* 在业务系统运行的过程中随意删改字段，会造成重大事故
* 常规的做法是业务停机，维护表结构
* 但是不影响正常业务的表结构是允许在线修改的

#### ALTER TABLE修改表结构的弊病
* 由于修改表结构是表级锁，因此在修改表结构时，影响表写入操作
* 如果修改表结构失败，必须还原表结构，所以耗时更长
* 大数据表记录多，修改表结构锁表时间很久 

#### 使用PerconaTookit工具
* Percona公司提供了维护MySQL的PerconaTookit工具包
* pt-online-schema-change可以完成在线修改表结构

#### 在线修改表结构的原理
![schema-change](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2018-30-53.png)

#### 安装PerconaTookit依赖包
*因为会与MySQL8发生冲突，所以建议在新环境下安装*
* 安装第三方依赖包
  * ```shell
	yum install -y perl-DBI
	yum install -y perl-DBD-mysql
	yum install -y perl-IO-Socket-SSL
	yum install -y perl-Digest-MD5
	yum install -y perl-TermReadKey
	```

#### 安装PerconaTookit工具
[PerconaTookit](http://repo.percona.com/tools/yum/release/7/RPMS/x86_64//)
```shell
rpm -ivh *.rpm
```
percona-tookit/percona-tookit-debuginfo

#### pt-online-schema-change参数
``pt-online-schema-change OPTIONS DSN``
![参数](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2018-59-42.png)

* 把客户收货地址表中的name字段改成VARCHAR(20)
  * ```shell
  	pt-online-schema-change --host=192.168.50.228 --port=3306 --user=root --password=123456 --charset=utf8 --alter "MODIFY name VARCHAR(20) NOT NULL COMMENT '收货人'" D=neti,t=t_customer_address --print --execute
	```
	因为percona用的是老的连接方式，MySQL8需要修改认证方式
	```sql
	ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
	ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
	```

### 订单号和流水号
#### 订单号和流水号的区别
* 订单号既是订单的唯一编号，而且经常被用来检索，所以应当是数字类型的主键
* 流水号是打印在购物单据上的字符串，便于阅读，但是不用做查询
![流水号设计](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-07%2000-06-06.png)

*通过JAVA生成流水号*
```java
public class Demo1 {
	public static String createOrderCode(String type, String organizationId, String spgId, String date) {
		StringBuffer buffer = new StringBuffer();
		buffer.append(type);
		buffer.append(organizationId);
		buffer.append(spgId);
		buffer.append(date);
		ThreadLocalRandom.current().ints(0,9).limit(10).forEach((one) -> {
			buffer.append(one);
		});
		return buffer.toString();
	}
	
	public static void main(String[] args) {
		String createOrderCode = createOrderCode("S", "000012", "11002", "20200506");
		System.out.println(createOrderCode);
	}
}
```

### 逻辑删除还是物理删除
#### 物理删除
* 物理删除就是用DELETE、TRUNCATE、DROP语句删除数据
* 物理删除是把数据从硬盘中删除，可以释放存储空间，缩小数据表的体积，对性能提升有帮助

#### 物理删除的代价
* 由于物理删除是真删除，所以数据恢复起来难度很大

![数据恢复方法](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-07%2002-05-42.png)

* 物理删除会造成主键的不连续，导致分页查询变慢
```sql
SELECT ... FROM ... LIMIT 1000,20;
SELECT ... FROM ... WHERE id>=1000 AND id<=1020;
```

#### 什么样的数据不适合物理删除
* 核心业务表的数据不建议做物理删除，只做状态变更。比如订单作废、账号禁用、优惠券作废等等。
* 既不删除数据，又能缩小数据表体积，可以把记录转移到历史表

#### 逻辑删除
* 逻辑删除就是在数据表添加一个字段(is_deleted),用字段值标记该数据已经逻辑删除，查询的时候跳过这些数据
  * ``SELECT ... FROM .... WHERE is_deleted=0``
* 核心业务数据表，必须要采用逻辑删除

*表克隆*
``CREATE TABLE t_user_history LIKE t_user;``

### 千万记录，如何快速分页
#### 常用的分页查询SQL
通过JAVA程序生成一个10000000条数据的txt文件

```java
public class Demo2 {
	public static void main(String[] args) {
		try {
			FileWriter w = new FileWriter("/home/ahogek/1.txt");
			BufferedWriter bw = new BufferedWriter(w);
			for (int i = 1; i <= 10000000; i++) {
				String uuid = UUID.randomUUID().toString();
				bw.write(i + "," + uuid + "\n");
			}
			bw.close();
			w.close();
			System.out.println("执行完毕");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

随后导入至库中,通过sql分别分页查询，可以清晰感受到数据量越大，查询越慢

```sql
SELECT id,val FROM t_test LIMIT 100,10;
SELECT id,val FROM t_test LIMIT 10000,10;
SELECT id,val FROM t_test LIMIT 1000000,10;
SELECT id,val FROM t_test LIMIT 5000000,10;
SELECT id,val FROM t_test LIMIT 9000000,10;
```

#### 优化方法
* 利用主键索引来加速分页查询
  * ```sql
  	SELECT * FROM t_test WHERE id>=5000000 LIMIT 100;
	SELECT * FROM t_test WHERE id>=5000000 AND id<=5000000 + 100;
	```

#### 如果主键值不连续，怎么分页？
* 使用逻辑删除，不会造成主键不连续
* 利用主键索引加速，再做表连接查询

```sql
SELECT t.id, t.name FROM t_test t JOIN (SELECT id FROM t_test LIMIT 5000000,100) tmp ON t.id = tmp.id;
```

* 业务上限定不可以查询早期数据

### 读多写少和读多写多
#### 读多写少的业务场景
* 普遍来说，绝大多数系统都是读多写少的

#### 写多读少的业务场景
* 滴滴的用户司机的位置信息的数据实时写入
* 大学食堂刷卡系统

#### 写多读少的解决方案
* 如果是低价值的数据，可以采用NoSQL数据库来存储这些数据
* NoSQL没有抛弃了复杂了的表结构和约束，数据的写入速度很快
* 如果是高价值的数据，可以用TokuDB来保存
* TokuDB的写入速度是InnoDB的9～20倍

#### 写多读多的业务场景
* 聊天软件的离线数据

#### 数据库集群方案缺点
* 数据库集群的读写速度低于单节点数据库实例

#### 数据库集群方案优点
* 数据库集群能支持更大规模的并发访问，并且存放更多的数据

### 删改数据如何避免锁表
#### 什么是锁机制
* InnoDB采用的是行级锁，删改数据的时候，MySQL会锁住记录

#### 共享锁和排它锁
* 行级锁分为共享锁（S锁）和排它锁（X锁）
* 共享锁和排他锁，都不允许其他事务执行写操作，但是可以读数据
* 排它锁不允许对数据再另行加锁

#### 共享锁
* 只有serializable事务隔离级别，才会给数据读取添加共享锁
  * ``SELECT ... FROM ... LOCK IN SHARE MODE;``
* 添加了共享锁，其他事务只能读取加锁数据，而不能修改和删除

#### 排它锁
* MySQL默认会给添加、修改和删除记录，设置排它锁
  * ``SELECT ... FROM ... FOR UPDATE;``

#### 如何减少并发操作的锁冲突
* 把复杂的SQL语句，拆分成多条简单的SQL语句

如果系统上线了，怎么维护表结构？
* 不影响业务的维护操作可以在线执行，先做好备份
* 影响业务的维护操作，要使用PerconaToolkit工具

系统内部的业务图片是怎么存储的？
* 使用图床服务器：Nginx或者云存储
* 使用MongoDB的GridFS搭建集群图床服务器

系统的负载怎么样？
* 读多写少的方案：MySQL+NoSQL
* 写多读少的方案：MySQL+TokuDB

数据表用逻辑删除还是物理删除？
* 使用逻辑删除，定时归档history表

数据记录很多的时候，如何对分页语句优化？
* 先用主键索引加速，然后用表连接获取具体数据

怎么避免并发操作的时候，数据不一致的问题
* 使用乐观锁机制

### 如何实现商品秒杀？
#### 商品秒杀过程中出现的超售现象
* 超售现象就是卖出了超过预期数量的商品

#### 数据库为什么会出现超售现象？
![超售](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-13%2013-03-23.png)

#### 怎么预防数据库超售现象？
* 设置数据库事务的隔离级别Serializable
* 在数据表上设置乐观锁字段
  * >很多Java开发者，持久层会选择MyBatis，如果想使用乐观锁，可以先用Maven引用一下MyBatis Plus插件，然后利用该插件内置的乐观锁机制就能实现乐观锁功能了，当然也需要数据库对应的版本号字段。

#### 程序实现乐观锁
![乐观锁](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-14%2006-15-05.png)

什么表需要设置乐观锁？
* 出现同时修改同一条记录的业务，相应的数据表要设置乐观锁
* 不会出现同时修改同一记录的数据表就不需要设置乐观锁

#### 利用Redis防止超售
#### Redis介绍
* Redis是开源免费的NoSQL数据库产品，它使用内存缓存数据
* Redis读写性能2万/秒，MySQL读性能5千/秒，写入3千/秒
* Redis是单线程的NoSQL数据库，但是采用的是非阻塞执行

#### Redis中的超售现象
* 因为Redis的单线程是非阻塞执行的，所以并发修改数据容易产生超售的结果

#### Redis避免超售现象
* Redis引入了事务机制（批处理），一次性把多条命令传递给Redis执行，这就避免了其他客户端中间插队，出现超售现象。 

#### 下载安装Redis程序
[下载地址：https://redis.io/download](https://redis.io/download)下载stable最新稳定版**在编译redis6.0.1之前需要升级gcc的版本，默认情况yum安装的gcc版本是4.8.5，由于版本过低，在编译时会报错误**

#### 安装Redis步骤
* 把Redis的压缩包上传到CentOS，然后执行解压缩
* 安装GCC编译器
  * ``yum install gcc -y``
* 进入Redis目录，执行编译
  * ```shell
	cd [redis解压后目录]
	make
	```
* 进入src目录，执行安装命令
  * ``cd src && make install``
* 启动redis程序
  * ``./redis-server ../redis.conf``
* 修改redis.conf文件
  * ```shell
	bind 0.0.0.0 #允许任何IP访问Redis
	daemonize yes #以后台进程运行Redis
	protected-mode no #关闭保护功能
	requirepass abc123456 #设置访问密码
	```
* 开放Redis需要关闭SELINUX以及开启防火墙的80端口和6379端口
  * ```shell
	firewall-cmd --zone=public --add-port=80/tcp
	firewall-cmd --zone=public --add-port=6379/tcp
	firewall-cmd --reload
	```
  * ``--permanent``参数可以让端口开发持续有效

*RDM*是现在较好的Redis图形连接工具

#### Redis事务机制
![redis事务机制](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-14%2007-36-40.png)

#### 如何保持事务的一致性
* 为了保证事务的一致性，在开启事务之前必须要用WATCH命令监视要操作的记录。
  * ``redis > WATCH kill_num kill_user``

#### 如何开启事务？
* 利用MULTI命令可以开启一个事务
  * ``redis > MULTI``
* 开启事务后的所有操作都不会立即执行，只有执行EXEC命令的时候才会批处理执行
  * ```shell
	redis > DECR kill_num
	redis > RPUSH kill_user 9502
	redis > EXEC
	```

#### Maven引用Jedis
* 在pom.xml文件中添加下面内容，引入Jedis依赖包
  * ```xml
	<dependency>
		<groupId>redis.clients</groupId>
		<artifactId>jedis</artifactId>
		<version>3.0.1</version>
	</dependency>
	```

#### 模擬redis超售

```java
public class Application {
	
	public static ThreadPoolExecutor pool = new ThreadPoolExecutor(10, 100, 10, TimeUnit.SECONDS, 
			new LinkedBlockingDeque<Runnable>());
	
	public static void main(String[] args) {
		Jedis jedis = new Jedis("192.168.50.197", 6379);
		jedis.auth("abc123456");
		jedis.select(0);
		jedis.set("kill_num", "50");
		jedis.del("kill_user");
		jedis.close();
		for (int i = 0; i < 1000; i++) {
			pool.execute(new KillTask());
		}
	}
}
```

```java
public class KillTask implements Runnable {

	@Override
	public void run() {
		Jedis jedis = new Jedis("192.168.50.197", 6379);
		jedis.auth("abc123456");
		jedis.select(0);
		int num = Integer.parseInt(jedis.get("kill_num"));
		if (num > 0) {
			jedis.watch("kill_num", "kill_user");
			Transaction transaction = jedis.multi();
			transaction.decr("kill_num");
			transaction.rpush("kill_user", "9527");
			transaction.exec();
		} else {
			Application.pool.shutdown();
		}
		jedis.close();
	}

}
```

### 什么是存储过程?
#### 数据库编程
SQL脚本通过编译可以编译成存储过程,函数与触发器.

* 存储过程是一个编译后的SQL脚本集合,可以单独调用,但是不能用SQL语句中
  * ![存储过程](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-14%2007-36-40.png)

#### 存储过程的优点
* 存储过程是编译过的SQL脚本,所以执行速度非常快
* 实现了SQL编程,可以降低锁表的时间和锁表的范围
* 对外封装了表结构，提升了数据库的安全性

#### 编写存储过程案例
* 编写存储过程，根据部门名称，查询部门用户信息

```sql
CREATE DEFINER=`root`@`%` PROCEDURE `p1`(IN `p_dname` varchar(20))
BEGIN
	SELECT e.id, e.ename, e.sex, e.married, j.job 
    FROM t_emp e JOIN t_dept d ON e.dept_id=d.id
    JOIN t_job j ON e.job_id=j.id
    WHERE d.dname=p_dname;
END
```

调用

```sql
call neti.p1("零售部");
```

* 编写存储过程，插入实习员工数据的时候，如果是男性，就分配到网商部实习；如果是女性，就分配到零售部实习

```sql
CREATE DEFINER=`root`@`%` PROCEDURE `p2`(IN p_wid varchar(20), IN p_ename varchar(20), IN p_sex char(1), 
	IN p_married boolean, IN p_education tinyint, IN p_tel varchar(11))
BEGIN
  DECLARE dept_id INT;
  CASE
    WHEN p_sex="女" THEN
	  SET dept_id=3;
    ELSE
      SET dept_id=4;
  END CASE;
  INSERT INTO t_emp(wid,ename,sex,married,education,tel,dept_id,hiredate,job_id,`status`,is_deleted)
  VALUES(p_wid,p_ename,p_sex,p_married,p_education,p_tel,dept_id,CURDATE(),9,1,0);
END
```

```sql
call neti.p2('TE0025', 'Jonah', '女', false, 1, '18854220236');
```

### 什么是函数
存储过程可以不需要返回值，而函数必须要有返回值，且是一个数据

#### 编写计算个税函数
* 个税计算公式=（收入-3500）x 税率 - 扣除数

```sql
CREATE DEFINER=`root`@`%` FUNCTION `f1`(salary DECIMAL) RETURNS decimal(10,2)
BEGIN
  DECLARE temp DECIMAL;
  DECLARE tax DECIMAL;
  SET temp=salary-3500;
  CASE
    WHEN temp<=0 THEN
      SET tax=0;
	WHEN temp>0 AND temp<=1500 THEN
      SET tax=temp*0.03-0;
	WHEN temp>1500 AND temp<=4500 THEN
      SET tax=temp*0.10-105;
	WHEN temp>4500 AND temp<=9000 THEN
      SET tax=temp*0.20-555;
	WHEN temp>9000 AND temp<=35000 THEN
      SET tax=temp*0.25-1005;
	WHEN temp>35000 AND temp<= 55000 THEN
      SET tax=temp*0.30-2755;
	WHEN temp>55000 AND temp<=8000 THEN
	  SET tax=temp*0.35-5505;
	ELSE
      SET tax=temp*0.45-13505;
  END CASE;
RETURN tax;
END
```

调用
``select neti.f1(10000);``

### 什么是触发器
#### 编写触发器
* 编写触发器，修改部门编号，同步更新该部门员工的dept_id字段

```sql
CREATE DEFINER=`root`@`%` TRIGGER `t1` AFTER UPDATE ON `t_dept` FOR EACH ROW BEGIN
UPDATE t_emp SET dept_id=NEW.id WHERE dept_id=OLD.id;
END
```

* 编写触发器，当删除部门之后，删除这个部门的员工记录

```sql
CREATE DEFINER=`root`@`%` TRIGGER `t2` AFTER DELETE ON `t_dept` FOR EACH ROW BEGIN
DELETE FROM t_emp WHERE dept_id=OLD.id;
END
```

### 为什么放弃存储过程，触发器，自定义函数
* 在数据库集群场景里，因为存储过程、触发器和自定义函数，都是在本地数据库执行，所以无法兼容集群场景

### 如何避免偷换交易中的商品信息
#### 如何避免篡改商品信息
* B2B电商平台，通常采用保存历次商品修改信息、降低搜索排名
* B2C电商平台，只需要保存历次商品修改信息即可

#### 如何保存商品历次修改信息？
* 商品信息存储在SKU和SPU数据表，应该如何存储历次修改信息？
  * ![img](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-14%2014-29-35.png)

#### 如何抵御XSS攻击
* XSS(跨站脚本)攻击，是让浏览器渲染DOM的时候意外的执行了恶意JS代码
* XSS攻击的原理是在网页中嵌入一个恶意脚本
  * ``<img src="null" onerror='alert(document.cookie)' />``

#### XSS的危险之处
* 毕竟浏览器是一个沙箱环境，JavaScript不可以读写本地文件、不可以连接数据库、不可以创建线程
* XSS不会对系统造成破坏，但是却可以盗用账户信息
* 通过HTML格式邮件的方式，发送恶意脚本

#### 内容转义
* AntiSamy是开源的Java类库，可以用来过滤XSS恶意代码
  * ```xml
	<dependency>
		<groupId>org.owasp.antisamy</groupId>
		<artifactId>antisamy</artifactId>
		<version>1.5.9</version>
	</dependency>
	```