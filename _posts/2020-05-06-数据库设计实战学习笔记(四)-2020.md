---
layout:     post                        # 使用的布局（不需要改）
title:      数据库设计实战学习笔记(四)              # 标题
subtitle:   常见问题与企业级解决  # 副标题
date:       2020-05-06                  # 时间
author:     AhogeK                      # 作者
header-img:  https://tr3.cbsistatic.com/hub/i/r/2016/08/02/ffb48ac0-b355-4aec-b814-04c79e1e1bfd/resize/1200x/292c4adbf288356b843876804b244d69/mysqlhero.jpg    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - MySQL
    - 慕课学习笔记
---
### 主键用数字还是UUID？
#### 什么是UUID？
* UUID 是通过唯一识别码的缩写，其目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。
  * ![UUID](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2017-59-14.png)
  * ```sql
	# 生成UUID UUID()
	SELECT UUID();
	```

#### 为什么有人想要使用UUID？
* 在数据库集群中，为了避免每个MySQL各自生成的主键产生重复，所以有人考虑采用UUID方式

#### UUID主键的好处
* 使用UUID，分布式生成主键，降低了全局节点的压力，使得主键生成速度更快
* 使用UUID生成的主键值全局唯一
* 跨服务器合并数据很方便

#### UUID主键的缺点
* UUID占用16个字节，比4字节的INT类型和8字节的BIGINT类型更加占用存储空间
* UUID是字符串类型，查询速度很慢
* UUID不是顺序增长，作为主键，数据写入IO随机性很大

#### 主键自动增长的优点
* INT和BIGINT类型占用存储空间较小
* MySQL检索数字类型速度远快过字符串
* 主键值是自动增长的，所以IO写入连续性较好

#### 分布式环境下的主键自动增长
**虽然使用UUID在分布式环境下可以做到主键唯一，但其实可以通过中间件来保证主键自增长的唯一性**
![MyCat](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2018-12-11.png)

**无论什么场合，都不推荐使用UUID作为数据表的主键**

### 如何在线修改表结构？
#### 在线修改表结构必须慎重
* 在业务系统运行的过程中随意删改字段，会造成重大事故
* 常规的做法是业务停机，维护表结构
* 但是不影响正常业务的表结构是允许在线修改的

#### ALTER TABLE修改表结构的弊病
* 由于修改表结构是表级锁，因此在修改表结构时，影响表写入操作
* 如果修改表结构失败，必须还原表结构，所以耗时更长
* 大数据表记录多，修改表结构锁表时间很久 

#### 使用PerconaTookit工具
* Percona公司提供了维护MySQL的PerconaTookit工具包
* pt-online-schema-change可以完成在线修改表结构

#### 在线修改表结构的原理
![schema-change](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2018-30-53.png)

#### 安装PerconaTookit依赖包
*因为会与MySQL8发生冲突，所以建议在新环境下安装*
* 安装第三方依赖包
  * ```shell
	yum install -y perl-DBI
	yum install -y perl-DBD-mysql
	yum install -y perl-IO-Socket-SSL
	yum install -y perl-Digest-MD5
	yum install -y perl-TermReadKey
	```

#### 安装PerconaTookit工具
[PerconaTookit](http://repo.percona.com/tools/yum/release/7/RPMS/x86_64//)
```shell
rpm -ivh *.rpm
```
percona-tookit/percona-tookit-debuginfo

#### pt-online-schema-change参数
``pt-online-schema-change OPTIONS DSN``
![参数](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-06%2018-59-42.png)

* 把客户收货地址表中的name字段改成VARCHAR(20)
  * ```shell
  	pt-online-schema-change --host=192.168.50.228 --port=3306 --user=root --password=123456 --charset=utf8 --alter "MODIFY name VARCHAR(20) NOT NULL COMMENT '收货人'" D=neti,t=t_customer_address --print --execute
	```
	因为percona用的是老的连接方式，MySQL8需要修改认证方式
	```sql
	ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
	ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
	```

### 订单号和流水号
#### 订单号和流水号的区别
* 订单号既是订单的唯一编号，而且经常被用来检索，所以应当是数字类型的主键
* 流水号是打印在购物单据上的字符串，便于阅读，但是不用做查询
![流水号设计](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/Screenshot%20from%202020-05-07%2000-06-06.png)

*通过JAVA生成流水号*
```java
public class Demo1 {
	public static String createOrderCode(String type, String organizationId, String spgId, String date) {
		StringBuffer buffer = new StringBuffer();
		buffer.append(type);
		buffer.append(organizationId);
		buffer.append(spgId);
		buffer.append(date);
		ThreadLocalRandom.current().ints(0,9).limit(10).forEach((one) -> {
			buffer.append(one);
		});
		return buffer.toString();
	}
	
	public static void main(String[] args) {
		String createOrderCode = createOrderCode("S", "000012", "11002", "20200506");
		System.out.println(createOrderCode);
	}
}
```

### 逻辑删除还是物理删除
#### 物理删除
* 物理删除就是用DELETE、TRUNCATE、DROP语句删除数据
* 物理删除是把数据从硬盘中删除，可以释放存储空间，缩小数据表的体积，对性能提升有帮助

#### 物理删除的代价
* 由于物理删除是真删除，所以数据恢复起来难度很大

![数据恢复方法](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/
Screenshot%20from%202020-05-07%2002-05-42.png)

* 物理删除会造成主键的不连续，导致分页查询变慢
```sql
SELECT ... FROM ... LIMIT 1000,20;
SELECT ... FROM ... WHERE id>=1000 AND id<=1020;
```

#### 什么样的数据不适合物理删除
* 核心业务表的数据不建议做物理删除，只做状态变更。比如订单作废、账号禁用、优惠券作废等等。
* 既不删除数据，又能缩小数据表体积，可以把记录转移到历史表

#### 逻辑删除
* 逻辑删除就是在数据表添加一个字段(is_deleted),用字段值标记该数据已经逻辑删除，查询的时候跳过这些数据
  * ``SELECT ... FROM .... WHERE is_deleted=0``
* 核心业务数据表，必须要采用逻辑删除

*表克隆*
``CREATE TABLE t_user_history LIKE t_user;``

### 千万记录，如何快速分页
#### 常用的分页查询SQL
通过JAVA程序生成一个10000000条数据的txt文件

```java
public class Demo2 {
	public static void main(String[] args) {
		try {
			FileWriter w = new FileWriter("/home/ahogek/1.txt");
			BufferedWriter bw = new BufferedWriter(w);
			for (int i = 1; i <= 10000000; i++) {
				String uuid = UUID.randomUUID().toString();
				bw.write(i + "," + uuid + "\n");
			}
			bw.close();
			w.close();
			System.out.println("执行完毕");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

随后导入至库中,通过sql分别分页查询，可以清晰感受到数据量越大，查询越慢

```sql
SELECT id,val FROM t_test LIMIT 100,10;
SELECT id,val FROM t_test LIMIT 10000,10;
SELECT id,val FROM t_test LIMIT 1000000,10;
SELECT id,val FROM t_test LIMIT 5000000,10;
SELECT id,val FROM t_test LIMIT 9000000,10;
```

#### 优化方法
* 利用主键索引来加速分页查询
  * ```sql
  	SELECT * FROM t_test WHERE id>=5000000 LIMIT 100;
	SELECT * FROM t_test WHERE id>=5000000 AND id<=5000000 + 100;
	```

#### 如果主键值不连续，怎么分页？
* 使用逻辑删除，不会造成主键不连续
* 利用主键索引加速，再做表连接查询

```sql
SELECT t.id, t.name FROM t_test t JOIN (SELECT id FROM t_test LIMIT 5000000,100) tmp ON t.id = tmp.id;
```

* 业务上限定不可以查询早期数据

### 读多写少和读多写多
#### 读多写少的业务场景
* 普遍来说，绝大多数系统都是读多写少的

#### 写多读少的业务场景
* 滴滴的用户司机的位置信息的数据实时写入
* 大学食堂刷卡系统

#### 写多读少的解决方案
* 如果是低价值的数据，可以采用NoSQL数据库来存储这些数据
* NoSQL没有抛弃了复杂了的表结构和约束，数据的写入速度很快
* 如果是高价值的数据，可以用TokuDB来保存
* TokuDB的写入速度是InnoDB的9～20倍

#### 写多读多的业务场景
* 聊天软件的离线数据

#### 数据库集群方案缺点
* 数据库集群的读写速度低于单节点数据库实例

#### 数据库集群方案优点
* 数据库集群能支持更大规模的并发访问，并且存放更多的数据

### 删改数据如何避免锁表
#### 什么是锁机制
* InnoDB采用的是行级锁，删改数据的时候，MySQL会锁住记录

#### 共享锁和排它锁
* 行级锁分为共享锁（S锁）和排它锁（X锁）
* 共享锁和排他锁，都不允许其他事务执行写操作，但是可以读数据
* 排它锁不允许对数据再另行加锁

#### 共享锁
* 只有serializable事务隔离级别，才会给数据读取添加共享锁
  * ``SELECT ... FROM ... LOCK IN SHARE MODE;``
* 添加了共享锁，其他事务只能读取加锁数据，而不能修改和删除

#### 排它锁
* MySQL默认会给添加、修改和删除记录，设置排它锁
  * ``SELECT ... FROM ... FOR UPDATE;``

#### 如何减少并发操作的锁冲突
* 把复杂的SQL语句，拆分成多条简单的SQL语句

如果系统上线了，怎么维护表结构？
* 不影响业务的维护操作可以在线执行，先做好备份
* 影响业务的维护操作，要使用PerconaToolkit工具

系统内部的业务图片是怎么存储的？
* 使用图床服务器：Nginx或者云存储
* 使用MongoDB的GridFS搭建集群图床服务器

系统的负载怎么样？
* 读多写少的方案：MySQL+NoSQL
* 写多读少的方案：MySQL+TokuDB

数据表用逻辑删除还是物理删除？
* 使用逻辑删除，定时归档history表

数据记录很多的时候，如何对分页语句优化？
* 先用主键索引加速，然后用表连接获取具体数据

怎么避免并发操作的时候，数据不一致的问题
* 使用乐观锁机制