---
layout:     post   				    # 使用的布局（不需要改）
title:      828-lab1-part3(3)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-31 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

### 练习12

​		修改mon_backtrace()以显示每个eip对应的函数名、源文件名和行号。在debuginfo_eip中，_STAB_*来自哪里?这个问题的答案很长;为了帮助你找到答案，这里有一些你可能想要做的事情

查看kern/kernel.ld文件__STAB_ *

运行objdump -h obj/kern/kernel

运行objdump -G obj/kern/kernel

运行gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c，然后看init.S。

查看boot loader是否将符号表作为加载内核二进制文件的一部分加载到内存中

在kern/kernel.ld文件中，有关STAB的相关代码：

```
/* Include debugging information in kernel memory */
	.stab : {
		PROVIDE(__STAB_BEGIN__ = .);
		*(.stab);
		PROVIDE(__STAB_END__ = .);
		BYTE(0)		/* Force the linker to allocate space
				   for this section */
	}
	
.stabstr : {
    PROVIDE(__STABSTR_BEGIN__ = .);
    *(.stabstr);
    PROVIDE(__STABSTR_END__ = .);
    BYTE(0)     /* Force the linker to allocate space
               for this section */
```

__STAB_BEGIN__和__STAB_END__是.stab 的开始和结束，__STABSTR_BEGIN__和__STABSTR_END__是.stabstr的开始和结束，这两个都在kern/kern.ld中定义。

执行objdump -h obj/kern/kernel：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdcycjfyxkj30lf0h9q5l.jpg)

给出了每个段的大小、加载地址、链接地址等信息。

执行objdump -G obj/kern/kernel：

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdcyezejryj30mz0fedhc.jpg)

给出了.stab节的一些信息。Symnum是符号索引，n_type是符号类型，SLINE指在text段中的行号，n_othr目前没被使用，其值固定为0，n_desc表示在文件中的行号，n_value表示地址。

运行gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c，然后看init.S，可以看到最开始加载了一堆符号表。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdcyl2bz9uj30oy0jsq65.jpg)

其中第2行是描述源文件信息的，文件名是 init.c，类型是N_SO（100），后面的desc=2表示C语言文件，.Ltext0为文件对应代码区的开始地址。

Q：通过插入对stab_binsearch的调用来查找地址的行号，完成debuginfo_eip的实现。

```
// Search within [lline, rline] for the line number stab.
// If found, set info->eip_line to the right line number.
// If not found, return -1.
//
// Hint:
//	There's a particular stabs type used for line numbers.
//	Look at the STABS documentation and <inc/stab.h> to find
//	which one.
// Your code here.
stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
	if (lline <= rline) {
   		 info->eip_line = stabs[lline].n_desc;
	} 
	else {
  	  return -1;
	}
```

​		向内核监视器添加一个backtrace命令，并扩展mon_backtrace的实现，以调用debuginfo_eip并为表单的每个堆栈帧打印一行:

```
K> backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
         kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
         kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
         kern/entry.S:70: <unknown>+0
K> 
```

每行给出堆栈框架的eip文件的文件名和该文件中的行，后面是函数名和eip从函数的第一条指令开始的偏移量(例如，monitor+106表示返回的eip是monitor开始后的106字节)。

确保将文件和函数名打印在单独的行上，以避免混淆评分脚本。

提示:printf格式字符串提供了一种简单(尽管有些晦涩)的方法来打印非空终止的字符串，就像STABS表中的那些字符串一样。printf (" %。*s"，长度，字符串)打印字符串的最大长度字符。查看printf手册页，了解其工作原理。

完整的函数：

```
int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
	// Your code here.
        int i;
	uint32_t eip;
	uint32_t* ebp = (uint32_t *)read_ebp();
	while (ebp) {
	//打印ebp,eip和五个参数
		eip = *(ebp + 1);
		cprintf("ebp %x eip %x args", ebp, eip);
		uint32_t *args = ebp + 2;
		for (i = 0; i < 5; i++) {
			uint32_t argi = args[i];
			cprintf(" %08x ", argi);
		}
		cprintf("\n");
		//打印文件名等信息
		struct Eipdebuginfo debug_info;
		debuginfo_eip(eip, &debug_info);
		cprintf("\t%s:%d: %.*s+%d\n",
			debug_info.eip_file,
			debug_info.eip_line,
			debug_info.eip_fn_namelen,
			debug_info.eip_fn_name, 
			eip - debug_info.eip_fn_addr);
		//更新ebp
		ebp = (uint32_t *) *ebp;
	}
	return 0;
}
```

函数运行效果如下：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdd5bnsruoj30os09zmzd.jpg)

make一下：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdd5afoifoj30cm04xgls.jpg)

这就是lab1的最后一道练习题。