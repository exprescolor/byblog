---
layout:     post                        # 使用的布局（不需要改）
title:      自定义注解              # 标题
subtitle:   AOP切面类监听获取到注解在类中的自定义注解上的参数值
date:       2019-12-16                # 时间
author:     AhogeK                      # 作者
header-img: img/post-bg-alibaba.jpg     # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - 学习笔记
    - AOP
---
自定义一个 @Log 日志注解

```java
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Log {
    /**
     * 模块
     */
    String title() default "";

    /**
     * 操作应用
     */
    OperApplication operApplication() default OperApplication.SYSTEM;

    /**
     * 功能
     */
    BusinessType businessType() default BusinessType.OTHER;
}
```

* @Target
    >@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。
    * 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）
    * 取值(ElementType)有：
        1. CONSTRUCTOR:用于描述构造器
        2. FIELD:用于描述符
        3. LOCAL_VARIABLE:用于描述局部变量
        4. METHOD:用于描述方法
        5. PACKAGE:用于描述包
        6. PARAMETER: 用于描述参数
        7. TYPE: 用于描述类、接口（包括注解类型）或者enum声明
* @Retention
    >@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。
    * 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）
    * 取值（RetentionPoicy）有：
        1. SOURCE:在源文件中有效（即源文件保留）
        2. CLASS:在class文件中有效（即class保留）
        3. RUNTIME:在运行时有效（即运行时保留）
* @Documented
    >@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。
* @interface
    >使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。

用于自定义注解参数的枚举类

```java
public enum BusinessType {
    /**
     * 其它
     */
    OTHER(0),

    /**
     * 新增
     */
    INSERT(1),

    /**
     * 修改
     */
    UPDATE(2),

    /**
     * 删除
     */
    DELETE(3),
    ;

    private Integer businessType;

    BusinessType(Integer businessType) { this.businessType = businessType; }

    public Integer getBusinessType() {return businessType; }
}

public enum OperApplication {

    /**
     * 后台管理
     */
    SYSTEM("后台管理"),
    ;

    private String application;

    OperApplication(String application) { this.application = application; }

    public  String getApplication() { return application; }
}
```

被注解的方法

```java
@Log(title = "字典管理", operApplication = OperApplication.SYSTEM, businessType = BusinessType.DELETE)
@DeleteMapping(value = "/delete")
@ApiOperation(value = "删除字典", notes = "删除字典")
@ApiImplicitParams({
        @ApiImplicitParam(name = "id", value = "字典id", dataType = "String", paramType = "query"),
        @ApiImplicitParam(name = "type", value = "字典type", dataType = "String", paramType = "query")
})
public RestResponse deleteDict(String id, String type) {
    sysDictService.deleteDict(id, type);
    return ResultGenerator.genSuccessResult();
}
```

切面类的获取

```java
@Aspect
@Component
public class LogAspect {

    private static final Integer SUCCESS_STATUS = 200;

    @Autowired
    private SysOperLogService sysOperLogService;

    /**
     * 声明切面
     *
     */
    @Pointcut("execution(* io.ahogek.*.controller.*.*(..))")
    private void pointCut() {}

    /**
     * 环绕通知进行日志导入
     *
     * @param joinPoint 切入点
     * @param log 日志注解
     */
    @Around(value = "pointCut() && @annotation(log)", argNames = "joinPoint, log")
    public Object methodAround(ProceedingJoinPoint  joinPoint, Log log) throws Throwable {
        SysOperLog sysOperLog = new SysOperLog();
        sysOperLog.setCreateBy(UserUtil.getUser().getId());
        sysOperLog.setCreateDate(new Date());
        sysOperLog.setOperName(UserUtil.getUser().getUserName());
        //获取 request
        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();
        sysOperLog.setOperIp(IPUtil.getIpAddress(request));
        sysOperLog.setOperApplication(log.operApplication().getApplication());
        sysOperLog.setTitle(log.title());
        sysOperLog.setBusinessType(log.businessType().getBusinessType());
        Object result = joinPoint.proceed();
        // 获取 response
        HttpServletResponse response = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getResponse();
        assert response != null;
        if (response.getStatus() == SUCCESS_STATUS) {
            sysOperLog.setStatus(0);
        } else {
            sysOperLog.setStatus(1);
        }
        sysOperLog.setSortBy(0);
        sysOperLog.setUpdateBy(UserUtil.getUser().getId());
        sysOperLog.setUpdateDate(new Date());
        if (!sysOperLogService.save(sysOperLog)) {
            throw new SysException(SysExceptionEnum.LOG_UPDATE_ERROR);
        }
        return result;
    }
```