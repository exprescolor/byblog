---
layout:     post 
title:     KMP算法
subtitle:  一道算法题的解释和深入学习
date:       2020-01-06
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - 算法
---

#### 首先，题目是一道Leetcode上标记为简单的算法题。但是自己对于算法之类的实在是不感冒，所以在我眼里他就是困难级别的，正好总结一下。但是自己从头到尾总结一遍，现在我让写依旧是写不出来，把他当作发散思维就好了，不强求。

----------------------------
给定一个haystack字符串和一个needle字符串。在haystack字符串中找出needle字符串出现的第一个位置（从0开始）。如果不存在，则返回-1
示例1：
```java
输入：haystack="hello",needle="ll"
输出：2
```
示例2：
```java
输入：haystack="aaaaa",needle="bba"
输出：-1
```
说明：
当needle是空字符串的时候我们应该返回什么值呢？对于本题而言，当needle是空字符串的时候我们应当返回0，这与C语言的strstr()以及Java的indexOf()定义相符。

---------------------------------

- 这道题的本意是让用KMP算法来解答，而非用暴力法。所以就需要先知道什么是KMP算法。

#### KMP算法

- 举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？
   - 有许多算法可以完成这个任务，KMP算法是最常用的算法之一。

- 解法示例：
- 1.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png)
   - 首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。
- 2.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png)
   - 因为B与A不匹配，搜索词再往后移
- 3.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png)
   - 就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。
- 4.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png)
   - 接着比较字符串和搜索词的下一个字符，还是相同。
- 5.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png)
   - 直到字符串有一个字符，与搜索词对应的字符不相同为止
- 6.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png)
   - 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍
- 7.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png)
   - 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率
- 8.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)
   - 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了
- 9.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png)
   - 已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值。因为 6 - 2 等于4，所以将搜索词向后移动4位。
- 10.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png)
   - 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位
- 11.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png)
   - 因为空格与A不匹配，继续后移一位。
- 12.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png)
   - 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。
- 13.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png)
   - 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。
- 14.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050114.png)
   - 下面介绍《部分匹配表》是如何产生的。
   - 首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。
- 15.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)
   - "部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。以"ABCDABD"为例，
      - "A"的前缀和后缀都为空集，共有元素的长度为0；
      - "AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；
      - "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
      - "ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
      - "ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
      - "ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；
      - "ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。
- 16.![](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png)
   - "部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）。搜索词移动的时候，第一个"AB"向后移动4位（字符串长度-部分匹配值），就可以来到第二个"AB"的位置。

#### 题解

- 首先用一个图示来说明一些定义：
- ![](https://pic.leetcode-cn.com/c43d65b60e24b1a4abd6b3593a7c2dd413107fa045e900d4f204b3ce049a133a-file_1570527731109)
- **1.怎么处理匹配失败的信息**
   - txt 串的已遍历字符，长度太长，缓存一份自然是不现实的，舍去；
   - pattern 串的已匹配字符，长度小，与 txt 串最近几个字符是已匹配的。
   - 因此，已匹配信息指 pattern 串的已匹配字符；且完整的 pattern 串是已知的，因此，我们一直掌握着一个信息：Pattern 串的匹配程度，也就是 Pattern 串的已匹配状态。
- **2.状态**
   - ![lr2KGq.png](https://s2.ax1x.com/2020/01/06/lr2KGq.png)
- **3.确定有限状态机**
   - ![lr2DsO.png](https://s2.ax1x.com/2020/01/06/lr2DsO.png)
- **4.使用有限状态机**
   - 假如我们已经构建好刚才的表 FSM（指 Finite State Machine，有限状态机简称），我们可以直接这样用

```java
int state = 0; // 匹配状态
for (int i = 0; i < strLen; i++) {
    state = FSM[state][haystack.charAt(i)];
    // 判断是否匹配到最终状态，是则返回结果
    if (state == subLen) {
        return i - subLen + 1;
    }
}
```

- **5.构建有限状态机**
   - 在确定有限状态机中，我们依据 当前状态 + 匹配字符 = 目标状态 推导出整张表，既然能手动推导，弄清楚原理让它自动生成了，所以我们来一步步搞清楚原理。abab 遇到 a 无法升级，但是却可以把 abab 看成是 ab，遇到 a 可以变成 aba，因此不需要重置，可以降级为 aba 状态。能这样做的原因是：abab 这个已匹配串中的前缀 ab 与后缀 ab 内容相同而不相等（不是同一个子字符串），就像 aba 可以视为 a，因为包含的内容相同而不相等的前后缀 a！也就是部分匹配，即前后缀内容相同而不相等，而 a 这个前缀/后缀就叫做当前状态的孪生词缀状态，因此有：当前状态 + 匹配失败字符 = 孪生词缀状态 + 匹配字符 = 目标状态（降级或重置）；所以，为构建状态机，我们需要为每一个状态找到相应的孪生词缀状态（设 X 代表孪生词缀状态），然后借助 X 判断匹配失败后是重置还是降级。我们通过构建状态机的代码来说明怎么找 X 状态；

```java
//1.声明状态机和 X；因为还没读取 pattern 串，所以默认所有目标状态都为 0；


int X = 0；//最初所有状态的孪生词缀状态是未知的，所以默认为 0；
// 除去最终状态，状态机有 pattern.length() 种输入状态，默认遇到 256 个字符。表格所有成员初始值为 0
int[][] FSM = new int[pattern.length()][256];


//2.更新状态机的每一列和更新每一个状态的孪生词缀状态。我们先默认所有字符都匹配失败，再用唯一正确的字符进行修改。

for (int i = 0; i < pattern.length(); i++){
    int match = (int)pattern.charAt(i); // 当前能成功匹配的字符
    for (int c = 0; c < 256; c++) {
        // 当前状态 + 匹配失败字符 = 孪生词缀状态 + 匹配字符 = 目标状态
        FSM[i][c] = FSM[X][c]; 
    }
    // 当前状态 + 匹配成功字符 = 升级状态
    FSM[i][match] = i + 1;

    if (i > 0) {
        /* 
         * 零或一状态是不可能有孪生词缀，因此不更新 0 状态的孪生词缀状态，
         * 但 1 状态匹配出错，匹配到第一个字符会回到 1 状态，因此需要更新。
         * 
         * 当前状态有孪生词缀状态的话，X 状态就是当前状态的前缀和后缀，
         * 当前状态遇到 match 会升级到下一个状态，X + match 一定是下一状态的后缀，
         * 
         * 如果 X 遇到 match 能升级，就表示 X + match 一定是下一个状态的前缀，那么 X + match 是下一状态的孪生词缀状态；
         * abab = aba + b；X(ab) = X(a) + b;
         * 如果无法升级，就表示 X + match 不是下一个状态的前缀，那么 X + match 就要降级或者重置状态了；
         * ababc = abab + c; X(0) = X(ab) + c;
         * 
         * 所以： 下一状态的孪生词缀状态 = 当前状态的孪生词缀状态 + 当前状态的更新字符
        */
        X = FSM[X][match];
    }
}
```

#### 整体算法

```java
public int strStr(String haystack, String needle) {
    int strLen = haystack.length(), subLen = needle.length();
    if (subLen == 0) return 0;
    if (strLen == 0) return -1;
    // 构建状态机
    int[][] FSM = new int[subLen][256];
    int X = 0, match = 0;
    for (int i = 0; i < subLen; i++) {
        match = (int) needle.charAt(i);
        for (int j = 0; j < 256; j++) {
            // 当前状态 + 匹配失败字符 = 孪生词缀状态 + 匹配字符
            FSM[i][j] = FSM[X][j]; 
        }
        FSM[i][match] = i + 1;
        if (i > 1) {
            // 下一部分匹配状态 = X + match
            X = FSM[X][match];
        }
    }
    // 匹配子串
    int state = 0;
    for (int i = 0; i < strLen; i++) {
        state = FSM[state][haystack.charAt(i)];
        if (state == subLen) {
            return i - subLen + 1;
        }
    }
    return -1;
}
```