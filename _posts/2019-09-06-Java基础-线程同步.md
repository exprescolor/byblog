---
layout:     post 
title:      Java基础0906
subtitle:   线程同步
date:       2019-09-06
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - Java
---

# Java基础

### 线程同步

- 多个线程之间进行协调的方法叫做线程同步
- 在Java语言中，引入了对象互斥锁的概念，保证共享数据操作的完整性。每个对象对应于一个可称为“互斥锁”的标记，这个标记保证在任一时刻，只能有一个线程访问该对象
- 关键字synchronized来与对象的互斥锁联系。当某个对象synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。

#### synchronized使用方法

```java
synchronized(this){
    //锁定当前对象
        num++;
        try{Thread.sleep(1);}
        catch(InterruptedException e){}
        System.out.println(name+",你是第"+num+"个使用timer的线程");
    	}
```
- synchronized也可以放在方法声明中，表示整个方法为同步方法

```java
public synchronized void add(String name)
```

- 例子：

```java
public class TestSync implements Runnable{
    Timer timer=new Timer();
    public static void main(String[] args){
        TestSync test=new TestSync();
        Thread t1=new Thread(test);
        Thread t2=new Thread(test);
        t1.setName("t1");
        t2.setName("t2");
        //t1和t2都访问的同一个对象timer，所以涉及到线程同步
        t1.start();
        t2.start();
    }
    public void run(){
        timer.add(Thread.currentThread().getName());
    }
}
class Timer{
    private static int num=0;
    public void add(String name){
    //也可以写成public synchronized void add(String name)
    synchronized(this){
    //锁定当前对象
        num++;
        try{Thread.sleep(1);}
        catch(InterruptedException e){}
        System.out.println(name+",你是第"+num+"个使用timer的线程");
    	}
    }
}
```
- 死锁例子：

```java
public class TestDeadLock implements Runnable{
    public int flag=1;
    static Object o1=new Object(),o2=new Object();
    public void run(){
        System.out.println("flag="+flag);
        if(flag==1){
            synchronized(o1){
                try{
                    Thread.sleep(500);
                }catch(Exception e){
                    e.printStackTrace();
                }
                synchronized(o2){
                    System.out.println("1");
                }
            }
        }
        if(flag==0){
            synchronized(o2){
                try{
                    Thread.sleep(500);
                }catch(Exception e){
                    e.printStackTrace();
                }
                synchronized(o1){
                    System.out.println("0");
                }
            }
        }
    }
    public static void main(String[] args){
        TestDeadLock td1=new TestDeadLock();
        TestDeadLock td2=new TestDeadLock();
        td1.flag=1;
        td2.flag=0;
        Thread t1=new Thread(td1);
        Thread t2=new Thread(td2);
        t1.start();
        t2.start();
    }
}
```
### 生产者消费者问题

- 一个程序，模拟做馒头和吃馒头。

```java
public class ProducerConsumer{
	public static void main(String[] args){
		SyncStack ss=new SyncStack();
		Producer p=new Producer(ss);
		Consumer c=new Consumer(ss);
		new Thread(p).start();
		new Thread(c).start();
	}
}

class WoTou{
	int id;
	WoTou(int id){
		this.id=id;
	}
	public String toString(){
		return "WoTou:"+id;
	}
}

class SyncStack{
	int index=0;
	WoTou[] arrWT=new WoTou[6];
	
	public synchronized void push(WoTou wt){
		while(index==arrWT.length){
			try{
				this.wait();//当前的正在访问的对象的线程wait
			}
			catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		this.notifyAll();//叫醒一个正在该对象上等待的线程
		arrWT[index]=wt;
		index++;
	}
	
	public synchronized WoTou pop(){
		while(index==0){
			try{
				this.wait();//当前的正在访问的对象的线程wait
			}
			catch(InterruptedException e){
				e.printStackTrace();
			}
		}
		this.notifyAll();
		index--;
		return arrWT[index];
	}
}

class Producer implements Runnable{
	SyncStack ss=null;
	Producer(SyncStack ss){
		this.ss=ss;
	}
	public void run(){
		for(int i=0;i<20;i++){
			WoTou wt=new WoTou(i);
			ss.push(wt);
			System.out.println("生产了："+wt);
			try{
				Thread.sleep((int)(Math.random())*1000);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}

class Consumer implements Runnable{
	SyncStack ss=null;
	Consumer(SyncStack ss){
		this.ss=ss;
	}
	public void run(){
		for(int i=0;i<20;i++){
			WoTou wt=ss.pop();
			System.out.println("消费了："+wt);
			try{
				Thread.sleep((int)(Math.random())*1000);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}
```