---
layout:     post                        # 使用的布局（不需要改）
title:      Shiro入门             # 标题
subtitle:   Shiro学习笔记(一)                  # 副标题
date:       2020-04-24                  # 时间
author:     AhogeK                      # 作者
header-img:  https://images.justwatch.com/backdrop/26024942/s1440/no-game-no-life    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - Shiro
---

### Shiro的作用
1. 加密项目中的密码
2. 提供访问权限限制

> Apache Shiro 是 Java 的一个安全（权限）框架。Shiro 可以轻松完成：身份认证、授权、加密、会话管理等功能。Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。功能强大且易用，可以快速轻松地保护任何应用程序（从最小的移动应用程序到最大的Web和企业应用程序。）方便的与Web集成和搭建缓存。

[下载地址](http://shiro.apache.org/)

类似的安全框架还所有 *SpringSecurity*
**相较于 Spring 的安全框架，Shiro学习更容易更简单，而功能足以满足**

### Shiro功能

* *Authentication:* 身份认证/登录，验证用户是不是拥有相应的身份。
* *Athorization:* 授权，即权限验证，验证某个已认证的用户是否拥有某个权限。
* *Session Manager:* 会话管理，即用户登录后就是一次绘画，在没有退出前，他的所有信息都在会话中。（不区分EE环境与SE环境）
* *Cryptography:* 加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。
* *Web Support:* Web 支持，可以非常容易的集成到 Web 环境。
* *Caching:* 缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，以提高效率。
* *Concurrency:* Shiro 支持多线程应用的并法验证，即如果在一个线程中开启另一个线程，能把权限自动传播过去。
* *Testing:* 提供测试支持。
* *Run As:* 允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。
* *Remember Me:* 记住我，一次登录后，下次可以不用再次登录

### Shiro架构

* *Subject:* 应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。Subject 代表当前“用户”，与 Subject 的所有交互都会委托给 SecurityManager；Subject 其实是一个门面，SecurityManager 才是实际执行者。
* *SecurityManager:* 安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；Shiro 的核心，他负责与 Shiro 的其他组建进行交互，它相当于 SpringMVC 中 DispatcherServlet 的角色。 
* *Realm:* Shiro 从 Realm 获取安全数据（如用户、角色、权限）就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作

[Shiro源码](https://github.com/apache/shiro)
**源码中有 sample quick start 可供学习**

### Shiro 的 jar 包依赖

* shiro-core: 是核心包，也是使用 shiro 框架的必须包。
* Shiro-web: 主要用于整合 web 项目。
* Shiro-spring: 主要用于整合 spring 框架。
* shiro-quartz: 主要用于整合任务调度 quartz。
* shiro-ehcache: 主要用于整合 ehcache 缓存等。
* shiro-all: 可以一次性加入所有 shiro 支持的功能的 jar 包

### 认证流程

构造 SecurityManager 环境 -> Subject.login()提交认证 -> SecurityManager.login()执行认证 -> Authenticator执行认证 -> Realm根据身份获取验证信息

### 入门简单案例

```java
public class ShiroTest {
	
	@Test
	public void loginTest() {
		// 加载资源文件
		Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:config/shiro.ini");
		// 创建安全管理器
		SecurityManager securityManager = factory.getInstance();
		// 把安全管理器甚至到 SecurityUtils
		SecurityUtils.setSecurityManager(securityManager);
		// 通过安全工具类创建 subject 主体对象
		Subject subject = SecurityUtils.getSubject();
		// 创建用户认证用的令牌
		UsernamePasswordToken token = new UsernamePasswordToken("admin", "admin");
		try {
			// 通过 subject 主体的 login 方法来进行认证
			subject.login(token);
			System.out.println("通过验证，可以登录系统");
		} catch(Exception e) {
			System.out.println("验证失败");
		}
		// 判断认证结果
		boolean authenticated = subject.isAuthenticated();
		System.out.println(authenticated);
		// 退出系统
		subject.logout();
		authenticated = subject.isAuthenticated();
		System.out.println(authenticated);
	}
}
```

### 自定义 realm 认证
> 实际开发过程中，realm 域主要用于数据库的交互，我们可以自定义 realm 类，从数据库中获取信息。

自定义域
```java
public class MyRealm extends AuthorizingRealm {

	@Override
	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
		// 通过 token 令牌获取用户账号信息
		String username = (String) token.getPrincipal();
		// 根据用户名从数据库中查询用户密码(省略数据库查询操作)
		String password = "admin";
		if (password == null || "".equals(password)) {
			return null;
		}
		// 把用户名，密码，域简写类名封装到 SimpleAuthenticationInfo对象中
		SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(username, password, "myRealm");
		return simpleAuthenticationInfo;
	}

}
```

配置文件定义 shiro-realm.ini

```ini
[main]
myRealm=com.demo.realm.MyRealm
securityManager.realms=$myRealm
```

#### 散列加密算法
在实际开发过程中，一般密码都是以密文的形式进行保存的，shiro 也对数据加密提供了支持。常用的加密算法有：md5,sha等，而 shiro 框架也专门对这些加密算法提供了实现类。

```java
@Test
public void testMd5() {
    // md5加密算法测试
    String password = "admin";
    String slt = "123456";
    int times = 1;
    Md5Hash md = new Md5Hash(password, slt, times);
    System.out.println(md.toString());
    SimpleHash sh = new SimpleHash("sha", password, slt, times);
    System.out.println(sh.toString());
}
```
----
```java
public class Md5AuthRealm extends AuthorizingRealm {

	@Override
	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
		// 通过 token 对象获取用户账号，即用户自己输入的账号
		String userName = token.getPrincipal().toString();
		// 根据获取到的用户账号查询数据表中对应的密码和盐值
		String password = "b9d11b3be25f5a1a7dc8ca04cd310b28";
		String salt = "123456";
		// 封装到SimpleAuthenticationInfo 实现类中
		SimpleAuthenticationInfo saci = new SimpleAuthenticationInfo(userName, password, 
				ByteSource.Util.bytes(salt), "md5AuthRealm");
		return saci;
	}

}
```

```ini
[main]
# 定义凭证匹配器
credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher
# 定义散列算法
credentialsMatcher.hashAlgorithmName=md5
# 定义散列次数
credentialsMatcher.hashIterations=1
# 将凭证匹配器设置到域
md5AuthRealm=com.demo.realm.Md5AuthRealm
md5AuthRealm.credentialsMatcher=$credentialsMatcher
securityManager.realms=$md5AuthRealm
```
----

#### 简单的通过ini配置文件进行授权入门

##### 授权流程
构造SecurityManager环境 -> Subject.isPermitted()授权 -> SecurityManager.isPermitted()执行授权 -> Authorizer执行授权 -> Realm根据身份获取资源权限信息

##### 授权方式
1. 编程式授权，通过代码判断角色和资源直接通过 shiro api 提供的方法进行判断
2. 注解式授权 @RequiresRoles("admin")
3. 通过 shiro 的自定义标签进行授权 <shiro:hasRole name="admin">...</shiro:hasRole>

shiro-perm.ini

```ini
[users]
# 用户admin的密码是admin，此用户具有role1和role2两个角色
admin=admin,role1,role2
test=test,role2

[roles]
# 角色 role1 对资源 user 拥有 create、update权限
role1=user:create,user:update
# 角色 role2 对资源 user 拥有 create、delete权限
role2=usre:create,user:delete
```

```java
@Test
public void testPerm() {
	// 加载资源文件
	Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:config/shiro-perm.ini");
	// 创建安全管理器
	SecurityManager securityManager = factory.getInstance();
	// 把安全管理器甚至到 SecurityUtils
	SecurityUtils.setSecurityManager(securityManager);
	// 通过安全工具类创建 subject 主体对象
	Subject subject = SecurityUtils.getSubject();
	// 创建用户认证用的令牌
	UsernamePasswordToken token = new UsernamePasswordToken("admin", "admin");
	try {
		// 通过 subject 主体的 login 方法来进行认证
		subject.login(token);
		System.out.println("通过验证，可以登录系统");
	} catch (Exception e) {
		System.out.println("验证失败");
	}
	// 判断认证结果
	boolean authenticated = subject.isAuthenticated();
	System.out.println(authenticated);
	// 判断当前主体对象是否属于指定的角色
	boolean hasRole = subject.hasRole("role1");
	System.out.println("admin的输入role1: " + hasRole);
	// 判断是否具备指定的权限
	boolean permitted = subject.isPermitted("user:create");
	System.out.println("用户具有创建权限：" + permitted);
	// 退出系统
	subject.logout();
	authenticated = subject.isAuthenticated();
	System.out.println(authenticated);
}
```

#### 通过自定义realm类授权

shiro-perm.ini
```ini
[users]
# 用户admin的密码是admin，此用户具有role1和role2两个角色
admin=admin,role1,role2
test=test,role2

[roles]
# 角色 role1 对资源 user 拥有 create、update权限
role1=user:create,user:update
# 角色 role2 对资源 user 拥有 create、delete权限
role2=usre:create,user:delete
```

MyPermRealm.java
```java
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
	String username = token.getPrincipal().toString();
	String password = "admin";
	SimpleAuthenticationInfo satInfo = new SimpleAuthenticationInfo(username, password, "myPermRealm");
	return satInfo;
}
```

test
```java
@Test
public void testPerm() {
	// 加载资源文件
	Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:config/shiro-perm.ini");
	// 创建安全管理器
	SecurityManager securityManager = factory.getInstance();
	// 把安全管理器甚至到 SecurityUtils
	SecurityUtils.setSecurityManager(securityManager);
	// 通过安全工具类创建 subject 主体对象
	Subject subject = SecurityUtils.getSubject();
	// 创建用户认证用的令牌
	UsernamePasswordToken token = new UsernamePasswordToken("admin", "admin");
	try {
		// 通过 subject 主体的 login 方法来进行认证
		subject.login(token);
		System.out.println("通过验证，可以登录系统");
	} catch (Exception e) {
		System.out.println("验证失败");
	}
	// 判断认证结果
	boolean authenticated = subject.isAuthenticated();
	System.out.println(authenticated);
	// 判断当前主体对象是否属于指定的角色
	boolean hasRole = subject.hasRole("role1");
	System.out.println("admin的输入role1: " + hasRole);
	// 判断是否具备指定的权限
	boolean permitted = subject.isPermitted("user:create");
	System.out.println("用户具有创建权限：" + permitted);
	// 退出系统
	subject.logout();
	authenticated = subject.isAuthenticated();
	System.out.println(authenticated);
}
```