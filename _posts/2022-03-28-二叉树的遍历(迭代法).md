---
layout:     post   				    # 使用的布局（不需要改）
title:      二叉树的遍历(迭代法)				# 标题 
subtitle:   题目类型:Midium #副标题
date:       2022-03-28 				# 时间
author:     谢玄xx 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 二叉树
---

# 问题一：二叉树的前序遍历


## 解题思路

* 递归法有手就行，本次来试一下迭代法。

* 迭代法都需要用到栈结构。利用栈先入后出的特点依次将元素遍历。

## 代码如下
```CPP
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        stack<TreeNode*> st;
        st.push(root);//一定记得先把这个根节点压入栈
        while(!st.empty())
        {
            //先把栈内元素存储在一个临时变量temp里，再把它出栈
            TreeNode* temp = st.top();
            st.pop();
            //接下来操作temp就可以得到对应的节点值
            res.push_back(temp->val);
            //先右后左，因为栈先入后出
            if(temp->right)
            {
                st.push(temp->right);
            }
            if(temp->left)
            {
                st.push(temp->left);
            }


        }
        return res;//出来就是中左右，前序遍历完成

    }
};
```


# 问题二：二叉树的后序遍历


## 解题思路

## 代码如下
```CPP
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        stack<TreeNode*> st;
        st.push(root);//一定记得先把这个根节点压入栈
        while(!st.empty())
        {
            //先把栈内元素存储在一个变量里，再把它出栈
            TreeNode* temp = st.top();
            st.pop();
            res.push_back(temp->val);
            if(temp->left)
            {
                st.push(temp->left);
            }
            if(temp->right)
            {
                st.push(temp->right);
            }


        }
        //出栈后是中右左。想要是后序遍历(左右中)直接reverse即可。
        reverse(res.begin(), res.end());//注意reverse格式
        return res;
    }
};

```

# 问题三：二叉树的中序遍历


## 解题思路

* 为什么中序遍历不同呢？因为前序是操作根节点，遍历根节点。

## 代码如下

### 解法1
```CPP
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```
# 问题四：二叉树的层序遍历


## 解题思路

## 代码如下
```CPP
struct node{
    TreeNode *p;
    int depth;
};
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;
        int last = 0;
        vector<int> current;
        queue<node> que; //队列类型为node，存放当前层节点，及时传给current
        que.push((node){root, 0});
        while(!que.empty())
        {
            node temp = que.front();
            que.pop();
            if(temp.depth != last) //如果不在同一层，赶快把current拿出来
            {
                res.push_back(current);
                current.clear();
                last = temp.depth;
            }
            current.push_back(temp.p->val);
            if(temp.p->left)
            {
                que.push((node){temp.p->left, temp.depth + 1});
            }
            if(temp.p->right)
            {
                que.push((node){temp.p->right, temp.depth + 1});
            }

        }
        res.push_back(current);
        return res;

    }
};
```
### 解法2
```CPP
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector <vector <int>> ret;
        if (!root) {
            return ret;
        }

        queue <TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int currentLevelSize = q.size();
            ret.push_back(vector <int> ());
            for (int i = 1; i <= currentLevelSize; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        
        return ret;
    }
};
```
