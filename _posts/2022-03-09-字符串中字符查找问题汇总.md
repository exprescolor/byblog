---
layout:     post   				    # 使用的布局（不需要改）
title:      字符串中字符查找问题汇总				# 标题 
subtitle:   汇总了一系列需要查找字符串中内容的LC原题 #副标题
date:       2022-03-09 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea7.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 字符串
    - 哈希表
---

# LC第14题：最长公共前缀

如果不存在公共前缀，返回空字符串 ""。

## 解题思路

纵向遍历，把字符串看成字符串数组，每个字符串为一行，一共有整数行。先横向遍历第一个字符串，之后将下面的每个字符串都和它对比。如果发现第一个不同的字符，就返回第一个~前一个字符。

## 代码示例

```CPP
string longestCommonPrefix(vector<string>& strs) {
    if(!strs) return "";
    int length = strs[0].length();
    int count = strs.size();
    for(int i = 0; i < length; i++) {
        char c = strs[0][i];
        for(int j = 1; j < count; j++) {
            if(strs[0].size() == i || strs[j][i] != c) {
                return strs[0].substr(0, i);
            }
        }
    }
    return strs[0];
}
```
# LC第387题：字符串中的第一个唯一字符

给定一个字符串 s ，找到它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
这里只需要考虑小写字母。


## 解题思路1

使用一个数组来记录出现过的小写字母。如果出现i次，就记录为index[s[i] - 'a']。然后再遍历一次数组，找i=1的即可。


## 代码示例1
```CPP
int firstUniqChar(string s) {
    int a[26]={0};
    int index[26];
    int size=s.size();
    for(int i=0;i<size;i++) {
        a[s[i]-'a']++;
        index[s[i]-'a']=i;
    }
    for(int i=0;i<size;i++) {
        if(a[s[i]-'a']==1) {
            return index[s[i]-'a'];
        }
    }
    return -1;
}    
```
## 解题思路2

直接使用哈希表存储每个字符出现的频次，之后进行二次遍历。只要其中一个字符串的value值为1，就马上返回这个元素下标。

## 代码示例2

```CPP
int firstUniqChar(string s) {
    unordered_map<char, int> pairs;
    for(int i = 0 ; i < s.length(); i++) {
        pairs[s[i]]++;//使用哈希表存储每个字符出现的频次
    }
    for(int i = 0 ; i < s.length(); i++) {
        if(pairs[s[i]] == 1) {
            return i;
        }
    }
    return -1;
}
```
# LC第242题：有效的字母异位词

给定两个字符串s,t，判断t是否为s的字母异位词，即每个字母出现的频次都相同。本题默认没有数字。


## 解题思路1

解题思路和上一道题大同小异。用一个数组a[26]存储所有出现的字母及其频次，然后a[t[i] - 'a']--，使用t的字母及频次对数组a进行“抵消”。如果最终结果为0，则返回true。


## 代码示例1
```CPP
bool isAnagram(string s, string t) {
    int shash[26] = {0};
    int thash[26] = {0};
    for(int i=0;i<s.size();i++) {
        shash[s[i]-'a']++;
    }
    for(int i=0;i<t.size();i++) {
        thash[t[i]-'a']++;
    }
    for(int i=0;i<26;i++) {
        if(shash[i] != thash[i]) {
            return false;
        }
    }
    return true;
}
```

## 代码疑惑

在第三个for语句判断中，为什么判断不等，返回false就可以过，而判断相等,返回true就过不了呢...

## 问题解答

这是因为，每个字符出现的次数**都需要相等**才能判断true，而单次判断true肯定不能确定是字母异位词，因此需要判断不等。


## 解题思路2

第二个思路和上一题的第二个思路基本类似。直接使用哈希表存储第一个字符串每个字符出现的频次，之后进行二次遍历，对出现的频次进行递减。只要其中一个字符串的value值不为0，就马上返回false。反之就是全部对应完成，输出true。

## 代码示例2

```CPP
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<char, int> pairs1;
        if(s.length() != t.length()) return false;
        for(int i = 0; i < s.length(); i++) {
            pairs1[s[i]]++;
        }
        for(int i = 0; i < t.length(); i++) {
            pairs1[t[i]]--;
        }
        for(int i = 0; i < t.length(); i++) {
            if(pairs1[s[i]] != 0) {
                return false;
            }
        }        
        return true;
    }
};
```
