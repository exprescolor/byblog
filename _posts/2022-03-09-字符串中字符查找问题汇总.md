---
layout:     post   				    # 使用的布局（不需要改）
title:      字符串中字符查找问题汇总				# 标题 
subtitle:   汇总了一系列需要查找字符串中内容的LC原题 #副标题
date:       2022-03-08 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 字符串
    - 哈希表
---

# LC第387题：字符串中的第一个唯一字符

给定一个字符串 s ，找到它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
这里只需要考虑小写字母。


## 解题思路

使用一个数组来记录出现过的小写字母。如果出现i次，就记录为index[s[i] - 'a']。然后再遍历一次数组，找i=1的即可。


## 代码示例

    int firstUniqChar(string s) {
        int a[26]={0};
        int index[26];
        int size=s.size();
        for(int i=0;i<size;i++)
        {
            a[s[i]-'a']++;
            index[s[i]-'a']=i;
        }
        for(int i=0;i<size;i++)
        {
            if(a[s[i]-'a']==1)
            {
                return index[s[i]-'a'];
            }
        }
        return -1;
    }    


# LC第242题：有效的字母异位词

给定两个字符串s,t，判断t是否为s的字母异位词，即每个字母出现的频次都相同。本题默认没有数字。


## 解题思路

解题思路和上一道题大同小异。用一个数组a[26]存储所有出现的字母及其频次，然后a[t[i] - 'a']--，使用t的字母及频次对数组a进行“抵消”。如果最终结果为0，则返回true。


## 代码示例

    bool isAnagram(string s, string t) {
        int shash[26] = {0};
        int thash[26] = {0};
        for(int i=0;i<s.size();i++)
        {
            shash[s[i]-'a']++;
        }
        for(int i=0;i<t.size();i++)
        {
            thash[t[i]-'a']++;
        }
        for(int i=0;i<26;i++)
        {
            if(shash[i] != thash[i]) 
            {
                return false;
            }
        }
        return true;
    }
## 代码疑惑

在第三个for语句判断中，为什么判断不等，返回false就可以过，而判断相等,返回true就过不了呢...

## 问题解答

这是因为，每个字符出现的次数**都需要相等**才能判断true，而单次判断true肯定不能确定是字母异位词，因此需要判断不等。
