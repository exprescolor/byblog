---
layout:     post   				    # 使用的布局（不需要改）
title:      myvm分析（5.11更新）	# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-05-09 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - rev
---

# 背景知识

虚拟机：虚拟机，在计算机科学中的体系结构里，是指一种特殊的软件，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它软件。虚拟机是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。

​		我们今天分析的就是一个简单的基于寄存器的虚拟机实现（主程序myvm)，你可以将它理解为一个“自定义字节码”的language based virtual machine，它可以解释执行任何一段与当前指令集相符分程序。

编码格式：常见的编码格式如 ASCII、ISO-8859-1、GB2312、GBK、UTF-8等，分别用于不同的环境，今天的虚拟机用的是x86指令编码，这是一种汇编编码方式。X86指令由:

- 前缀字节prefix (非必需)
- 操作码opcode (必须)
- 内存/寄存器操作数字节ModR/M (非必需)
- 索引寻址描述字节SIB (非必需)
- 常数偏移字节/半字/字Displacement (非必需)
- 立即数字节/半字/字 Immediate (非必需)

具体解释见![x86指令编码笔记](http://4ch12dy.site/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/)(http://4ch12dy.site/2017/10/11/x86指令编码笔记/X86指令编码笔记/)

汇编器：汇编器（Assembler）是将汇编语言翻译为机器语言的程序。 一般而言，汇编生成的是目标代码，需要经链接器（Linker）生成可执行代码才可以执行。 汇编语言是一种以处理器指令系统为基础的低级语言，采用助记符表达指令操作码，采用标识符表示指令操作数。

反汇编器：反汇编器是一种将机器语言转换为汇编语言的计算机程序——这与汇编器的目的相反。反汇编器与反编译器不同，反编译器的目标是高级语言而非汇编语言。反汇编器的反汇编输出通常格式化为适合人类阅读，而非用作汇编器的输入源，因此它主要是一个逆向工程工具。

# main函数代码

```assembly
; int __cdecl main(int, char **, char **)
main proc near
; __unwind {
push    r14
push    rbx
push    rax
mov     rbx, rsi
cmp     edi, 2
jnz     short loc_C47
lea     rsi, handler    ; handler
mov     edi, 2          ; sig
call    signal
mov     rdi, [rbx+8]
call    sub_CE0
mov     rbx, rax
lea     r14, unk_202014
mov     dword ptr [r14], 1
nop     word ptr [rax+rax+00000000h]
loc_C10:
mov     rdi, rbx
call    sub_E90
test    eax, eax
jnz     short loc_C24
cmp     dword ptr [r14], 0
jnz     short loc_C10
jmp     short loc_C35
loc_C24:
cmp     eax, 2
jnz     short loc_C35
lea     rdi, s          ; "Illegal Instruction"
call    puts
loc_C35:
mov     rdi, rbx
call    nullsub_1
loc_C3D:
xor     eax, eax
add     rsp, 8
pop     rbx
pop     r14
retn
loc_C47:
mov     rax, cs:stderr_ptr
mov     rdi, [rax]      ; stream
mov     rdx, [rbx]
lea     rsi, format     ; "Usage: %s <myvm program>\n"
xor     eax, eax
call    fprintf
jmp     short loc_C3D
; } // starts at BD0
main endp
```

## 指令集

PUSH    把字压入堆栈.

MOV     传送字或字节.

CMP     比较.(两操作数作减法,仅修改标志位,不回送结果).

JNE/JNZ     不等于时转移. 

LEA     装入有效地址.例: LEA DX,string ;把偏移地址存到DX. 

CALL      过程调用 

NOP     无操作 

TEST    测试.(两操作数作与运算,仅修改标志位,不回送结果). 

XOR     异或运算. 

ADD     加法. 

CMP     比较.(两操作数作减法,仅修改标志位,不回送结果). 

POP     把字弹出堆栈.

RET/RETF    过程返回.

# 源代码

```c
__int64 __usercall main@<rax>(char **a1@<rsi>, char **a2@<rdx>, __int64 a3@<rax>, int a4@<edi>)
{
  __int64 v4; // rbx
  int v5; // eax

  if ( a4 == 2 )
  {
    signal(2, handler);
    v4 = sub_CE0(a1[1], handler);
    unk_202014 = 1;
    while ( 1 )
    {
      v5 = sub_E90(v4);
      if ( v5 )
        break;
      if ( !unk_202014 )
        goto LABEL_8;
    }
    if ( v5 == 2 )
      puts("Illegal Instruction");
LABEL_8:
    nullsub_1(v4);
  }
  else
  {
    fprintf(stderr, "Usage: %s <myvm program>\n", *a1, a3);
  }
  return 0LL;
}
```

代码是用IDA的F5生成的，然后分析一些这部分代码。

先判断a4是否等于2，如果不等于，执行汇编中loc_C47这一块代码，也就是`fprintf(stderr, "Usage: %s <myvm program>\n", *a1, a3);`输出数据到文件中，结束。

如果相等，则进入if语句。调用`signal(2, handler)`

> signal函数

函数原型：`void（* signal（int  sig，void（* func）（int）））（int）;`

设置处理信号的功能

指定使用sig指定的*信号编号*处理信号的方法。 参数func指定程序可以处理信号的三种方式之一：

- 默认处理（SIG_DFL）：信号由该特定信号的默认动作处理。
- 忽略信号（SIG_IGN）：忽略信号，即使没有意义，代码执行仍将继续。
- 函数处理程序：定义一个特定的函数来处理信号。

我们的signal函数自定义一个信号处理函数handler，要求内核在处理该信号时切换到用户态执行这个处理函数。

然后调用了sub_CE0这个函数。F5得到源代码：

```c
char *__fastcall sub_CE0(const char *a1)
{
  FILE *v1; // rax
  FILE *v2; // rbx
  __int64 v3; // r15
  void *v4; // r14
  char *v5; // rbx

  v1 = fopen(a1, "rb");
  v2 = v1;
  if ( !v1 )
    return 0LL;
  fseek(v1, 0LL, 2);
  v3 = ftell(v2);
  fseek(v2, 0LL, 0);
  v4 = malloc(0x10000uLL);
  memset(v4, 0, 0x10000uLL);
  fread(v4, 1uLL, v3, v2);
  fclose(v2);
  _mm_storeu_si128(
    (__m128i *)&unk_202018 + 4096,
    _mm_unpacklo_epi64((__m128i)(unsigned __int64)&unk_202018, (__m128i)((unsigned __int64)&unk_202018 + 0x8000)));
  memcpy(&unk_202018, v4, 0x10000uLL);
  _mm_storeu_si128((__m128i *)&unk_202018 + 4097, (__m128i)0LL);
  *(_QWORD *)((char *)&unk_202018 + 65566) = 0LL;
  *((_WORD *)&unk_202018 + 32785) = 32764;
  *((_QWORD *)&unk_202018 + 8197) = 0LL;
  v5 = (char *)&unk_202018 + 0x10000;
  free(v4);
  return v5;
}
```

v1和v2代表两个文件对象，fopen打开了a1文件，rb是只读。

> fseek函数

函数原型`int fseek(FILE stream, long offset, int fromwhere)`把fp的文档读写位置指针移到指定的位置.

SEEK_SET 0 文档开头
SEEK_CUR 1 文档当前位置
SEEK_END 2 文档末尾

fseek(v1, 0LL, 2)设置v1指向文件尾，fseek(v2, 0LL, 0)设置v2指向文件头。

> ftell函数

long ftell(FILE fp) 得到流式文档的当前读写位置,其返回值是当前读写位置偏离文档头部的字节数

ftell(v2)把v2当前位置相对于文件首的偏移字节数赋值给v3。

malloc动态分配内存，这里分配了一块长度为0x10000uLL的内存，v4指向该区域的开头位置。

memset(v4, 0, 0x10000uLL)把这块内存初始化为0.

> fread函数

函数原型`size_t fread( void buffer, size_t size, size_t count, FILE stream )`

buffer 是读取的数据存放的内存的指针
size 是每次读取的字节数
count 是读取次数
stream 是要读取的文档的指针

fread(v4, 1uLL, v3, v2)从v2中读取v3次数据，每次的大小为1ull，存放在v4处。

fclose(v2)关闭v2。

> _mm_store_si128函数

函数原型` _mm_store_si128 ( __m128i *p, __m128i a)`

功能：可存储128位数据；
说明：将__m128i 变量a的值存储到p所指定的变量中去；
注意：p必须是一个16-bit对齐的一个变量的地址。

>_mm_unpacklo_epi64函数

函数原型`_mm_unpacklo_epi64 (m128i a, m128i b) `

返回一个m128i的寄存器，它将寄存器a和寄存器b的低64bit数以64bit为单位交织在一块。

`_mm_storeu_si128(
    (__m128i *)&unk_202018 + 4096,
    _mm_unpacklo_epi64((__m128i)(unsigned __int64)&unk_202018, (__m128i)((unsigned __int64)&unk_202018 + 0x8000)));`这句话将逗号后的__m128i 变量的值存储到&unk_202018 + 4096所指定的变量中去。

` memcpy(&unk_202018, v4, 0x10000uLL)`从v4处拷贝0x10000uLL大小的数据到&unk_202018位置处。

最后sub_CE0函数的返回值是v5。函数结果赋值给v4。

回到main函数的if语句中，unk_202014 赋值为1，调用sub_E90函数，里面是一些case语句。将返回值赋值给v5，若v5不为0则跳出循环，若v5为2则抛出Illegal Instruction。

# 寻址方式

1.立即寻址方式（immediate addressing）

操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式，把该操作数称为立即数。

MOV  AL, 6                       ;(AL)=6

MOV  AX, 3064H             ;(AX)=3064

2.寄存器寻址方式（register addressing）

操作数直接包含在寄存器中,由指令指定寄存器号的寻址方式。

MOV  BX, AX                    ;(BX)=(AX)

MOV  DI, 5678H              ;(DI)=5678H

除以上两种寻址方式外，以下各种寻址方式的操作数都在存储器中，其操作数称为存储器操作数。

由于80X86对内存采用分段管理,因此由以下寻址方式得到的只是有效地址（简写为EA－effective address，在IBM PC中就是操作数地址的偏移量部分）。

有效地址可以由以下四种成分组成：

位移量（displacement）是存放在指令中的一个8位、16位或32位的数，它是一个地址。

基址（base）是存放在基址寄存器中的内容。通常用来指向数据段中数组或字符串的首地址。

变址（index）是存放在变址寄存器中的内容。通常用来访问数组中的某个元素或字符串中的某个字符。

比例因子（scale factor）是80386以上CPU新增加的。其值可为1、2、4或8。寻址中，可用变址寄存器的内容乘以比例因子来取得变址值。

EA=基址+（变址x比例因子）+位移量

3.直接寻址方式（direct addressing）

操作数的有效地址直接包含在指令中的寻址方式。

有效地址存放在代码段的指令操作码之后，但操作数本身在存储器中，所以必须先求出操作数的物理地址。这种寻址方式常用于存取简单变量。

MOV  AL, [78H]

由于在汇编语言中用符号表示地址,所以指令“MOV  AL,VAR”中的源操作数寻址方式是直接寻址，有时也写做“MOV  AL,[VAR]”

4.寄存器间接寻址方式（register indirect addressing）

操作数的有效地址在基址寄存器BX、BP或变址寄存器SI、DI中，而操作数在存储器中的寻址方式。对于386以上CPU，允许使用任何32位通用寄存器。

MOV  AL, [BX]

5.寄存器相对寻址方式（register relative addressing）

也称为直接变址寻址方式。操作数的有效地址是一个基址(BX、BP)或变址(SI、DI)寄存器的内容和指令中给定的一个位移量（disp）之和。有效地址由2部分组成。对于386以上允许使用任何32位通用寄存器。

即：EA＝（基址＜或变址＞寄存器）＋disp

或：EA＝（32位通用寄存器）+disp（386型号以上）

例：  MOV  AL, 8[BX] 或MOV  AL, [BX＋8]

6.基址变址寻址方式（based indexed addressing）

操作数的有效地址是一个基址寄存器（BX、BP）和一个变址寄存器（SI、DI）的内容之和。386以上允许使用变址部分除ESP以外的任何两个32位通用寄存器组合。缺省使用段寄存器的情况由基址寄存器决定。允许使用段超越前缀。

MOV AL,[BX][SI] 或MOV AL,[BX＋SI]

7.相对基址变址寻址方式（relative based indexed addressing）

操作数的有效地址是一个基址和一个变址寄存器的内容和指令中给定的一个位移量之和。有效地址由三部分组成。80386以上允许使用变址部分除ESP以外的任何两个32位通用寄存器组合。缺省使用段寄存器的情况由基址寄存器决定。允许使用段超越前缀。

MOV AL,MASK[BX][SI] 或MOV AL,MASK[BX＋SI]或MOV AL,[MASK＋BX＋SI]

8.比例变址寻址方式（scaled indexed addressing）

注意：80386以上的微处理器才提供。

EA＝（基址寄存器）＋（变址寄存器）×比例因子＋disp

其优点在于：对于元素大小为2、4、8字节的数组，可以在变址寄存器中给出元素下标，而由寻址方式控制直接用比例因子把下标转换为变址值。

可以看出，它实际上是386以上CPU存储器操作数寻址方式的通用公式。

MOV AX, ARY[BX][4*SI]