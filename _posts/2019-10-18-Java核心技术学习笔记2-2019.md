---
layout:     post                    # 使用的布局（不需要改）
title:      Java核心技术学习笔记2           # 标题 
subtitle:   继承-类、超类和子类             #副标题
date:       2019-10-18              # 时间
author:     AhogeK                      # 作者
header-img: img/core_java.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - java
    - 继承
    - 学习笔记
---

## 继承
### 类、超类和子类
#### 定义子类

```java
public class Manager extends Employee {
  添加方法和域
}
```

已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class)或孩子类（child class）。
**将通用的方法放在超类，而将具有特殊用途的方法放在子类中**

#### 覆盖方法

>超类中提供的公共的方法，虽用途相同，但可能实现会有所差异，这时就可以提供一个覆盖（override）方法。

*注：有些人认为 super 与 this 引用是类似的概念，实际上，这样比较并不恰当。这是因为 super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字*

#### 子类构造器

``super()``调用父类的构造（子类构造器的第一条语句）
*注：关键字 this 有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作另一个构造器的第一条语句出现。构造参数即可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器*

(不同对象薪水上的区别)

```java
package inheritance;

/**
 * This program demonstrates inheritance.
 * @version 1.21 2004-02-21
 * @author Cay Horstmann
 */
public class ManagerTest
{
   public static void main(String[] args)
   {
      // construct a Manager object
      Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
      boss.setBonus(5000);

      Employee[] staff = new Employee[3];

      // fill the staff array with Manager and Employee objects

      staff[0] = boss;
      staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
      staff[2] = new Employee("Tommy Tester", 40000, 1990, 3, 15);

      // print out information about all Employee objects
      for (Employee e : staff)
         System.out.println("name=" + e.getName() + ",salary=" + e.getSalary());
   }
}
```

```java
package inheritance;

import java.time.*;

public class Employee
{
   private String name;
   private double salary;
   private LocalDate hireDay;

   public Employee(String name, double salary, int year, int month, int day)
   {
      this.name = name;
      this.salary = salary;
      hireDay = LocalDate.of(year, month, day);
   }

   public String getName()
   {
      return name;
   }

   public double getSalary()
   {
      return salary;
   }

   public LocalDate getHireDay()
   {
      return hireDay;
   }

   public void raiseSalary(double byPercent)
   {
      double raise = salary * byPercent / 100;
      salary += raise;
   }
}
```

```java
package inheritance;

public class Manager extends Employee
{
   private double bonus;

   /**
    * @param name the employee's name
    * @param salary the salary
    * @param year the hire year
    * @param month the hire month
    * @param day the hire day
    */
   public Manager(String name, double salary, int year, int month, int day)
   {
      super(name, salary, year, month, day);
      bonus = 0;
   }

   public double getSalary()
   {
      double baseSalary = super.getSalary();
      return baseSalary + bonus;
   }

   public void setBonus(double b)
   {
      bonus = b;
   }
}
```

#### 继承层次
由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy）。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链（inheritance chain）。

#### 多态
> 讲多态前先再来说说继承，继承关系有个简单规则 -> "is-a" 例如：每个经理都是雇员。这是一种置换法则，程序中出现超类对象的任何地方都可以用子类对象置换。
在 Java 程序设计语言中，对象变量是多态的。例如一个雇员数组中的一个元素可以与boss引用同一个对象，但该元素编辑器将依旧看成雇员对象。 -> 不能将一个超类的引用赋给子类变量。
**使用 ``new managers[10]`` 创建的数组是一个经理数组，如果试图存储一个*Employee*类型的引用就会引发*ArrayStoreException*异常**

#### 理解方法调用
调用过程：
1. 编译器查看对象的声明类型和方法名
2. 编译器将查看调用方法时提供的参数类型 *方法名和参数列表称为方法的签名*
3. 如果时 private 方法、static 方法、final 方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方法称为静态绑定（static binding）
4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。
**在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。如果超类方法是 public，子类方法一定要声明为 public**

#### 阻止继承：final类和方法
阻止人们利用某个类定义子类，不允许扩展的类被称为 *final* 类。

```java
public final class Executive extends Manager {
   ...
}
```

类中的特定方法也可以被称为 final。子类不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法）
*域也可以被声明为 final。对于 final 域来说，构造对象之后就不允许改变它们的值了。**将一个类声明为 final 只有其中的方法自动成为 final 而不包括域***
<br>
目的：确保他们不会在子类中改变语义。<br>
在早期版本的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程被称为内联（inlining）