---
layout:     post 
title:      Java
subtitle:   Java学习
date:       2019-10-12
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.用Java设计一个100亿的计算器

- 注意加减法的位运算原理和计算机中的算数运算会发生越界的情况。
   - 计算机中的算数运算越界：计算机中用固定数量的几个字节来存储数值，而计算机中能够表示的数值是有一定的范围的。以byte类型的整数为例，他用一个字节进行存储，表示的最大数值范围为-128~+127。-1在内存中对应的二进制值为11111111，如果两个-1相加，不考虑Java运算时的类型提升， 运算后会产生进位，二进制结果为111111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。-128在内存中的二进制值是10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1000000000，由于进位后超过了byte的存储空间，所以进位部分会被舍弃，即最终的结果为00000000，也就是0，这个结果显然是错的，这说明计算机中的算数运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。
- 由于在Java中int的正数范围为2的31次方，也就是大约20亿，所以要实现100亿的计算器，我们需要自己设计一个类可以用于表示很大的数，并且提供了与另一个整数进行加减乘除的功能，大概功能如下：
   - 1.这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数
   - 2.有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中
   - 3.提供加减乘除功能

```java
public class BigInteger{
    int sign;
    byte[] val;
    public Biginteger(String val){
        sign=;
        val=;
    }
    
    public BigInteger add(BigInteger other){
        
    }
    public BigInteger subtract(BigInteger other){
        
    }
    public BigInteger multiply(BigInteger other){
        
    }
    public BigInteger divide(BigInteger other){
        
    }
}
```

- 实现大体框架即可，若想了解详细代码，请看下方示例：
- 详细代码来源于网上，具体自行了解，只有相加的功能
- MyBigInteger.java

```java
package redis;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by Rocky on 14-3-26.
 */
public class MyBigInteger {
	private char sign = '0'; // 0 表示正数 - 表示负数
	private byte[] data;

	public MyBigInteger() {
		this.data = "0".getBytes();
	}

	public MyBigInteger(String value) throws Exception {
		// 正则表达式，输入字符串要求以 零个或一个 - 开头，其余都是数字
		Pattern pattern = Pattern.compile("^-?\\d+$");

		if (value == null || value.length() <= 0) {
			value = "0";
		}
		Matcher matcher = pattern.matcher(value);
		if (!matcher.find()) {
			throw new Exception("the value is not a number string :" + value);
		}
		// 获取字符串的第一个字符
		char firstChar = value.charAt(0);

		// data应该保存的是第一个非0数字后的字符串
		if (firstChar == '-') { // 说明输入的是个负数
			if (value.length() >= 2) {
				sign = firstChar;
				value = value.substring(1);
				value = getTemp(value); // 得到value中第一个非0后的子字符串。
			}
		} else {
			value = getTemp(value);
		}
		this.data = value.getBytes();
	}

	/**
	 * 得到一个字符串第一个非0后的字符串，如果没有找到，则返回 "0" 。如：00003435534，则返回3435534
	 * 
	 * @return
	 */
	private String getTemp(String value) {
		Pattern pattern = Pattern.compile("[^0]{1}");
		Matcher matcher = pattern.matcher(value);
		if (matcher.find()) {
			value = value.substring(matcher.start());
		} else {
			value = "0";
		}
		return value;
	}

	public MyBigInteger add(MyBigInteger other) {
		MyBigInteger result = new MyBigInteger();
		int thisLength = this.data.length;
		int otherLength = other.data.length;
		int shorterLength = thisLength > otherLength ? otherLength : thisLength;
		ArrayList<Byte> resultData = new ArrayList<Byte>();
		int flag = 0; // 表示相加时的 进位，或相减时的 借位
		int i = thisLength - 1;
		int j = otherLength - 1;
		int k = shorterLength;

		// 两个数的符号相同
		if (other.sign == this.sign) {
			// 从两个整数的个位开始依次相加
			while (k > 0) {
				Integer temp = new Integer(new String(new byte[] { this.data[i] }))
						+ new Integer(new String(new byte[] { other.data[j] })) + flag;
				flag = temp / 10; // 相加结果超过10时的进位。没有超过10，进位为 0
				resultData.add(0, ((temp % 10) + "").getBytes()[0]); // 把相加结果保存起来
				k--;
				i--;
				j--;
			}
			// 把多出的位加入到结果中
			if (i == -1) {
				while (j >= 0) {
					Integer temp = new Integer(new String(new byte[] { other.data[j] })) + flag;
					flag = temp / 10;
					resultData.add(0, ((temp % 10) + "").getBytes()[0]);
					j--;
				}
			} else if (j == -1) {
				while (i >= 0) {
					Integer temp = new Integer(new String(new byte[] { this.data[i] })) + flag;
					flag = temp / 10;
					resultData.add(0, ((temp % 10) + "").getBytes()[0]);
					i--;
				}
			}
			// 最后把flag加进结果中
			if (flag != 0) {
				for (byte by : (flag + "").getBytes()) {
					resultData.add(0, by);
				}
			}
			result.sign = other.sign;
		} else { // 符号不同
			if (thisLength > otherLength) { // 说明this表示的整数绝对值大，所以最终结果的符号为this的符号
				result.sign = this.sign;
				resultData = subtract(this.data, other.data); // 执行减法
			} else if (thisLength < otherLength) { // other表示的整数绝对值大，所以最终结果的符号为other的符号
				result.sign = other.sign;
				resultData = subtract(other.data, this.data);
			} else { // 如果两个数据的位数相同
				Integer thisInt = 0;
				Integer otherInt = 0;
				// 从第一位开始比较，直到两者不相等
				for (int n = 0; n < thisLength; n++) {
					thisInt = new Integer(new String(new byte[] { this.data[n] }));
					otherInt = new Integer(new String(new byte[] { other.data[n] }));
					if (!thisInt.equals(otherInt)) { // 注意这里要使用equals方法，因为这里需要比较的是两者的内容
						break;
					}
				}

				// 如果this的绝对值大
				if (thisInt > otherInt) {
					result.sign = this.sign;
					resultData = subtract(this.data, other.data);
				} else {
					result.sign = other.sign;
					resultData = subtract(other.data, this.data);
				}
			}
		}
		result.data = new byte[resultData.size()];
		for (int m = 0; m < resultData.size(); m++) {
			result.data[m] = resultData.get(m);
		}
		return result;
	}

	private ArrayList<Byte> subtract(byte[] larger, byte[] smaller) {
		ArrayList<Byte> resultData = new ArrayList<Byte>();
		int flag = 0;
		int i = smaller.length - 1;
		int j = larger.length - 1;
		int k = smaller.length;
		while (k > 0) {
			Integer temp = new Integer(new String(new byte[] { larger[j] })) + flag
					- new Integer(new String(new byte[] { smaller[i] }));
			if (temp < 0) { // 如果相减结果小于0，说明需要借位，则把flag置为 -1，以便下一位减去
				flag = -1;
				temp += 10;
			} else { // 如果大于零，需要把flag置为 0.不要忘记了
				flag = 0;
			}
			resultData.add(0, (temp + "").getBytes()[0]);
			j--;
			i--;
			k--;
		}
		// 下面的代码就不写注释了
		while (j >= 0) {
			Integer temp = new Integer(new String(new byte[] { larger[j] })) + flag;
			if (temp < 0) {
				flag = -1;
				temp += 10;
			} else {
				flag = 0;
			}
			resultData.add(0, (temp + "").getBytes()[0]);
			j--;
		}
		return resultData;
	}

	@Override
	public String toString() {
		String str = new String(this.data);
		str = getTemp(str);
		if (sign == '-' && str != "0") {
			str = sign + str;
		}
		return str;
	}

}
```

- MyBigIntegerTest.java

```java
package redis;

import junit.framework.TestCase;
import java.math.BigInteger;
 
/**
 * Created by Rocky on 14-3-26.
 */
public class MyBigIntegerTest extends TestCase {
    public void test1() throws Exception {
        String a1 = "-5453450543044355356576980545345054545453453454344435353254545345054304435535657698087756454543454345454534534543444353532545453450543044355356454543454354353450136546534534545345345054353450136546534534545345345043044355356576980657698087756454543454354353450136546534534545345345054353450136546534534545345345043044355356576980877564545434543543534501877564545434543543534501";
        String b1 = "4545453453454344435353254545345054304435535657698087756454543454354345454534534543444353532545453450543044355356576980877564545434545454534534564545434543543534501365465345345453453450543534501365465345345453453450430443553565769804344435353254545345054304435535657698087756454543454354353450136546534534545345345043543534501365465345345453453450534501365465345345453453450";
        MyBigInteger a = new MyBigInteger(a1);
        MyBigInteger b = new MyBigInteger(b1);
        MyBigInteger c = a.add(b);
        System.out.println(c);
        BigInteger a2 = new BigInteger(a1);
        BigInteger b2 = new BigInteger(b1);
        BigInteger c2 = a2.add(b2);
        System.out.println(c2);
        System.out.println(c2.toString().equals(c.toString()));
    }
}
```

#### 2.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

- 使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，如下语句：

```java
final StringBuffer a=new StringBuffer("immutable");
```

- 执行如下语句的时候会报错

```java
a=new StringBuffer("");
```

- 但是执行如下语句则可以通过编译

```java
a.append("broken");
```

- 有人在定义方法参数的时候，会采用如下形式来阻止方法内部修改传进来的参数对象

```java
public void method(final StringBuffer param){
    
}
```

- 实际上这是办不到的，在该方法内部依旧可以采用如下方法进行更改参数对象

```java
param.append("a");
```

#### "=="和equals方法究竟有什么区别？

- "=="操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相等，要比较两个基本类型的数据或者两个引用变量是否相等，只能用==操作符
- equals方法用于比较两个独立对象的内容是否相同
- 如果一个类没有自己定义equals方法，它默认的equals方法就是使用==操作符，也就是在比较两个变量所指向的对象是否是同一个对象。

#### 静态变量和实例变量和区别？

- 在语法定义上的区别：静态变量前要加上static关键字，而实例变量不需要
- 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了某个实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。静态变量不属于某个对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来使用

#### 构造器Constructor是否能被override？

- 构造器不能被继承，因此不能重写override，但可以被重载overload。