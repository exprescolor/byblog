---
layout:     post   				    # 使用的布局（不需要改）
title:      C++11新特性				# 标题 
subtitle:    #副标题
date:       2022-05-11 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea8.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - C++11
    - 八股
---

C++11的新特性也多次被问到，在这里做一个简要总结。

# 统一的初始化方法——赋值符号"="可省略

Talk is cheap. Show you the code : )

```CPP
int main() {
    int arr[3] {1, 2, 3};   //C++11可以直接这么写，而不需要括号。
    vector<int> a {1, 2, 3};    //vector 同理
    string str {"Today"};       //stirng 同理
    unordered_map<string, int> pairs { {"a", 1}, {"b", 2}};
    int *p = new int[20] {1,2,3};
}

```
# auto 关键字

# decltype关键字

# 智能指针

对智能指针来说，有两条原则：

1. 智能指针本身是**不能动态分配**的，否则它自身有不被释放的风险，进而可能导致它所管理对象不能正确地被释放；
2. 在栈上分配智能指针，让它指向堆上动态分配的对象，这样就能保证智能指针所管理的对象能够合理地被释放。

## unique_ptr

* unique_ptr是独占式的，即完全拥有它所管理对象的所有权，不和其它的对象共享。
* unique_ptr实现的是专属所有权语义，用于独占它所指向的资源对象的场合。某个时刻只能有一个unique_ptr指向一个动态分配的资源对象，也就是这个资源不会被多个unique_ptr对象同时占有，它所管理的资源只能在unique_ptr对象之间进行移动，不能拷贝，所以它**只提供了移动语义**。
* 资源对象的生命周期被唯一的一个unique_ptr对象托管着，一旦这个unique_ptr对象被销毁或者变成空对象，或者拥有了另一个资源对象，它所管理的资源对象同时一并销毁。资源对象要么随同unique_ptr对象一起销毁，要么在离开unique_ptr对象的管理范围时被销毁，从而保证了内存不会泄露。

* unique_ptr是以**模板形式**提供的，它有两种版本：
1. 普通版本，即标量版本，用于管理一个动态分配的资源对象；
2. 数组版本，是一个偏特化版本，用于管理一个动态分配的数组。

下面是一个unique_ptr的例子,此处的res是在栈上的局部变量，在main()结束时会被销毁，它管理的资源也会被释放掉。

```CPP
#include <iostream>
#include <memory> // 使用智能指针unique_ptr需引用本头文件
using namespace std;
struct Resource
{
    Resource() { cout << "构造Resource\n"; }
    ~Resource() { cout << "析构Resource\n"; }
};

int main()
{
    // 分配一个Resource类对象res，由unique_ptr所有。
    unique_ptr<Resource> res{ new Resource() };

    return 0;
} // Resource在这里被析构
```
## shared_ptr
