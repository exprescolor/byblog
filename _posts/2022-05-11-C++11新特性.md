---
layout:     post   				    # 使用的布局（不需要改）
title:      C++11新特性				# 标题 
subtitle:    #副标题
date:       2022-05-11 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea8.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - C++11
    - 八股
---

C++11的新特性也多次被问到，在这里做一个简要总结。

# 统一的初始化方法——赋值符号"="可省略

Talk is cheap. Show you the code : )

```CPP
class A {
    int i,j;
    A(int m, int n):i(m),j(n) {}
};
int main() {
    A* pa = new A {3,7};

    int arr[3] {1, 2, 3};   //C++11可以直接这么写，而不需要括号。
    vector<int> a {1, 2, 3};    //vector 同理
    string str {"Today"};       //stirng 同理
    unordered_map<string, int> pairs { {"a", 1}, {"b", 2}};
    int *p = new int[20] {1,2,3};
}

```

# 成员变量默认初始值
```CPP
class B {
public:
    int m = 1234;
    int n;
};

int main() {
    B b;
    cout << b.m << endl;    //输出值为1234,即对象的成员变量默认初始值为类中定义的m值
    return 0;
}
```
# auto 关键字

auto关键字用于定义变量，编译器可以自动判断变量类型。
```CPP
auto a = 100; //a的数据类型为int
auto p = new A();//p的数据类型为A*;
auto b = 1234LL;//b的数据类型为long long

unordered_map<string, int> pairs;
for(auto i = pairs.begin(); i != pairs.end(); i++) {
    cout << i->first << i->second << endl;
}
//这个i的类型是 unordered_map<string, int> :: iterator, 可见方便多了！
```
除了判断变量类型外，auto还有一个关键用途：
```CPP
class A {
    
};
//运算符重载
A operator + (int n, const A & a) {
    reutrn a;
}

template <class T1, class T2>
//->表明函数的返回值
auto add(T1 x, T2 y)->decltype(x + y) {
    return x + y;
}

auto i = add(10, 1.5);  //i的数据类型为float, 值为11.5
auto j = add(10, A());  //j的数据类型为A，因为10 + A()中的加号运算符已被重载，返回的是后面的加数A()。
//这个decltype是什么含义？请看下文。
```
# decltype关键字

如上文所述，decltype用于做**类型判别**。上述函数意为：add函数的返回值类型为decltype(x + y)。decltype会根据x + y的类型决定自己是什么类型。这样编译器以后从add模板实例化add函数时，就会根据x + y的表达式类型来推断出add函数返回值的类型。

```CPP
int i;
double j;
struct A {
    double k;
};
const A* a = new A();

decltype(a) x1; //定义了x1,变量类型为decltype(a)。由于a的数据类型为A*, 所以x1的类型就是A*.
decltype(i) x2; //定义了x2,变量类型为decltype(i)。由于i的数据类型为int,所以x2的类型为int.
decltype(a->k) x3;  //x3的类型是double
decltype((a->k)) x4 = t;    //用括号括起来的时候(双重括号..)要注意。这时x4的类型就是double的引用。
```

# 智能指针

* 智能指针都需要引入< memory >头文件。
* new出来的内存空间一定要在每条执行路径上delete掉。由于这么做太过复杂，于是引入智能指针的概念。
* 对智能指针来说，有两条原则：

1. 智能指针本身是**不能动态分配**的，否则它自身有不被释放的风险，进而可能导致它所管理对象不能正确地被释放；
2. 在栈上分配智能指针，让它指向堆上动态分配的对象，这样就能保证智能指针所管理的对象能够合理地被释放。

## unique_ptr

* unique_ptr是独占式的，即完全拥有它所管理对象的所有权，不和其它的对象共享。
* unique_ptr实现的是专属所有权语义，用于独占它所指向的资源对象的场合。某个时刻只能有一个unique_ptr指向一个动态分配的资源对象，也就是这个资源不会被多个unique_ptr对象同时占有，它所管理的资源只能在unique_ptr对象之间进行移动，不能拷贝，所以它**只提供了移动语义**。
* 资源对象的生命周期被唯一的一个unique_ptr对象托管着，一旦这个unique_ptr对象被销毁或者变成空对象，或者拥有了另一个资源对象，它所管理的资源对象同时一并销毁。资源对象要么随同unique_ptr对象一起销毁，要么在离开unique_ptr对象的管理范围时被销毁，从而保证了内存不会泄露。
由于unique_ptr禁止了"Copy"语义，所以"res2 = res1;"不能编译通过。
* unique_ptr是以**模板形式**提供的，它有两种版本：
1. 普通版本，即标量版本，用于管理一个动态分配的资源对象；
2. 数组版本，是一个偏特化版本，用于管理一个动态分配的数组。

下面是一个unique_ptr的例子,此处的res是在栈上的局部变量，在main()结束时会被销毁，它管理的资源也会被释放掉。

```CPP
#include <iostream>
#include <memory> // 使用智能指针unique_ptr需引用本头文件
using namespace std;
struct Resource
{
    Resource() { cout << "构造Resource\n"; }
    ~Resource() { cout << "析构Resource\n"; }
};

int main()
{
    // 分配一个Resource类对象res，由unique_ptr所有。
    unique_ptr<Resource> res{ new Resource() };

    return 0;
} // Resource在这里被析构
```
## shared_ptr

