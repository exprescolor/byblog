---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partA(2)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-07 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

### 练习2

在文件 env.c中，完成下列函数：

env_init(): 初始化所有的在envs数组中的 Env结构体，并把它们加入到 env_free_list中。 还要调用 env_init_percpu，这个函数要配置段式内存管理系统，让它所管理的段，可能具有两种访问优先级其中的一种，一个是内核运行时的0优先级，以及用户运行时的3优先级。

env_setup_vm(): 为一个新的用户环境分配一个页目录表，并且初始化这个用户环境的地址空间中的和内核相关的部分。

region_alloc(): 为用户环境分配物理地址空间

load_icode(): 分析一个ELF文件，类似于boot loader做的那样，我们可以把它的内容加载到用户环境下。

env_create(): 利用env_alloc函数和load_icode函数，加载一个ELF文件到用户环境中

env_run(): 在用户模式下，开始运行一个用户环境。

**env_init():**

作用：初始化envs数组，构建env_free_list链表，遍历 envs 数组中的所有 Env 结构体，把每一个结构体的 env_id 字段置0，因为要求所有的 Env 在 env_free_list 中的顺序，要和它在 envs 中的顺序一致，所以需要采用头插法，envs[0]应该在链表头部位置。实现如下：

```c
void
env_init(void)
{
	// Set up envs array
	// LAB 3: Your code here.
	env_free_list = NULL;
	for (int i = NENV - 1; i >= 0; i--) {	//前插法构建链表
		envs[i].env_id = 0;
		envs[i].env_link = env_free_list;
		env_free_list = &envs[i];
	}

	// Per-CPU part of the initialization
	env_init_percpu();    //加载全局描述符表(GDT)
}
```

**env_setup_vm():**

初始化新的用户环境的页目录表，不过只设置页目录表中和操作系统内核跟内核相关的页目录项，用户环境的页目录项不要设置，因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址UVPT，这个也会单独进行设置），所以我们可以参照 kern_pgdir 中的内容来设置 env_pgdir 中的内容。

```c
// 初始化环境e的内核虚拟内存布局。分配一个页面目录，相应地设置e->env_pgdir，并初始化新环境地址空间的内核部分。
//不要(现在)将任何内容映射到环境的虚拟地址空间的用户部分

static int
env_setup_vm(struct Env *e)
{
	int i;
	struct PageInfo *p = NULL;

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;

	// Now, set e->env_pgdir and initialize the page directory.
	//
	// Hint:
	//    - The VA space of all envs is identical above UTOP
	//	(except at UVPT, which we've set below).
	//	See inc/memlayout.h for permissions and layout.
	//	Can you use kern_pgdir as a template?  Hint: Yes.
	//	(Make sure you got the permissions right in Lab 2.)
	//    - The initial VA below UTOP is empty.
	//    - You do not need to make any more calls to page_alloc.
	//   -注意:一般情况下，pp_ref不会对只映射在UTOP之上的物理页面进行维护，但env_pgdir是一个例外—您需要为env_free增加env_pgdir的pp_ref以使其正确工作。

	// LAB 3: Your code here.

 	p->pp_ref++;
    	e->env_pgdir = (pde_t *)page2kva(p);  //刚分配的物理页作为页目录使用
    	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);  //继承内核页目录

     	// UVPT maps the env's own page table read-only.
     	// Permissions: kernel R, user R
     	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;  //唯一需要修改的是UVPT需要映射到当前环境的页目录物理地址e->env_pgdir处，而不是内核的页目录物理地址kern_pgdir处

	return 0;
}

```

**region_alloc():**

参数：

1. struct Env *e：需要操作的用户环境
2. void *va：虚拟地址
3. size_t len：长度

作用：操作e->env_pgdir，为[va, va+len)分配物理空间。

```c
// 为环境env分配len字节的物理内存，并将其映射到环境的地址空间中的虚拟地址va。
//不为零或以其他方式以任何方式初始化映射页。
//页面应该是可写的用户和内核。
static void
region_alloc(struct Env *e, void *va, size_t len)
{
	// LAB 3: Your code here.
	// (But only if you need it for load_icode.)
	//
	// 提示:如果调用者可以传递没有页面对齐的'va'和'len'值，那么使用region_alloc会更容易。你应该把va四舍五入，把(va + len)四舍五入
	void *begin = ROUNDDOWN(va, PGSIZE), *end = ROUNDUP(va + len, PGSIZE);
    	for (; begin < end; begin += PGSIZE) {
        	struct PageInfo *p = page_alloc(0);  //分配一个物理页
        	if (!p) panic("env region_alloc failed");
        	page_insert(e->env_pgdir, p, begin, PTE_W | PTE_U);//修改e->env_pgdir，建立线性地址begin到物理页pg的映射关系
    	}   
}
```

**load_icode():**

参数：

1. struct Env *e：需要操作的用户环境
2. uint8_t *binary：可执行用户代码的起始地址

作用：加载binary地址开始处的ELF文件,为每一个用户进程设置它的初始代码区，堆栈以及处理器标识位。每个用户程序都是ELF文件，所以我们要解析该ELF文件。。

为用户进程设置初始程序二进制、堆栈和处理器标志。此函数仅在运行第一个用户模式环境之前的内核初始化期间调用。此函数从ELF二进制映像加载所有可加载段到环境的用户内存中，从ELF程序头中指定的适当虚拟地址开始。与此同时，它清除这些段的任何部分，这些部分在程序头中被标记为被映射，但实际上不存在于ELF文件中。

```c
static void
load_icode(struct Env *e, uint8_t *binary)
{
    struct Elf *env_elf;
    struct Proghdr *ph, *eph;
    env_elf = (struct Elf*)binary;
    ph = (struct Proghdr*)((uint8_t*)(env_elf) + env_elf->e_phoff);
    eph = ph + env_elf->e_phnum;

    lcr3(PADDR(e->env_pgdir));

    for (; ph < eph; ph++) {
        if(ph->p_type == ELF_PROG_LOAD) {  //只加载LOAD类型的Segment
            region_alloc(e, (void *)ph->p_va, ph->p_memsz);
            memcpy((void*)ph->p_va, (void *)(binary+ph->p_offset), ph->p_filesz);  //因为这里需要访问刚分配的内存，所以之前需要切换页目录
            memset((void*)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);  //应该有如下关系：ph->p_filesz <= ph->p_memsz。搜索BSS段
        }
    }

    e->env_tf.tf_eip = env_elf->e_entry;
    lcr3(PADDR(kern_pgdir));

    // Now map one page for the program's initial stack
    // at virtual address USTACKTOP - PGSIZE.
    region_alloc(e, (void *)(USTACKTOP-PGSIZE), PGSIZE);
}
```

**env_create():**

参数：

1. uint8_t *binary：将要加载的可执行文件的起始位置
2. enum EnvType type：用户环境类型

作用：首先调用env_alloc分配 struct Env结构以及页目录，然后调用load_icode加载进程代码。

```c
void
env_create(uint8_t *binary, enum EnvType type)
{
    struct Env *e;
    env_alloc(&e, 0);
    e->env_type = type;
    load_icode(e, binary);  //加载从binary地址开始处的ELF可执行文件到该Env结构
}
```

**env_run(struct Env \*e):**

参数：

1. struct Env *e：需要执行的用户环境

作用：在用户模式运行用户进程

```c
void
env_run(struct Env *e)
{
    // panic("env_run not yet implemented");
    if (curenv && curenv->env_status == ENV_RUNNING) {
        curenv->env_status = ENV_RUNNABLE;
    }
    curenv = e;
    curenv->env_status = ENV_RUNNING;
    curenv->env_runs++;
    lcr3(PADDR(curenv->env_pgdir));   //加载线性地址空间
    env_pop_tf(&curenv->env_tf);  //弹出env_tf结构到寄存器
}
```

下面是调用用户代码之前的代码调用图。确保你理解了每一步的目的。

start (kern/entry.S)

i386_init (kern/init.c)

　　cons_init

​    　mem_init

　　env_init

　　trap_init （目前还未实现）

　　env_create

　　env_run

　　env_pop_tf

​		一旦你完成上述子函数的代码，并且在QEMU下编译运行，系统会进入用户空间，并且开始执行hello程序，直到它做出一个系统调用指令int。但是这个系统调用指令不能成功运行，因为到目前为止，JOS还没有设置相关硬件来实现从用户态向内核态的转换功能。当CPU发现，它没有被设置成能够处理这种系统调用中断时，它会触发一个保护异常，然后发现这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，我们把这个叫做"triple fault"。通常来说，接下来CPU会复位，系统会重启。

　　所以我们马上要来解决这个问题，不过解决之前我们可以使用调试器来检查一下程序要进入用户模式时做了什么。使用make qemu-gdb 并且在 env_pop_tf 处设置断点，这条指令应该是即将进入用户模式之前的最后一条指令。然后进行单步调试，处理会在执行完 iret 指令后进入用户模式。然后依旧可以看到进入用户态后执行的第一条指令了，该指令是一个cmp指令，开始于文件 lib/entry.S 中。 现在使用 b *0x... 设置一个断点在hello文件（obj/user/hello.asm）中的sys_cputs函数中的 int $0x30 指令处。这个int指令是一个系统调用，用来展示一个字符到控制台。如果你的程序运行不到这个int指令，说明有错误。

### 处理中断和异常

到目前为止，当程序运行到第一个系统调用 int $0x30 时，就会进入错误的状态，因为现在系统无法从用户态切换到内核态。所以你需要实现一个基本的异常/系统调用处理机制，使得内核可以从用户态转换为内核态。你应该先熟悉一下X86的异常中断机制。

