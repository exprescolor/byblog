---
layout:     post   				    # 使用的布局（不需要改）
title:      828-lab1-part2(1)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-28 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# 加载地址和链接地址

​		加载地址（存储地址）：加载地址是指代码存储所在的物理地址，由于ARM总是从0开始取值，即PC初始值为0，所以加载地址必须对应0地址，程序才能正确启动执行，之后才可以进行跳转，比如设置PC等于一个子程序的入口地址，而这个入口地址可能在rom中也可能在ram中。

​		链接地址（运行地址）：运行地址是链接器根据链接文件中指定的链接地址作为程序运行的起始地址，（作用）将程序中所有指令地址按照相对于这个起始地址的位置进行赋值，与程序实际运行时地址不一定相同，因为实际的程序运行起始地址总是0，而链接地址不一定为0，决定于程序需要在ROM还是RAM中运行）；如果链接地址与加载地址设为相同，则所有寻址地址在ROM上都有对应的指令存在，也就可以正常执行；但如果链接地址与加载地址不同，则所有指令的地址是根据链接地址确定的，在ROM上不存在与之对应的代码入口（即使链接地址正好还处于ROM代码中，接下来执行的指令也将是不正确的和存在偏移的）
​		加载地址是程序实际执行时的真实起始地址且必须为0；而链接地址的作用就是在链接过程中以链接地址为基准，确定程序中所有指令的相对位置，加载地址与链接地址相同时，该相对位置处才存在对应的指令，否则该相对位置处将不存在正确指令

# part3： the kernel

## 虚拟内存

​		在运行boot loader时，boot loader中的链接地址（虚拟地址）和加载地址（物理地址）是一样的。但是内核的链接地址(由objdump打印)和它的加载地址之间存在(相当大的)差异。

​		操作系统内核通常喜欢在非常高的虚拟地址(比如0xf0100000)上进行链接和运行，以便将处理器虚拟地址空间的较低部分留给用户程序使用。

​		许多机器在地址0xf0100000处没有任何物理内存，因此我们不能指望能够将内核存储在那里。相反，我们将使用处理器的内存管理硬件将虚拟地址0xf0100000(内核代码期望在其上运行的链接地址)映射到物理地址0x00100000(boot loader将内核加载到物理内存中)。

​		实际上，我们将映射PC的整个底层256MB物理地址空间，从物理地址0x00000000到0x0fffffff，分别映射到虚拟地址0xf0000000到0xffffffff。

​		现在，我们只映射第一个4MB的物理内存，这足够让我们启动和运行。我们使用kern/entrypgdir.c中手工编写的、静态初始化的页面目录和页面表来实现这一点。kern/entry.S设置CR0_PG标志，内存引用被视为物理地址(严格地说，它们是线性地址，但是boot/boot.S建立了一个从线性地址到物理地址的恒等映射，我们永远不会改变它)。设置CR0_PG之后，内存引用就是虚拟地址，由虚拟内存硬件转换为物理地址。entry_pgdir将范围为0xf0000000到0xf0400000的虚拟地址转换为物理地址0x00000000到0x00400000，以及将虚拟地址0x00000000到0x00400000转换为物理地址0x00000000到0x00400000。任何不在这两个范围内的虚拟地址都会导致一个硬件异常。

###练习7

​		使用QEMU和GDB跟踪到JOS内核，并在movl %eax %cr0处停止。检查0x00100000和0xf0100000处的内存。现在，使用stepi GDB命令单步执行该指令。再次检查0x00100000和0xf0100000处的内存。确保你明白刚刚发生了什么。

​		在新映射建立之后，如果映射没有就位，第一个不能正常工作的指令是什么?在kern/entry.S中注释掉movl %eax， %cr0，验证一下。

​		我们在0x100025处下断点，也就是movl %eax %cr0这个指令的地址，然后查看0x00100000和0xf0100000处的内存，内存数据不相同，再执行si，单步执行完movl指令，再查看0x00100000和0xf0100000处的内存，发现内存数据相等：

​		![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd9jttqqwaj30nl0cvjsq.jpg)

​		原因是这句代码的作用是开启分页，开启分页前，高地址的内容未映射，开启分页之后，虚拟地址映射到了物理内存，所以内存的内容是一样的。

​		把这句代码注释掉，重新make一下，下断点到0x100025，单步执行发现报错：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd9k847toij30nn0axwfe.jpg)

回到qemu这边报错：尝试在RAM或ROM之外的0xf010002c处执行代码，访问的地址超出内存了。

![屏幕截图1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd9k8s5o2pj30md0420tc.jpg)

## 格式化打印到控制台

​		大多数人认为printf()这样的函数是理所当然的，有时甚至认为它们是C语言的“原语”。但是在操作系统内核中，我们必须自己实现所有的I/O。

​		通读kern / printf.c, lib / printfmt.c, kern /console.c，并确保你了解他们的关系。在以后的实验室中，我们将清楚地了解为什么printfmt.c位于lib目录中。

### 练习8

​		我们省略了一小段代码——使用“%o”形式的模式打印八进制数所必需的代码。查找并填充这段代码。

​		先看一下这段代码：

```
// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
			putch('X', putdat);
			putch('X', putdat);
			break;
			
//填充代码：
case 'o':
     // Replace this with your code.
     num = getuint(&ap, lflag);  //从ap指向的可变字符串中获取输出的值
     base = 8;  //设置基数为8
     goto number;
```

然后执行make grade验证

1. 解释printf.c和console.c之间的接口。具体来说，console.c导出什么功能?printf.c是如何使用这个函数的?

   ​	console.c导出了cputchar,getchar等函数，printf.c调用了console.c中的cputchar函数。

2. 解释console.c中的

   ```
   if (crt_pos >= CRT_SIZE) {
   	int i;
       memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
       for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
       	crt_buf[i] = 0x0700 | ' ';
       crt_pos -= CRT_COLS;
   }
   ```

   这个函数实现了滚屏的功能。文本模式下一页屏幕最多显示25*80个字符，超出时，需要将2~25行往上提一行，memmove把内容向上移动一行，最后一行用空格填充。

3. 跟踪以下代码：

   ```
   int x = 1, y = 3, z = 4;
   cprintf("x %d, y %x, z %d\n", x, y, z);
   ```

   Q:在调用cprintf()时，fmt指向什么?ap指向什么?

   fmt指向的是参数中的格式字符串，也就是"x %d, y %x, z %d\n"，而ap指向fmt的后一个参数地址

   Q:列出(按执行顺序)对cons_putc、va_arg和vcprintf的每个调用。对于cons_putc，也列出它的参数。对于va_arg，列出调用之前和之后ap指向的内容。对于vcprintf，列出它的两个参数的值。

   调用va_arg前，ap存放待显示的x,y,z三个参数的内容1,3,4，调用va_arg之后，待显示的参数剩了y和z，即3,和4。

   vcprintf的两个参数是格式字符串fmt和参数列表ap。

4. 运行以下代码：

   ```
    unsigned int i = 0x00646c72;
    cprintf("H%x Wo%s", 57616, &i);
   ```

Q：输出是什么?按照前面的练习一步一步地解释这个输出是如何得到的。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd9tb1hqihj305000ujr6.jpg)

​		把代码添加到kern\monitor.c中，重新make，得到输出He110 World。第一个参数%x输出的是16进制的57616也就是e110，第二个参数是%s的&i，是变量i的内存地址，题目中说x86是小端序，也就是最高位字节存放在最高位字节地址上，int类型的i有四个字节，则分别存放了0x72,0x6c,0x64,0x00，对应字符为rld。字符串拼接起来就成了输出是He110 World。

Q：输出取决于x86是little-endian这一事实。如果x86是big-endian，为了得到相同的输出，您会将i设置为什么?您需要将57616更改为不同的值吗?

​		如果是大端序，57616不需要改变，i则改为0x726c6400。

5. 在下面的代码中，'y='后面要打印什么?(注意:答案不是一个特定的值)为什么会这样?

   ```
    cprintf("x=%d y=%d", 3);
   ```

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd9tmchrjvj307z00nq2q.jpg)

y输出的是x地址往上4个字节的内容。

6. 假设GCC改变了它的调用约定，以声明的顺序将参数推入栈中，最后一个参数最后被推入。你将如何改变cprintf或它的接口，使它仍然有可能传递一个可变数量的参数?

​       放一个表示参数数量的变量。

## 栈

​		在这个实验的最后练习中,我们将更详细地探讨C语言使用x86上的堆栈的方式,并在这一过程中写一个新的kernel monitor,输出一个堆栈回溯。

### 练习9

确定内核初始化堆栈的位置，以及堆栈在内存中的确切位置。内核如何为它的堆栈保留空间?堆栈指针初始化后指向该保留区域的哪个“端”?

初始化堆栈的位置：

	movl	$0x0,%ebp			# nuke frame pointer
	# Set the stack pointer
	movl	$(bootstacktop),%esp
堆栈的位置：

```
.data
###################################################################
# boot stack
###################################################################
	.p2align	PGSHIFT		# force page alignment
	.globl		bootstack
bootstack:
	.space		KSTKSIZE
	.globl		bootstacktop   
bootstacktop:
```

这里给出了bootstacktop以及栈的大小bootstacktop，为32kb，在内存中声明了堆栈的空间。

我们查看kernel.asm：

```
# Set the stack pointer
	movl	$(bootstacktop),%esp
f0100034:	bc 00 00 11 f0       	mov    $0xf0110000,%esp
```

得到栈顶是0xf0110000，所以栈的位置是从0xf0110000往下的32kb，指针指向的是栈顶的位置。