---
layout:     post
title:      够不够你说了算
subtitle:   golang的小基础，闲来翻看一下
date:       2019-08-03
author:     HH
header-img: img/post-bg-golang.png
catalog: true
tags:
    - Golang
    - 语言基础
---

# 简介

> 从微信公众号`Go程序员开发`搬过来的，一些小基础，闲暇之时可以翻看巩固基础。

## 前言：为什么一定要学Go

>Go语言是谷歌2009发布的第二款开源编程语言。
>Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

#### 与其他语言相比的优势

**学习曲线**

它包含了类C语法、GC内置和工程工具。这一点非常重要，因为Go语言容易学习，所以一个普通的大学生花一个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。

**效率**

Go拥有接近C的运行效率和接近PHP的开发效率，这就很有利的支撑了上面大家追求快速的需求。

**出身名门、血统纯正**

之所以说Go语言出身名门，是因为我们知道Go语言出自Google公司，这个公司在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。我们看看Go语言的主要创造者，血统纯正这点就可见端倪了。

**自由高效：组合的思想、无侵入式的接口**

Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程以及函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。

**强大的标准库**

这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。

**部署方便：二进制文件、Copy部署**

我相信这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。

**简单的并发**

它包含了降低心智的并发和简易的数据同步，我觉得这是Go最大的特色。之所以写正确的并发、容错和可扩展的程序如此之难，是因为我们用了错误的工具和错误的抽象，Go可以说这一块做的相当简单。

**稳定性**

Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。

#### Go语言适合用来做什么？

- 服务器编程：以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。
- 分布式系统：数据库代理器等。
- 网络编程：这一块目前应用最广，包括Web应用、API应用、下载应用、内存数据库。
- 云平台：google开发的groupcache，couchbase的部分组建云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。

#### Go语言成功的项目

>nsq：bitly开源的消息队列系统，性能非常高，目前他们每天处理数十亿条的消息
>docker：基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建
>packer：用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者
>skynet：分布式调度框架
>Doozer：分布式同步工具，类似ZooKeeper
>Heka：mazila开源的日志处理系统
>cbfs：couchbase开源的分布式文件系统
>tsuru：开源的PAAS平台，和SAE实现的功能一模一样
>groupcache：memcahe作者写的用于Google下载系统的缓存系统
>god：类似redis的缓存系统，但是支持分布式和扩展性
>gor：网络流量抓包和重放工具

#### 哪些大公司在用go语言？

- Google
  这个不用多做介绍，作为开发Go语言的公司，当仁不让。Google基于Go有很多优秀的项目，比如：[kubernetes](https://github.com/kubernetes/kubernetes)  ，大家也可以在[Github](https://github.com/google/)上  查看更多Google的Go开源项目。

- Facebook
  Facebook也在用，为此他们还专门在Github上建立了一个开源组织[facebookgo](https://github.com/facebookgo)，大家可以通过  访问查看facebook开源的项目，比如著名的是平滑升级的grace。

- 腾讯
  腾讯作为国内的大公司，还是敢于尝试的，尤其是[Docker](http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice)容器化这一块，他们在15年已经做了docker万台规模的实践，具体可以参考

- 百度
  目前所知的百度的使用是在运维这边，是百度运维的一个[BFE](http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend)项目，负责前端流量的接入。他们的负责人在2016年有分享，大家可以看下这个

- 阿里
  阿里巴巴具体的项目不太清楚，不过听说其系统部门、CDN(Content Delivery Network)等正在招Go方面的人。

- 京东
  京东云消息推送系统、云存储，以及京东商城等都有使用Go做开发。

- 小米
  小米对Golang的支持，莫过于[运维监控系统](http://open-falcon.com/)的开源，此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。

- 360
  360对Golang的使用也不少，一个是开源的日志搜索系统[Poseidon](https://github.com/Qihoo360/poseidon)，托管在Github上。

## 第一章 环境搭建

#### linux安装go语言环境

```
# yum install mercurial
# yum install git 
# yum install gcc 
# cd /usr/local/
# wget https://go.googlecode.com/files/go1.9.1.linux-amd64.tar.gz
# tar -zxvf go1.9.1.linux-amd64.tar.gz
```

建立Go语言的工作空间（workspace，也就是GOPATH环境变量指向的目录）Go语言代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录：
src ---- 里面每一个子目录，就是一个包。包内是Go语言的源码文件
pkg ---- 编译后生成的，包的目标文件
bin ---- 生成的可执行文件
这里，我们在/home目录下，建立一个名为go（可以不是go, 任意名字都可以）的文件夹，然后再建立三个子文件夹（子文件夹名必须为src、pkg、bin）。

```
# cd /home/
# mkdir go
# cd go/
# mkdir bin
# mkdir src
# mkdir pkg
```

添加PATH环境变量和设置GOPATH环境变量

```
# vim /etc/profile 
export GOROOT=/usr/local/go        ##Golang安装目录
export PATH=$GOROOT/bin:$PATH
export GOPATH=/home/go  ##Golang项目目录
# source /etc/profile        ##刷新环境变量
# go version        ##查看go版本
go version go1.9.1 linux/amd64
# go env
```

进入项目目录

```
# cd /home/go/src/    
# mkdir project
# cd project/
# mkdir test
# cd test/
# mkdir main
# cd main/
# touch main.go
```

进入main.go编写第一个程序

```
# vim main.go 
package main
import "fmt"
func main() {
    fmt.Println("Hello World")
}
```

使用go install工具编译此程序

```
# cd /home/go/
# go install project/test/main
```

进入bin目标查看编译好的二进制文件 ( cd /home/go/bin )

```
# cd bin/
# ls
main
```

使用shell命令 ./ 运行编译好的二进制文件

```
# ./main 
Hello World
```

#### Windows搭建Go语言环境

[Go程序员开发](https://mp.weixin.qq.com/s?__biz=MzU0ODc4MjE0Nw==&mid=2247483721&idx=1&sn=b2d3681507607d0d6021b78cb4047acb&scene=21#wechat_redirect)中有MSI(Microsoft installer)和ZIP两种安装方式。我这里只搬ZIP的方式（看不到底层的安装过程我不放心，所以我通常会选择ZIP，无论哪种语言安装包）。

- 下载安装包（根据操作系统选择相应Go语言版本）
  下载地址：https://golang.google.cn/
  下载最新版本：go1.9.2.windows-386.zip

- 将下载后的文件解压，放到了C:\根目录下 （可以不是C:\根目录, 任意目录都可以）
  注意：目录路径文件命名不能包含中文字符

- 设置环境变量
  - 设置GOROOT    C:\go
  - 将bin路径添加到Path目录中   ;%GOROOT%\bin;
  - 设置GOPATH 在目录中创建一个文件夹src，用来存放我们的源码文件。
  - 设置GOPROXY   https://goproxy.io

- 验证是否安装成功，输出环境信息则安装成功，打开终端运行 go env 命令

#### Mac搭建Go语言环境

- 下载安装包 ( 据操作系统选择相应Go语言版本 )
  下载地址：https://golang.google.cn/
  下载最新版本：go1.9.2.darwin-amd64.pkg

- 打开此pkg文件 并跟随提示来安装Go工具

- 配置Go环境变量GOPATH和GOBIN

  - 打开终端，输入 cd ~ 命令 回到用户家目录：

  - 查看是否有.bash_profile文件：ls -all

  - 有则跳过创建，没有则：

    ```
    创建：touch .bash_profile
    编辑：open -e .bash_profile
    自定义GOPATH和GOBIN位置：
    export GOPATH=/Users/oldboy/Desktop/go        
    export GOBIN=$GOPATH/bin
    export PATH=$PATH:$GOBIN
    ```

  - 编译：source .bash_profile

- 查看Go环境信息： go env

终于完成了第一步了，开始语言的正式学习吧。

## 第二章 Go语言基础

#### Go语言介绍

**主要特性**

1. 可直接编译成机器码，不依赖其他库，glibc的版本有一定要求，部署就是扔一个文件上去就完成了。
2. 静态类型语言，但是有动态语言的感觉，静态类型的语言就是可以在编译的时候检查出来隐藏的大多数问题，动态语言的感觉就是有很多的包可以使用，写起来的效率很高。ps:静态语言中变量的类型不能轻易改变。
3. 语言层面支持并发，这个就是Go语言最大的特色，可以充分的利用多核，很容易的使用并发。
4. 内置runtime，支持垃圾回收，这属于动态语言的特性之一吧，虽然目前来说GC不算完美，但是足以应付我们所能遇到的大多数情况，特别是Go1.1之后的GC。
5. 简单易学，Go语言的作者都有C的基因，那么Go自然而然就有了C的基因，那么Go关键字是25个，但是表达能力很强大，几乎支持大多数你在其他语言见过的特性：继承、重载、对象等。丰富的标准库，Go目前已经内置了大量的库，特别是网络库非常强大。
6. 内置强大的工具，Go语言里面内置了很多工具链，最好的应该是gofmt工具，自动化格式化代码，能够让团队review变得如此的简单，代码格式一模一样，想不一样都很困难。跨平台编译，如果你写的Go代码不包含cgo，那么就可以做到window系统编译linux的应用，如何做到的呢？Go引用了plan9的代码，这就是不依赖系统的信息。
7. 内嵌C语言支持，前面说了作者是C语言的作者，所以Go语言里面也可以直接包含C语言代码，利用现有的丰富的C语言库。

**标准命令解释**

```
Go is a tool for managing Go source code.
Usage:
	go <command> [arguments]
The commands are:
	bug         start a bug report
	build       compile packages and dependencies
	clean       remove object files and cached files
	doc         show documentation for package or symbol
	env         print Go environment information
	fix         update packages to use new APIs
	fmt         gofmt (reformat) package sources
	generate    generate Go files by processing source
	get         download and install packages and dependencies
	install     compile and install packages and dependencies
	list        list packages or modules
	mod         module maintenance
	run         compile and run Go program
	test        test packages
	tool        run specified go tool
	version     print Go version
	vet         report likely mistakes in packages
Use "go help <command>" for more information about a command.
Additional help topics:
	buildmode   build modes
	c           calling between Go and C
	cache       build and test caching
	environment environment variables
	filetype    file types
	go.mod      the go.mod file
	gopath      GOPATH environment variable
	gopath-get  legacy GOPATH go get
	goproxy     module proxy protocol
	importpath  import path syntax
	modules     modules, module versions, and more
	module-get  module-aware go get
	packages    package lists and patterns
	testflag    testing flags
	testfunc    testing functions
Use "go help <topic>" for more information about that topic.
```

简单翻译几个常用的

>go env 用于打印Go语言的环境信息。
>
>go run 命令可以编译并运行命令源码文件。
>
>go get 可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。
>
>go build 命令用于编译我们指定的源码文件或代码包以及它们的依赖包。
>
>go install 用于编译并安装指定的代码包及它们的依赖包。
>
>go clean 命令会删除掉执行其它命令时产生的一些文件和目录。
>
>go doc 命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。
>
>go test 命令用于对Go语言编写的程序进行测试。
>
>go list 命令的作用是列出指定的代码包的信息。
>
>go fix 会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。
>
>go vet 是一个用于检查Go语言源码中静态错误的简单工具。
>
>go tool pprof 命令来交互式的访问概要文件的内容。

这里说一下编译和安装的个人理解，编译是从源代码编程可执行的二进制语言。安装会初始化一些环境变量。

#### Go语言命名

**25个关键字**

> package ：用于声明包文件
> import ：用于导入其它package
>
> interface ：用于定义接口
> struct ：用于定义数据类型
>
> var ：用于变量的声明
> const ：用于常量的声明
> type ：用于声明类型
> func ：用于声明函数和方法 
>
> chan ：用于声明chan类型数据
> map ：用于声明map类型数据
>
> return ：用于从函数返回
> defer ：延迟调用，在函数退出之前执行
> go ：创建一个协程
> select ：用于选择不同类型的通讯
>
> break、case、continue、for、fallthrough、else、if、switch、goto、default ：用于流程控制
> range ：用于遍历array、slice、map、channel数据

**37个保留字**

在下一小节内置类型详细解说。

**语言命名规范**

Go语言的包（package）、变量、常量、自定义类型、函数、方法的命名方式遵循以下规则：

- 首字符可以是任意的Unicode字符或者下划线
- 剩余字符可以是Unicode字符、下划线、数字
- 字符长度不限
- 不要使用Go语言的关键字和保留字命名

#### 内置类型和函数

上一小节的37个保留字分为Constants，Types，Functions三种。

首先来看一下Constants吧，一共有四个，true，false，iota，nil。然后是Types有int，int8，int16，int32，int64，unit，unit8，uint16，uint32，uint64，uintptr，float32，float64，complex64，complex128，bool，byte，rune，string，error。最后是Functions，有make，len，cap，new，append，copy，close，delete，complex，real，imag，panic，recover。

| 类型          | 长度（字节） | 默认值                                                    | 说明                                             |
| ------------- | ------------ | --------------------------------------------------------- | ------------------------------------------------ |
| bool          | 1            | false                                                     | bool类型代表逻辑值不能与int转换                  |
| byte          | 1            | 0                                                         | int8的别名                                       |
| int8，uint8   | 1            | 0                                                         | int8:-128~127 unit8:0~255                        |
| int16，uint16 | 2            | 0                                                         | int16:-32768~32767 uint16:0~65535                |
| rune          | 4            | 0                                                         | int32的别名                                      |
| int32，uint32 | 4            | 0                                                         | int32:-2147483648~2147483647 uint32:0~4294967295 |
| int64，uint64 | 8            | 0                                                         | 很大                                             |
| float32       | 4            | 0                                                         | 单精度浮点型                                     |
| float64       | 8            | 0                                                         | 双精度浮点型                                     |
| complex64     | 8            | 0+0i                                                      | 复数类型                                         |
| complex128    | 16           | 0+0i                                                      | 复数类型                                         |
| uintptr       | 4或8         | 0                                                         | 指针类型，存储指针的uint32或uint64整数           |
| array         |              | 默认值根据数据类型来定var array [4] int 默认值为[0 0 0 0] | 值类型                                           |
| struct        |              | 默认值要根据其数据类型来确定                              | 值类型                                           |
| string        |              | “”                                                        | UTF-8字符串                                      |
| slice         |              | nil                                                       | 引用类型                                         |
| map           |              | nil                                                       | 引用类型                                         |
| channel       |              | nil                                                       | 引用类型                                         |
| interface     |              | nil                                                       | 接口类型                                         |
| function      |              | nil                                                       | 函数类型                                         |
| error         |              | nil                                                       | 错误类型                                         |
| int，uint     | 4或8         | 0                                                         | int有符号整数，uint无符号整数                    |

**内置函数**

Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。

| 函数           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| append         | 用来追加元素到slice中，返回修改后的slice                     |
| close          | 主要用来关闭channel                                          |
| delete         | 从map中删除key对应的value                                    |
| panic          | 停止常规的goroutine。panic和recover用来做错误处理            |
| recover        | 允许程序定义goroutine的panic动作                             |
| imag           | 返回虚部                                                     |
| real           | 返回实部                                                     |
| make           | 分配内存，返回Type本身，只能应用于slice,map,channel          |
| new            | 分配内存，主要用来分配值类型，比如int，struct。返回执行type的指针 |
| cap            | 求最大容量，比如array，slice，channel返回最大容量            |
| copy           | 复制和连接slice，返回复制的数目                              |
| len            | 求长度，例如string，array，slice，map，channel的长度         |
| print，println | 底层打印函数，在部署环境中建议使用fmt包                      |

**内置接口error**

只要实现了Error()函数，返回值为String的就实现了error接口

```
type error interface{
    Error() String
}
```

#### Go语言特殊函数介绍

**main函数**

Go语言程序的默认入口函数（主函数）：func main()，函数体用｛｝一对括号包裹。只能应用于package main

```
package main
func main(){
    //函数体
}
```

**init函数**

go语言中`init`函数用于包`package`的初始化，该函数是go语言的一个重要特性。

init函数有下面的特征：

1、init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等

2、每个包可以拥有多个init函数

3、包的每个源文件也可以拥有多个init函数

4、同一个包中多个init函数的执行顺序go语言没有明确的定义（说明）

5、不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序

6、init函数不能被其他函数调用，而是在main函数执行之前，自动被调用

**init函数和main函数的异同**

相同点：
两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。

不同点：
init函数可以应用于任意包中，且可以重复定义多个。
main函数只能用于main包中，且只能定义一个。

**两个函数的执行顺序**

对同一个go文件的`init()`调用顺序是从上到下的。

对同一个`package`中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的`init()`函数。

对于不同的`package`，如果不相互依赖的话，按照main包中"先import的后调用"的顺序调用其包中的`init()`，如果`package`存在依赖，则先调用最早被依赖的`package`中的`init()`，最后调用main函数。

如果init函数中使用了`println()`或者`print()`你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。

#### Go语言运算符

详细的在[Go程序员开发](https://mp.weixin.qq.com/s?__biz=MzU0ODc4MjE0Nw==&mid=2247483760&idx=1&sn=ae0a5c66dade22df83ed516bc1c75504&scene=21#wechat_redirect)中都有介绍，Go 语言内置的运算符有：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、其他运算符。我这里只搬两个我比较容易记混的。

其他运算符

| 运算符 | 描述                       |
| ------ | -------------------------- |
| &      | 取地址符，返回变量存储地址 |
| *      | 取值符，返回指针指向的变量 |

特殊表示符

“_”是特殊标识符，又称占位符（空标识符号），用来忽略结果。

- 特殊标识符应用在import中

在Go语言里，import的作用是导入其他package。

特殊标识符（如：import  _  lemonhh/golang）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用  import _ 引用该包。即使用（import _  包路径）只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。

示例：
代码目录结构

```
src 
|
+--- main.go            
|
+--- lemonhh
       |
        +--- lemonhh.go
```

main.go

```
package main

import _ "./lemonhh"

func main() {
    // lemonhh.Print() 
    //编译报错：./main.go:6:5: undefined: lemonhh
}
```

lemonhh.go

```
package lemonhh

import "fmt"

func init() {
    fmt.Println("The lemonhh welcomes you.")
}

func Print() {
    fmt.Println("Hello!")
}
```

运行结果：

```
The lemonhh welcomes you.
```

- 特殊标识符应用在代码中

```
package main

func main() {
    str, _ := lemonhh()
    _ = str
}

func lemonhh() (str string, err error) {
    str = "The old boy welcomes you."
    err = nil
    return
}
```

> 解释：
>
> 占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给占位符，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给占位符。
>
> 第一个占位符：这种情况是忽略函数返回值，函数返回两个结果，而你只想要一个结果。
>
> 第二个占位符：这种情况是忽略未使用的局部变量，如果声明的局部变量，不使用，编译器是会报错。

## 第三章 Go语言程序结构

#### Go语言变量

**变量**来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。

Go语言是静态类型语言，不能在运行期间改变变量类型。使用关键字 var 定义变量，自动初始化为零值。如果提供初始化值，可省略变量类型，由编译器自动推断。

Go语言中变量可以在三个地方声明：

> 函数外定义的变量称为全局变量
>
> 函数内定义的变量称为局部变量
>
> 函数定义中的变量称为形式参数

**变量声明**

- 第一种，指定变量类型，声明后若不赋值，使用默认值。

  ```
  var name string
  ```

- 第二种，根据值自行判定变量类型。

  ```
  var age = 18
  ```

- 第三种，变量声明并赋值

  ```
  var class string = "Linux"
  ```

- 第四种，一次性声明多个变量

  ```
  var Mon, Tues, Wed, Thur, Fri, Sat, Sun int
  
  var (
      Monday    int
      Tuesday   int
      Wednesday int
      Thursday  int
      Friday    int
      Saturday  int
      Sunday    int
  )
  ```

- 第五种，短声明变量
  在函数内部，可以使用更简略的 ":=" 方式定义变量。":=" 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。

  ```
  package main
  
  func main() {
      name := "lemonhh"
      age, class := 18, "Linux"
      _, _, _ = name, age, class
  }
  ```

  注意：":=" 结构不能在函数外使用。

- 第六种，形式参数

  ```
  package main
  
  func main() {
  }
  
  func sum(a, b int) (c int) {
      c = a + b
      return
  }
  ```

**变量优先级**

Go语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。实例如下

```go
package main

import "fmt"

// 声明全局变量
var variable string = "全局变量"

func main() {
    // 声明局部变量
    var variable string = "局部变量"
    fmt.Printf("结果：%s\n", variable)
}
```

运行结果：

```
结果：局部变量
```

多变量赋值时，先计算所有相关值，然后再从左到右依次赋值。

```go
package main

import "fmt"

func main() {
    data, i := [4]string{"course", "Python", "Linux", "Golang"}, 0
    i, data[i] = 2, "lemonhh"
    fmt.Printf("i：%v，data：%v\n", i, data)
}
```

#### Go语言常量

**常量**是一个简单值的标识符，在程序运行时，永远是只读的，不能修改。

使用 const 关键字定义常量。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

**常量定义**

- 第一种，显式类型定义

  ```
  const name string = "lemonhh"
  ```

- 第二种，隐式类型定义，一个未指定类型的常量由上下文来决定其类型

  ```
  const age = 18
  ```

- 第三种，一次性定义多个常量

  ```
  const Mon, Tues, Wed, Thur, Fri, Sat, Sun = 1, 2, 3, 4, 5, 6, 7
  
  const (
      name = "lemonhh"
      age  = 18
  )
  ```

- 第四种，常量可以用len()，cap()，unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：

  ```
  const (
      a = "abc"
      b = len(a)
      c = unsafe.Sizeof(b)
  )
  ```

  > len()的返回类型是int,在这里测出来的是int64，即c=8

**常量技巧**

未使用的局部常量不会引发编译错误。实例如下：

```
package main

func main() {
    const str = "The old boy welcomes you."
}
```

在常量组中，如不提供类型和初始化值，那么视作与上一个常量相同。实例如下：

```
package main

import (
    "fmt"
)

func main() {
    const (
        name = "lemonhh"
        nickname
    )
    fmt.Printf("name : %s, nickname : %s\n", name, nickname)
}
```

运行结果：

```
name : lemonhh, nickname : lemonhh
```

**特殊常量**

特殊常量，iota，可以认为是一个可以被编译器修改的常量。
在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。

关键字 iota 定义常量组中从 0 开始按行计数的自增枚举值。实例如下：

```
package main

import (
    "fmt"
)

const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)

func main() {
    fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)
}
```

运行结果：

```
0 1 2 3 4 5 6
```

在同一常量组中，可以提供多个 iota，它们各自增长。实例如下：

```
package main

import (
    "fmt"
)

const (
    A1, B1 = iota, iota << 10
    A2, B2
)

func main() {
    fmt.Println(A1, B1, A2, B2)
}
```

运行结果：

```
0 0 1 1024
```

如果 iota 自增被打断，须显式恢复。实例如下：

```
package main

import (
    "fmt"
)

const (
    Sun = iota
    Mon
    Tues
    Wed = "Wednesday"
    Thur
    Fri = iota
    Sat
)

func main() {
    fmt.Println(Sun, Mon, Tues, Wed, Thur, Fri, Sat)
}
```

运行结果：

```
0 1 2 Wednesday Wednesday 5 6
```

#### Go语言包和文件

**工作空间**

Go语言工作空间：编译工具对源码目录有严格要求，每个工作空间 (workspace) 必须由bin、pkg、src三个目录组成。

src ---- 项目源码目录，里面每一个子目录，就是一个包，包内是Go语言的源码文件。
pkg ---- Go语言编译的.a 中间文件存放目录，可自动生成。
bin ---- Go语言编译可执行文件存放目录，可自动生成。

**包结构**

包是结构化代码的一种方式：每个程序都由包的概念组成，可以使用自身的包或者从其它包中导入内容。

如同其它一些编程语言中的类库或命名空间的概念，每个Go文件都属于且仅属于一个包。一个包可以由许多以.go为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

包声明 "package + 包名" ，必须在源文件中非注释的第一行指明这个文件属于哪个包。
如：package main。package main表示一个可独立执行的程序，每个Go应用程序都包含一个名为 main 的包。

同一个包（package）下面，可以有非常多的不同文件，只要每个文件的头部都有相同name就可以，如 "package lemonhh" 。文件夹名字可以和这个package名称不一致。

**标准库**

在Go的安装文件里包含了一些可以直接使用的包，即标准库。Go语言标准库包，覆盖了几乎所有的基础库，提供了丰富广泛的功能特性。标准库的内容还可能继续增加，大家可以通过在线查阅库API或使用godoc（包含在Go发布包中）来获取最新信息以及全面了解每个包所具备的功能。

**第三方库**

通过"go get + 完整包名"保存下载第三方库。

在执行go get 命令之前，确保你的电脑配置了环境变量GOPATH，并且安装git。

**导出包**

在Go语言中根据首字母的大小写来确定可以访问的权限。如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用。该规则适用于全局变量、全局常量、类型、结构字段、函数、方法等。

可以简单的理解成，首字母大写是公有的，首字母小写是私有的。

在导入包之后，你只能访问包所导出的名字，任何未导出的名字是不能被包外的代码访问的。

**导入包**

使用包成员前，必须先用import关键字导入，但不能形成导入循环。

import用法:

第一种，导入系统包。

```
import "fmt"  
```

第二种，相对路径导入包，导入同一目录下 test 包中的内容。

```
import "./test" 
```

第三种，绝对路径导入包，导入 gopath/src/lemonhh/python 包中的内容。

```
import "lemonhh/python"    
```

第四种，导入包并启用别名。

```
import f "fmt"    
```

导入fmt，并给他启别名ｆ

```
import . "fmt"  
```

将fmt启用别名"."，这样就可以直接使用其内容，而不用再添加fmt。如fmt.Println可以直接写成Println。

第五种，`"import _"`

```
import  _ "fmt" 
```

表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。

注意：未使用的导入包，会被编译器视为错误 (不包括 `"import _"`)。实例如下：

```
package main

import (
    "fmt"
)

func main() {
}
```

编译错误：

```
./main.go:4:2: imported and not used: "fmt"
```

#### 编写一个Go程序

**编码格式**

Go语言源码文件编码格式必须是 `UTF-8` 格式，否则会导致编译器出错。

**结束语句**

在 Go 程序中，一行代表一个语句结束。每个语句不需要像其它语言一样以分号 `";"`结尾，因为这些工作都将由 Go 编译器自动完成。

如果你打算将多个语句写在同一行，它们则必须使用 `";"`人为区分。实例如下：

```
package main

import (
    "fmt"
)

func main() {
    fmt.Println("lemonhh")
    fmt.Println("Linux");
    fmt.Println("Java");fmt.Println("DBA")
    fmt.Println("Python");fmt.Println("Golang");
}
```

**代码注释**

注释不会被编译，每一个包应该有相关注释。

Go语言代码注释支持 `"//"、"/**/"` 两种注释方式，不能嵌套。

单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。实例如下：

```
// 单行注释

/*
   多行注释
*/
```

**编写 Hello World**

1、创建文件 hello.go，不写入任何内容。运行 go build hello.go 命令进行编译。将会输出如下错误：

```
can't load package: package main: 
hello.go:1:1: expected 'package', found 'EOF'
```

因为Go语言中，所有文件必须隶属于某一个包。需要在文件的头部声明一个package name，其中package为关键字，name为包名。

2、在hello.go文件中添加一条语句，之后重新进行编译。

添加内容如下：

```
package main
```

执行编译，将会输出如下错误：

```
runtime.main_main·f: relocation target main.main not defined
runtime.main_main·f: undefined: "main.main"
```

因为Go程序启动时，需要在文件中有一个可标识入口。Go程序的入口函数是main函数。

3、在hello.go文件中添加另外一行，并且重试。

添加内容如下：

```
package main

func main(){}
```

执行运行命令 `go run hello.go` ，程序正确执行并很快就退出了。到目前为止，我们已经创建了自己的第一个程序。虽然没有功能，但是已经可以正常运行了。

4、我们继续添加功能，添加内容如下：

```
package main

func main(){
    Println("hello world")
}
```

执行编译，将会输出如下错误：

```
./hello.go:4:2: undefined: Println
```

因为Println函数存放在fmt包中。我们程序中没有主动引入fmt包，所以编译器报未定义错误。

如果我们需要使用这些包中的功能，首先需要import引入相应的包。包中的可导出组件可以通过 包名.组件名的方式进行调用。

函数Println和其它读写文本和字符的函数，都存放在一个叫做fmt的包中——formatting的缩写。

5、再添加几行代码，添加内容如下：

```
package main

import "fmt"

func main(){
    fmt.Println("hello world")
}
```

执行 go run hello.go 命令，运行程序。运行结果如下：

```
hello world
```

Go 程序启动执行顺序如下：

按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：

如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。

然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。

在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

## 第四章 Go语言基本类型

#### Go语言fmt包详解

**格式化输出函数**

```
func Print(a ...interface{}) (n int, err error)
```

Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格，返回写入的字节数和遇到的任何错误。

```
func Printf(format string, a ...interface{}) (n int, err error)
```

Printf根据format参数生成格式化的字符串并写入标准输出，返回写入的字节数和遇到的任何错误。

```
func Println(a ...interface{}) (n int, err error)
```

Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符，返回写入的字节数和遇到的任何错误。

**常用的格式化**

Go语言的标准输出流在打印到屏幕时有些参数跟别的语言（比如C#和Java）不同，下面是我整理的一些常用的格式化操作。

- 普通占位符

| 占位符 | 说明                               | 举例                    |
| :----- | :--------------------------------- | :---------------------- |
| %v     | 以默认的方式打印变量的值           | fmt.Printf("%v", site)  |
| %+v    | 在打印结构体时，会添加字段名       | fmt.Printf("%+v", site) |
| %#v    | 在打印结构体时，会添加字段名和包名 | fmt.Printf("%#v", site) |
| %T     | 打印变量的类型                     | fmt.Printf("%T", site)  |
| %%     | 字面上的百分号，并非值的占位符     | fmt.Printf("%%")        |

- 布尔占位符

| 占位符 | 说明            | 举例                   |
| :----- | :-------------- | :--------------------- |
| %t     | 打印true或false | fmt.Printf("%t", true) |

- 整数占位符

| 占位符 | 说明                                                         | 举例                     |
| :----- | :----------------------------------------------------------- | :----------------------- |
| %b     | 表示为二进制 binary                                          | fmt.Printf("%b", 100)    |
| %c     | 该值对应的unicode码值                                        | fmt.Printf("%c", 0x4E2D) |
| %d     | 表示为十进制                                                 | fmt.Printf("%d", 10)     |
| %o     | 表示为八进制                                                 | fmt.Printf("%o", 0x12)   |
| %q     | 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 | fmt.Printf("%q", 0x4E2D) |
| %x     | 十六进制表示，字母形式为小写 a-f                             | fmt.Printf("%x", 13)     |
| %X     | 十六进制表示，字母形式为大写 A-F                             | fmt.Printf("%x", 13)     |
| %U     | 表示为Unicode格式：U+1234，等价于"U+%04X"                    | fmt.Printf("%U", 0x4E2D) |

- 浮点数和复数的组成部分（实部和虚部）

| 占位符 | 说明                                                  | 举例                       |
| :----- | :---------------------------------------------------- | :------------------------- |
| %e     | (=%.6e) 6位小数点 科学计数法，例如 -1234.456e+78      | fmt.Printf("%e", 10.2)     |
| %E     | 科学计数法，例如 -1234.456E+78                        | fmt.Printf("%e", 10.2)     |
| %f     | (=%.6f) 6位小数点 有小数点而无指数，例如 123.456      | fmt.Printf("%f", 10.2)     |
| %g     | 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 | fmt.Printf("%g", 10.20)    |
| %G     | 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 | fmt.Printf("%G", 10.20+2i) |

- 字符串与字节切片 %cap.len

| 占位符  | 说明                                           | 举例                                |
| :------ | :--------------------------------------------- | :---------------------------------- |
| %s      | 输出字符串表示（string类型或[]byte)            | fmt.Printf("%s", []byte("lemonhh")) |
| %10s    | 输出字符串最小宽度为10(右对齐)                 | fmt.Printf("%10s", "lemonhh")       |
| %-10s   | 输出字符串最小宽度为10(左对齐)                 | fmt.Printf("%-10s", "lemonhh")      |
| %.5s    | 输出字符串最大宽度为5                          | fmt.Printf("%.5s", "lemonhh")       |
| %5.10s  | 输出字符串最小宽度为5，最大宽度为10            | fmt.Printf("%5.10s", "lemonhh")     |
| %-5.10s | 输出字符串最小宽度为5，最大宽度为10(左对齐)    | fmt.Printf("%-5.10s", "lemonhh")    |
| %5.3s   | 输出字符串宽度为5,如果原字符串宽度大于3,则截断 | fmt.Printf("%5.3s", "lemonhh")      |
| %010s   | 如果宽度小于10，就会在字符串前面补零           | fmt.Printf("%010s", "lemonhh")      |
| %q      | 双引号围绕的字符串，由Go语法安全地转义         | fmt.Printf("%q", "oldboy")          |
| %x      | 十六进制，小写字母，每字节两个字符             | fmt.Printf("%x", "oldboy")          |
| %X      | 十六进制，大写字母，每字节两个字符             | fmt.Printf("%X", "oldboy")          |

- 指针

| 占位符 | 说明                  | 举例                     |
| :----- | :-------------------- | :----------------------- |
| %p     | 十六进制表示，前缀 0x | fmt.Printf("%p", &site)  |
| %#p    | 不带前缀 0x           | fmt.Printf("%#p", &site) |

#### Go语言字符串

Go语言的字符串是一个用UTF-8编码的变宽字符序列，它的每一个字符都用一个或多个字节表示 。

在Go语言中，没有字符类型，字符类型是rune类型，rune是int32的别称。可使用 []byte() 获取字节，使用 []rune() 获取字符，可对中文进行转换。

**定义字符串**

第一种，双引号，用来创建可解析的字符串字面量 (支持转义，但不能用来引用多行)；

```
str := "Go语言字符串\n不能跨行赋值"
```

第二种，反引号，用来创建原生的字符串字面量 ，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。

```
str := `Go原生原格式字符串
            可以跨行`
```

**注意：**单引号不能用于定义字符串，单引号用于定义Go语言的一个特殊类型 rune，类似其他语言的byte但又不完全一样，是指码点字面量（Unicode code point），不做任何转义的原始内容。

**连接字符串**

第一种，直接使用 "+" 运算符链接

```
str := "hello" + "lemonhh"
```

golang 里面的字符串都是不可变的，每次运算都会产生一个新的字符串，所以会产生很多临时的无用的字符串，不仅没有用，还会给 gc 带来额外的负担，所以性能比较差。

**注意：**连接跨行字符串时，"+" 必须在上一行末尾，否则导致编译错误。

第二种，使用 fmt.Sprintf() 链接

```
str := fmt.Sprintf("%s,%s", "hello", "lemonhh")
```

内部使用 []byte 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 interface，所以性能也不是很好。

第三种，使用 strings.Join() 链接

```
str := strings.Join([]string{"hello", "oldboy"}, ",")
```

join会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小。

第四种，使用 buffer.WriteString() 链接

```
var buffer bytes.Buffer
buffer.WriteString("hello")
buffer.WriteString(",")
buffer.WriteString("oldboy")
str := buffer.String()
```

这个比较理想，可以当成可变字符使用，对内存的增长也有优化。

**总结：**

1. 在已有字符串数组的场合，使用 strings.Join() 能有比较好的性能；

2. 在一些性能要求较高的场合，尽量使用 buffer.WriteString() 以获得更好的性能；

3. "+" 运算符在较少字符串连接的场景下性能最好，而且代码更简短清晰，可读性更好；

4. 如果需要拼接的不仅仅是字符串，还有数字之类的其他需求的话，可以考虑 fmt.Sprintf()。

**字符串长度**

第一种，将字符串转换为 []rune 后调用 len 函数进行统计

```go
package main

import (
    "fmt"
)

func main() {
    str := "hello lemonhh"
    length := len([]rune(str))
    fmt.Println(length)
}
```

在 Golang 中，如果字符串中出现中文字符不能直接调用 len 函数来统计字符串字符长度，这是因为在 Go 中，字符串是以 UTF-8 为格式进行存储的，在字符串上调用 len 函数，取得的是字符串包含的 byte 的个数。

第二种，使用 bytes.Count() 统计

```
func Count(s, sep []byte) int
```

计算字节切片sep在字节切片s中非重叠显示的个数，如果 sep 为 nil，则返回 s 中的字节个数 + 1。

```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    str := "hello lemonhh"
    length := bytes.Count([]byte(str), nil) - 1
    fmt.Println(length)
}
```

第三种，使用 strings.Count() 统计

```
func Count(s, sep string) int
```

判断字符sep在字符串s中出现的次数，没有找到则返回-1，如果为空字符串("")则返回字符串的长度+1。

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    str := "hello lemonhh"
    length := strings.Count(str, "") - 1
    fmt.Println(length)
}
```

第四种，使用 utf8.RuneCountInString() 统计

```
func RuneCountInString(s string) (n int)
```

返回 s 字符串长度，可以正常解析中文，一个中文被当做一个字符。

```go
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    str := "hello lemonhh"
    length := utf8.RuneCountInString(str)
    fmt.Println(length)
}
```

**字符串操作**

使用索引号 "[ ]" 返回子串。 返回的字符串依然指向原字节数组，仅修改了指针和长度属性。实例如下：

```go
package main

import (
    "fmt"
)

func main() {
    str := "hello, lemonhh"
    s1 := str[0:5]
    s2 := str[7:14]
    fmt.Println(s1, s2)
}
```

运行结果：

```
hello lemonhh
```

修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。实例如下：

```
package main

import "fmt"

func main() {
    str1 := "hello lemonhh"
    s1 := []byte(str1)
    s1[0] = 'H'
    fmt.Println(string(s1))

    str2 := "鸟宿池边树，僧推月下门。"
    s2 := []rune(str2)
    s2[7] = '敲'
    fmt.Println(string(s2))
}
```

运行结果：

```
Hello oldboy
鸟宿池边树，僧敲月下门。
```

#### Go语言string包详解

strings包实现了用于操作字符的简单函数。

**查找操作**

判断给定字符串s中是否包含子串substr, 找到返回true, 找不到返回false

```
func Contains(s, substr string) bool
```

实例如下：

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("包含子串返回：", strings.Contains("lemonhh", "lemon"))
    fmt.Println("不包含子串返回：", strings.Contains("lemonhh", "sweet"))
    fmt.Println("子字符串是空字符串返回：", strings.Contains("lemonhh", ""))
    fmt.Println("原字符串、子字符串都是空字符串返回：", strings.Contains("", ""))
    fmt.Println("中文字符串包含子串返回：", strings.Contains("柠檬精浩浩", "柠檬"))
}
```

运行结果：

```
包含子串返回： true
不包含子串返回： false
子字符串是空字符串返回： true
原字符串、子字符串都是空字符串返回： true
中文字符串包含子串返回： true
```

在字符串s中查找sep所在的位置, 返回位置值, 找不到返回-1

```
func Index(s, sep string) int
```

实例如下：

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("存在返回第一个匹配字符的位置：", strings.Index("lemonhh", "hh"))
    fmt.Println("不存在返回：", strings.Index("lemonhh", "gg"))
    fmt.Println("中文字符串存在返回：", strings.Index("柠檬精浩浩", "柠檬"))
}
```

运行结果：

```
存在返回第一个匹配字符的位置： 5
不存在返回： -1
中文字符串存在返回： 0
```

统计给定子串sep的出现次数, sep为空时, 返回字符串的长度 + 1

```
func Count(s, sep string) int
```

实例如下：

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println("子字符串出现次数：", strings.Count("lemonhh", "o"))
    fmt.Println("子字符串为空时, 返回：", strings.Count("lemonhh", ""))
}
```

运行结果：

```
子字符串出现次数： 1
子字符串为空时, 返回： 8
```

**重复操作**
重复s字符串count次, 最后返回新生成的重复的字符串

```
func Repeat(s string, count int) string
```

实例如下：

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(strings.Repeat("嘀嗒", 4), "时针它不停在转动")
}
```

运行结果：

```
嘀嗒嘀嗒嘀嗒嘀嗒 时针它不停在转动
```

**替换操作**
在s字符串中, 把old字符串替换为new字符串，n表示替换的次数，如果n<0会替换所有old子串。

```
func Replace(s, old, new string, n int) string
```

实例如下：

```go
package main
import (
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println(strings.Replace("luck luck luck", "k", "ky", 2))
    fmt.Println(strings.Replace("luck luck luck", "k", "ky", -1))
}
```

运行结果：

```
lucky lucky luck
lucky lucky lucky
```

**删除操作**
删除在s字符串的头部和尾部中由cutset指定的字符, 并返回删除后的字符串

```
func Trim(s string, cutset string) string
```

实例如下：

```go
package main
import (    
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println(strings.Trim("   lemonhh   ", " "))
}
```

运行结果：

```
lemonhh
```

**大小写转换**
给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)

```
func Title(s string) string
```

返回将所有字母都转为对应的小写版本的拷贝

```
func ToLower(s string) string
```

返回将所有字母都转为对应的大写版本的拷贝

```
func ToUpper(s string) string
```

实例如下：

```go
package main
import (    
    "fmt"    
    "strings")
func main() {    
    fmt.Println(strings.Title("It is never too late to learn.")) 
    fmt.Println(strings.ToLower("It Is Never Too Late To Learn."))  
    fmt.Println(strings.ToUpper("It is never too late to learn."))}
```

运行结果：

```
It Is Never Too Late To Learn.
it is never too late to learn.
IT IS NEVER TOO LATE TO LEARN.
```

**字符串前缀后缀**判断字符串是否包含前缀prefix，大小写敏感

```
func HasPrefix(s, prefix string) bool
```

判断s是否有后缀字符串suffix，大小写敏感

```
func HasSuffix(s, suffix string) bool
```

实例如下：

```go
package main
import (    
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println("前缀是以lemonhh开头的：", strings.HasPrefix("lemonhh", "lemon")) 
    fmt.Println("后缀是以hh结尾的：", strings.HasSuffix("lemonhh", "hh"))
}
```

运行结果：

```
前缀是以lemonhh开头的： true
后缀是以hh结尾的： true
```

**字符串分割**

用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。

```
func Split(s, sep string) []string
```

返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。

```
func Fields(s string) []string
```

实例如下：

```go
package main
import (    
    "fmt"    
    "strings"
)
func main() {    
    fmt.Println("Split 函数的用法")    
    fmt.Printf("%q\n", strings.Split("Linux,Python,Golang,Java", ","))    
    fmt.Printf("%q\n", strings.Split("a mountain a temple", "a "))    
    fmt.Printf("%q\n", strings.Split(" abc ", ""))    
    fmt.Printf("%q\n", strings.Split("", "lemonhh"))    
    fmt.Println("Fields 函数的用法")    
    fmt.Printf("Fields are: %q\n", strings.Fields(" Linux Python Golang  Java "))
}
```

运行结果：

```
Split 函数的用法
["Linux" "Python" "Golang" "Java"]
["" "mountain " "temple"]
[" " "a" "b" "c" " "]
[""]
Fields 函数的用法
Fields are: ["Linux" "Python" "Golang" "Java"]
```

#### Go语言数组

**数组**是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。

在Go语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从0开始。

数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可以让它在CPU缓存中待更久，所以迭代数组和移动元素都会非常迅速。

**数组定义**

第一种，通过指定数据类型和元素个数（数组长度）来声明数组。

声明一个长度为5的整数数组：

```
var array [5]int
```

声明一个长度为5的整数数组并初始化：

```
var array [5]int =[5]int{1,2,3,4,5}
```

第二种，一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型。声明一个长度为5的字符串数组并初始化每个元素：

```
array := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
```

第三种，如果你把长度写成…，Go编译器将会根据你的元素来推导出长度。通过初始化值的个数来推导出数组容量：

```
array := [...]int{1, 2, 3, 4, 5}
```

第四种，如果我们知道想要数组的长度，但是希望对指定位置元素初始化。声明一个长度为5的整数数组，为索引为1和3的位置指定元素初始化，剩余元素为该元素类型的默认值：

```
array := [5]int{1: 1, 3: 3}
```

注意：当一个数组被声明时，它里面包含的每个元素都会被初始化为该元素类型的默认值。一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。

**数组操作**

使用内置函数len()和cap()返回数组长度和数组容量。实例如下：

```go
package main

import "fmt"

func main() {
    array := [2]int{}
    fmt.Printf("数组长度：%d，数组容量：%d\n", len(array), cap(array))
}
```

运行结果：

```
数组长度：2，数组容量：2
```

使用 [] 操作符来访问数组元素：改变索引为2的元素的值：

```
array := [5]int{1, 2, 3, 4, 5}
array[2] = 100
```

注意：数组可以通过下标进行访问，数组下标是从0开始，最后一个元素下标是：len(array)-1。如果下标在数组合法范围之外，则触发访问越界。实例如下：

```
package main

func main() {
    array := [5]int{1, 2, 3, 4, 5}
    array[5] = 100
}
```

编译错误：

```
./main.go:5:7: invalid array index 5 (out of bounds for 5-element array)
```

数组赋值操作，一个数组可以被赋值给任意相同类型的数组：

```go
var arr1 [5]string
arr2 := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
arr1 = arr2
```

注意：

数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，实例如下：

```
package main

import "fmt"

func main() {
    var arr1 [3]string
    arr2 := [5]string{"Linux", "Python", "Java", "Golang", "DBA"}
    arr1 = arr2
    fmt.Println(arr1)
}
```

编译错误：

```
./main.go:8:7: cannot use arr2 (type [5]string) as type [3]string in assignment
```

**多维数组**

数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：

声明一个二维数组

```
var array [3][6]int
```

使用数组字面值声明并初始化

```
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
```

指定外部数组索引位置初始化

```
array := [4][2]int{1: {20, 21}, 3: {40, 41}}
```

同时指定内外部数组索引位置初始化

```
array := [4][2]int{1: {20, 21}, 3: {40, 41}}
```

使用内置函数len()和cap()返回多维数组长度和多维数组容量。实例如下：

```go
package main

import "fmt"

func main() {
    array := [3][6]int{}
    fmt.Printf("数组长度：%d，数组容量：%d\n", len(array), cap(array))
}
```

运行结果：

```
数组长度：3，数组容量：3
```

通过 [] 操作符来访问数组元素：

```
var array [2][2]int
array[0][0] = 0
array[0][1] = 1
array[1][0] = 2
array[1][1] = 3
```

相同类型的多维数组相互赋值：

```
var arr1 [2][2]int
var arr2 [2][2]int
arr2[0][0] = 0
arr2[0][1] = 1
arr2[1][0] = 2
arr2[1][1] = 3
arr1 = arr2
```

#### Go语言类型转换

类型转换用于将一种数据类型的变量转换为另外一种类型的变量。

Go语言类型转换基本格式如下：表达式 T(v) 将值 v 转换为类型 T 。

Go语言各种类型转换及函数的高级用法：strconv包实现了基本数据类型和其字符串表示的相互转换。

**转字节**

字符串转字节

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var str string = "lemonhh"
    result := []byte(str)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is [108 101 109 111 110 104 104] , result type is []uint8
```

32位整形转字节

```go
package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "reflect"
)

func main() {
    var x int32
    x = 100
    bytesBuffer := bytes.NewBuffer([]byte{})
    binary.Write(bytesBuffer, binary.BigEndian, x)
    result := bytesBuffer.Bytes()
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果

```
result is [0 0 0 100] , result type is []uint8
```

**转字符串**

字节转字符串

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var b []byte = []byte{108, 101, 109, 111, 110, 104, 104}
    result := string(b)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is lemonhh , result type is string
```

整形转字符串

```go
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var x int
    x = 100
    result := strconv.Itoa(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is 100 , result type is string
```

FormatInt 将 int 型整数 i 转换为字符串形式 
base：进位制（2 进制到 36 进制） 大于 10 进制的数，返回值使用小写字母 ‘a’ 到 ‘z’

```
func FormatInt(i int64, base int) string
```

Itoa 相当于 FormatInt(i, 10)

64位整形转字符串

```go
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var i int64
    i = 0x100
    result := strconv.FormatInt(i, 10)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is 256 , result type is string
```

布尔值转字符串

```go
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    t := strconv.FormatBool(true)
    f := strconv.FormatBool(false)
    fmt.Printf("t is %v , t type is %v\n", t, reflect.TypeOf(t))
    fmt.Printf("f is %v , f type is %v\n", f, reflect.TypeOf(f))
}
```

输出结果

```
t is true , t type is string
f is false , f type is string
```

浮点数转字符串

```go
strconv.FormatFloat(f,fmt,prec,bitSize)
f：要转换的浮点数 
fmt：格式标记（b、e、E、f、g、G） 
prec：精度（数字部分的长度，不包括指数部分） 
bitSize：指定浮点类型（32:float32、64:float64）

格式标记： 
‘b’ (-ddddp±ddd，二进制指数) 
‘e’ (-d.dddde±dd，十进制指数) 
‘E’ (-d.ddddE±dd，十进制指数) 
‘f’ (-ddd.dddd，没有指数) 
‘g’ (‘e’:大指数，’f’:其它情况) 
‘G’ (‘E’:大指数，’f’:其它情况)

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    f := 100.12345678901234567890123456789
    result := strconv.FormatFloat(f, 'e', 30, 32)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

结果输出

```
result is 1.001234588623046875000000000000e+02 , result type is string
```

**转整形**

int转int64

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 100
    result := int64(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果：

```
result is 100 , result type is int64
```

字符串转整形

```go
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var str string
    str = "100"
    result, _ := strconv.Atoi(str)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

输出结果

```
result is 100 , result type is int
```

字节转32位整形

```go
package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "reflect"
)

func main() {
    b := []byte{0x00, 0x00, 0x03, 0xe8}
    bytesBuffer := bytes.NewBuffer(b)

    var result int32
    binary.Read(bytesBuffer, binary.BigEndian, &result)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

结果输出

```
result is 1000 , result type is int32
```

**转浮点型**

float32转float64

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float32 = 100
    result := float64(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

整型转浮点型

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 100
    result := float32(x)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

字符串转浮点数

```
strconv.ParseFloat(str,bitSize)
str：要转换的字符串
bitSize：指定浮点类型（32:float32、64:float64）
如果 str 是合法的格式，而且接近一个浮点值，
则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准）
如果 str 不是合法的格式，则返回“语法错误”
如果转换结果超出 bitSize 范围，则返回“超出范围”

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    var str string = "0.12345678901234567890"
    result, _ := strconv.ParseFloat(str, 32)
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

**转布尔值**

字符串转布尔值

```
ParseBool 将字符串转换为布尔值 
它接受真值：1, t, T, TRUE, true, True 
它接受假值：0, f, F, FALSE, false, False. 
其它任何值都返回一个错误

package main

import (
    "fmt"
    "reflect"
    "strconv"
)

func main() {
    result, _ := strconv.ParseBool("1")
    fmt.Printf("result is %v , result type is %v\n", result, reflect.TypeOf(result))
}
```

```
result is true , result type is bool
```

注意：Go语言不能将其他类型当 bool 值使用。

```
package main

func main() {
    a := 100
    if a {
    }
}
```

编译错误：

```
./main.go:5:2: non-bool a (type int) used as if condition
```

