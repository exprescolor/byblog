---
layout:     post   				    # 使用的布局（不需要改）
title:      第九章异常和中断		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-07 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# 第9章异常和中断

中断和异常是特殊类型的控制传递。它们的工作方式类似于未编程的 [CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)。他们更改正常程序流程以处理外部事件或报告错误或异常情况。中断与异常之间的区别在于，中断用于处理处理器外部的异步事件，而异常则用于处理处理器自身在执行指令过程中检测到的条件。

有两个外部中断源和两个异常源：

1. 中断
   - 可屏蔽中断，通过INTR引脚发出信号。
   - 不可屏蔽中断，通过NMI（不可屏蔽中断）引脚发出信号。
2. 例外情况
   - 检测到处理器。这些进一步分类为故障，陷阱和中止。
   - 程序。指令 [INTO](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm)， [INT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm) 3， [INT n](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm)和 [BOUND](https://pdos.csail.mit.edu/6.828/2018/readings/i386/BOUND.htm)可以触发异常。这些指令通常称为“软件中断”，但是处理器将它们作为异常处理。

本章介绍了80386在保护模式下执行时提供的用于控制和响应中断的功能。

## 9.1识别中断

处理器将标识号与每种不同类型的中断或异常相关联。

为NMI和处理器识别的异常分配了0到31范围内的预定标识符。80386当前并非使用所有这些数字；而是将这些数字全部使用。英特尔保留该范围内未分配的标识符，以用于将来的扩展。

可屏蔽中断的标识符由外部中断控制器（例如Intel的8259A可编程中断控制器）确定，并在处理器的中断应答序列中传达给处理器。由8259A PIC分配的编号可以由软件指定。可以使用32到255之间的任何数字。

根据报告异常的方式以及是否支持重新启动导致异常的指令，将异常分为错误，陷阱或中止。

- 缺点

  错误是在导致异常的指令“之前”报告的异常。在指令开始执行之前或指令执行期间检测到错误。如果在指令执行过程中检测到故障，则会报告故障，并且机器将恢复为允许重新启动指令的状态。

- 陷阱

  陷阱是在检测到异常的指令之后立即在指令边界报告的异常。

- 中止

  中止是一种异常，它既不允许精确定位导致异常的指令，也不允许重启导致异常的程序。中止用于报告严重错误，例如硬件错误以及系统表中的不一致或非法值。

## 9.2启用和禁用中断

处理器仅在一条指令的结束与下一条指令的开始之间处理中断和异常。使用重复前缀重复字符串指令时，重复之间可能会发生中断和异常。因此，对长字符串的操作不会延迟中断响应。

某些条件和标志设置使处理器在指令边界处禁止某些中断和异常。

###9.2.1NMI掩盖了其他NMI

在执行NMI处理程序时，处理器将忽略NMI引脚上的其他中断信号，直到执行下一条IRET指令为止。

###9.2.2IF屏蔽INTR

IF（中断使能标志）控制通过INTR引脚发出的外部中断的接收。当IF = 0时，禁止INTR中断。当IF = 1时，允许INTR中断。与其他标志位一样，处理器响应RESET信号清除IF。[CLI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CLI.htm)和 [STI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/STI.htm)指令更改了IF的设置。

[CLI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CLI.htm)（清除中断使能标志）和 [STI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/STI.htm)（设置中断使能标志）显式更改IF（标志寄存器中的位9）。仅当CPL <= IOPL时才能执行这些指令。如果在CPL> IOPL时执行保护异常，则会发生保护异常。

IF还受到以下操作的隐式影响：

- 指令 [PUSHF](https://pdos.csail.mit.edu/6.828/2018/readings/i386/PUSHF.htm)将所有标志（包括IF）存储在堆栈中，以便对其进行检查。
- 任务开关和指令 [POPF](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POPF.htm)和 [IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm)加载标志寄存器；因此，它们可用于修改IF。
- 通过中断门的中断会自动重置IF，从而禁用中断。（中断门将在本章后面说明。）

### 9.2.3射频模板调试故障

EFLAGS中的RF位控制调试故障的识别。这允许给定指令最多引发一次调试错误，而不管指令重新启动了多少次。

### 9.2.4 MOV或POP到SS会屏蔽某些中断和异常

需要更改堆栈段的软件通常使用一对指令。例如：

```
MOV SS，AX
MOV ESP，StackTop
```

如果在更改SS之后但ESP接收到相应的更改之前处理了中断或异常，则在中断处理程序或异常处理程序的持续时间内，堆栈指针SS：ESP的两个部分不一致。

为了防止这种情况，在将[MOV转换](https://pdos.csail.mit.edu/6.828/2018/readings/i386/MOV.htm)为SS并将 [POP转换](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POP.htm)为SS的指令之后，80386在 更改SS的指令之后的指令边界处禁止NMI，INTR，调试异常和单步陷阱。某些异常可能仍然会发生。即页面错误和一般保护错误。始终使用80386 [LSS](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGS.htm)指令，并且不会发生此问题。

## 9.3同时中断和异常之间的优先级

如果在一个指令边界上有多个中断或异常悬而未决，则处理器一次服务一个中断或异常。处理器首先处理优先级最高的类中的待处理中断或异常，将控制权转移到中断处理程序的第一条指令。优先级较低的异常将被丢弃；较低优先级的中断将被挂起。当中断处理程序将控制权返回到中断点时，将重新发现丢弃的异常。

## 9.4中断描述符表

中断描述符表（IDT）将每个中断或异常标识符与服务于相关事件的指令的描述符相关联。像GDT和LDT一样，IDT是8字节描述符的数组。与GDT和LDT不同，IDT的第一项可能包含一个描述符。为了形成IDT的索引，处理器将中断或异常标识符乘以8。因为只有256个标识符，所以IDT不必包含超过256个描述符。它可以包含少于256个条目。仅对于实际使用的中断标识符才需要这些条目。

IDT可以驻留在物理内存中的任何位置。，所述处理器位于由IDT寄存器（IDTR）的装置的IDT。指令 [LIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGDT.htm)和 [SIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/SGDT.htm)在IDTR操作。两条指令都有一个显式操作数：内存中6字节区域的地址。下图的格式。

[LIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGDT.htm)（加载IDT寄存器）使用存储在操作数中的线性基址和极限值加载IDT寄存器。仅当CPL为零时才能执行该指令。创建IDT时，操作系统的初始化逻辑通常使用它。操作系统也可以使用它从一个IDT更改为另一个IDT。

[SIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/SGDT.htm)（存储IDT寄存器）将存储在IDTR中的基数和极限值复制到存储位置。该指令可以在任何特权级别执行。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-1.gif)

## 9.5 IDT描述符

IDT可以包含三种描述符中的任何一种：

- 任务门
- 中断门
- 活板门

下图说明了任务门，80386中断门和陷阱门的格式。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-3.gif)

## 9.6中断任务和中断程序

正如[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)指令可以调用过程或任务一样，中断或异常也可以“调用”过程或任务的中断处理程序。当响应中断或异常时，处理器使用中断或异常标识符为IDT中的描述符建立索引。如果处理器索引到中断门或陷阱门，它将以类似于[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)到调用门的方式调用处理程序。如果处理器找到任务门，它将以类似于[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)的方式导致任务切换到任务门。

###9.6.1中断程序

中断门或陷阱门间接指向将在当前执行的任务的上下文中执行的过程。门的选择器指向GDT或当前LDT中的可执行段描述符。门的偏移量字段指向中断或异常处理过程的开始。

80386调用中断或异常处理过程的方式与其调用过程大致相同 ；以下各节将说明差异。

#### 9.6.1.1中断程序堆栈

就像由于CALL指令而进行的控制传递一样，向中断或异常处理过程的控制传递也使用堆栈来存储返回到原始过程所需的信息。正如下图，一个中断推动EFLAGS指针到被中断的指令之前寄存器到堆栈。

某些类型的异常也会导致将错误代码压入堆栈。异常处理程序可以使用错误代码来帮助诊断异常。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-5.gif)

####9.6.1.2从中断程序返回

中断过程与正常过程的不同之处还在于退出过程。该 IRET指令从中断过程用于退出。IRET与RET类似， 不同之处在于 IRET将 ESP额外增加四个字节（由于堆栈上的标志）并将保存的标志移到EFLAGS寄存器中。仅当CPL为零时，才更改EFLAGS的IOPL字段。仅当CPL <= IOPL时，才更改IF标志。

#### 9.6.1.3通过中断过程标记使用

通过中断门或陷阱门的矢量中断会在TF的当前值作为EFLAGS的一部分保存到堆栈后，使TF（陷阱标志）复位。通过此操作，处理器可以防止使用单步调试的调试活动影响中断响应。随后的[IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm)指令将TF恢复为堆栈上EFLAGS映像中的值。

中断门和陷阱门之间的差异在于对IF（中断使能标志）的影响。通过中断门引导的中断会将IF复位，从而防止其他中断干扰当前的中断处理程序。随后的 [IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm) 指令将IF恢复为堆栈上EFLAGS映像中的值。通过陷阱门的中断不会改变IF。

#### 9.6.1.4中断程序中的保护

管理中断过程的特权规则与过程调用的规则类似：CPU不允许中断将控制权转移到比当前特权级别小的特权（数字更大的特权级别）的段中的过程。尝试违反此规则将导致一般保护例外。

因为通常无法预测到中断的发生，所以此特权规则有效地限制了可以执行中断和异常处理过程的特权级别。可以采用以下两种策略中的任一种来确保永不违反特权规则。

- 将处理程序放在符合条件的段中。该策略使处理程序适合某些异常情况（例如，划分错误）。这样的处理程序必须仅使用堆栈中可用的数据。如果它需要来自数据段的数据，则该数据段将必须具有特权级别3，从而使其不受保护。
- 将处理程序放置在特权级别零段中。

### 9.6.2中断任务

IDT中的任务门间接指向任务 。门的选择器指向GDT中的TSS描述符。

当中断或异常引导至IDT中的任务门时，将导致任务切换。使用单独的任务处理中断有两个优点：

- 整个上下文将自动保存。
- 可以通过其LDT或通过其页面目录为其分配单独的地址空间，从而将中断处理程序与其他任务隔离。

中断任务通过执行[IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm)指令返回到被中断的任务。

如果任务切换是由具有错误代码的异常引起的，则处理器会自动将错误代码压入堆栈，该堆栈与要在中断任务中执行的第一条指令的特权级别相对应。

在80386的操作系统中使用中断任务时，实际上有两个调度程序：软件调度程序（操作系统的一部分）和硬件调度程序（处理器的中断机制的一部分）。软件调度程序的设计应考虑到这样的事实：只要启用了中断，硬件调度程序就可以调度中断任务。

## 9.7错误代码

对于与特定段相关的异常，处理器将错误代码推送到异常处理程序（无论是过程还是任务）的堆栈上。错误代码的格式如下图所示 。错误代码的格式类似于选择器的格式。但是，错误代码包含两个1位项目，而不是RPL字段：

1. 如果程序外部的事件导致异常，则处理器会将EXT位置1。
2. 如果错误代码的索引部分引用了IDT中的门描述符，则处理器将设置I位（IDT位）。

如果未设置I位，则TI位指示错误代码是指GDT（值0）还是LDT（值1）。其余的14位是所涉及的段选择器的高14位。在某些情况下，堆栈上的错误代码为空，即，低阶字中的所有位均为零。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-7.gif)

## 9.8例外条件

以下各节详细描述了每种可能的异常条件。每个描述都将异常分类为故障，陷阱或中止。此分类提供系统程序员重新启动发生异常的过程所需的信息：

- 缺点

  报告故障时保存的CS和EIP值指向导致故障的指令。

- 陷阱

  报告陷阱时存储的CS和EIP值在导致陷阱的指令之后动态指向该指令。如果在更改程序流的指令期间检测到陷阱，则报告的CS和EIP值将反映程序流的更改。例如，如果在[JMP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/JMP.htm)指令中检测到陷阱，则 压入堆栈的CS和EIP值指向[JMP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/JMP.htm)的目标 ，而不是[JMP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/JMP.htm)之后的指令 。

- 中止

  中止是一种异常，它既不允许精确定位导致异常的指令，也不允许重启导致异常的程序。中止用于报告严重错误，例如硬件错误以及系统表中的不一致或非法值。

### 9.8.1中断0-除法错误

除数为零 时，在DIV或 IDIV指令期间发生除法错误故障。

### 9.8.2中断1-调试异常

处理器会在多种情况下触发此中断；异常是错误还是陷阱取决于条件：

- 指令地址断点故障。
- 数据地址断点陷阱。
- 一般检测故障。
- 单步陷阱。
- 任务切换断点陷阱。

处理器不会为该异常推送错误代码。异常处理程序可以检查调试寄存器，以确定导致异常的条件。

###9.8.3中断3-断点

INT 3指令引起该陷阱。的INT 3指令是一个字节长，这使得它易于与断点操作码的可执行段替换的操作码。操作系统或调试子系统可以对可执行段使用数据段别名，以将 INT 3放置在便于停止正常执行的任何位置，以便可以执行某种特殊处理。调试器通常使用断点作为在任务关键点处显示寄存器，变量等的方式。

保存的CS：EIP值指向断点后的字节。如果调试器用有效的操作码替换了植入的断点，则它必须在返回之前从保存的EIP值中减去一个。

### 9.8.4中断4-溢出

当处理器遇到INTO指令并且设置了OF（溢出）标志时，就会发生此陷阱 。由于有符号算术和无符号算术都使用相同的算术指令，因此处理器无法确定要使用的算术指令，因此不会自动导致溢出异常。相反，当结果（如果解释为带符号的数字）超出范围时，它仅设置OF。当对带符号的操作数进行算术运算时，小心的程序员和编译器将直接测试OF或使用INTO指令。

### 9.8.5中断5-边界检查

当处理器在执行BOUND指令时发现操作数超过指定的限制时，将发生此错误 。程序可以使用 BOUND 指令根据内存块中定义的有符号限制来检查有符号数组索引。

### 9.8.6中断6-无效的操作码

当执行单元检测到无效的操作码时，会发生此错误。（除非尝试执行无效的操作码，否则不会检测到该异常；即，预取无效的操作码不会导致此异常。）不会将错误代码压入堆栈。可以在同一任务中处理异常。
当操作数的类型对于给定的操作码无效时，也会发生此异常。示例包括引用寄存器操作数的段间 JMP或带有寄存器源操作数的 LES指令。

### 9.8.7中断7-协处理器不可用

在以下两种情况之一中会发生此异常：

- 处理器遇到ESC（转义）指令，并且CR0（控制寄存器为零）的EM（仿真）位置1。
- 处理器遇到 [WAIT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/WAIT.htm)指令或ESC指令，并且CR0的MP（监控协处理器）和TS（任务切换）位均被置1。

### 9.8.8中断8-双重故障

通常，当处理器在尝试为先前的异常调用处理程序时检测到异常时，可以依次处理这两个异常。但是，如果处理器无法串行处理它们，则会发信号通知双重故障异常。为了确定何时将两个故障作为双重故障发出信号，80386将异常分为三类：良性异常，贡献性异常和页面错误。

处理器始终将错误代码压入双重故障处理程序的堆栈中；但是，错误代码始终为零。错误指令可能不会重新启动。如果在尝试调用双故障处理程序时发生任何其他异常，则处理器将关闭。

### 9.8.9中断9-协处理器段溢出

如果80386在将协处理器操作数的中间部分传输到NPX时检测到页或段冲突，则会在保护模式下引发此异常。此异常是可以避免的。 

### 9.8.10中断10-无效的TSS

如果在任务切换期间新的TSS无效，则会发生中断10。将错误代码压入堆栈，以帮助确定故障原因。EXT位指示异常是否由程序控制之外的条件引起；例如，通过任务门的外部中断触发了到无效TSS的切换。

在原始任务的上下文中或在新任务的上下文中都可能发生此故障。在处理器完全验证新TSS的存在之前，该异常会在原始任务的上下文中发生。一旦验证了新TSS的存在，就认为任务切换已完成；即，更新TR，并且如果切换是由于 [CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm) 或中断引起的，则将新TSS的反向链接设置为旧TSS。在此之后，处理器发现的任何错误都将在新任务的上下文中处理。

为了确保有适当的TSS对其进行处理，异常10的处理程序必须是通过任务门调用的任务。

### 9.8.11中断11-段不存在

当处理器检测到描述符的当前位为零时，发生异常11。在以下任何情况下，处理器均可触发此故障：

- 尝试加载CS，DS，ES，FS或GS寄存器时；但是，加载SS寄存器会导致堆栈错误。
- 尝试使用[LLDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LLDT.htm)指令加载LDT寄存器时 ；但是，在任务切换操作期间加载LDT寄存器会导致“无效的TSS”异常。
- 尝试使用标记为不存在的门描述符时。

该故障可以重启。如果异常处理程序使该段存在并返回，则被中断的程序将恢复执行。

如果在任务切换期间发生不存在的异常，则说明任务切换的所有步骤均未完成。在任务切换期间，处理器首先加载所有段寄存器，然后检查其内容的有效性。如果发现不存在的异常，则尚未检查其余段寄存器，因此可能无法用于引用内存。不存在的处理程序不应依赖于能够使用CS，SS，DS，ES，FS和GS中的值而不会引起其他异常。异常处理程序应在尝试继续执行新任务之前检查所有段寄存器。否则，稍后可能会在使诊断更加困难的情况下导致一般性保护故障。有三种方法可以处理这种情况：

1. 用任务处理不存在的故障。任务切换回中断的任务将导致处理器在从TSS加载寄存器时检查寄存器。
2. [PUSH](https://pdos.csail.mit.edu/6.828/2018/readings/i386/PUSH.htm)和 [POP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POP.htm)所有段寄存器。每个 [POP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POP.htm)都会使处理器检查段寄存器的新内容。
3. 检查TSS中每个段寄存器映像的内容，以模拟处理器在加载段寄存器时进行的测试。

此异常将错误代码压入堆栈。如果程序外部的事件导致中断，随后引用了不存在的段，则错误代码的EXT位置1。如果错误代码引用IDT条目（例如，引用不存在的门的[INT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm)指令），则设置I位 。

操作系统通常使用“不存在段”异常来在段级别实现虚拟内存。但是，门描述符中不存在的指示通常并不表示不存在段（因为门不一定对应于段）。操作系统可以使用不存在的门来触发对操作系统具有特殊意义的异常。

### 9.8.12中断12-堆栈异常

堆叠故障发生在以下两种一般情况之一：

- 由于在引用SS寄存器的任何操作中都违反了限制。这包括面向堆栈的指令，如 [POP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POP.htm)， [PUSH](https://pdos.csail.mit.edu/6.828/2018/readings/i386/PUSH.htm)， [ENTER](https://pdos.csail.mit.edu/6.828/2018/readings/i386/ENTER.htm)和 [LEAVE](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LEAVE.htm)，以及其他隐式使用SS的内存引用（例如`MOV AX，[BP + 6]`）。 当堆栈对于指示的局部变量空间而言太小时，[ENTER](https://pdos.csail.mit.edu/6.828/2018/readings/i386/ENTER.htm)会导致此异常。
- 尝试使用标记为不存在但有效的描述符加载SS寄存器时。这可能发生在任务切换，层间 [CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)，层间返回， [LSS](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGS.htm)指令或SS 的[MOV](https://pdos.csail.mit.edu/6.828/2018/readings/i386/MOV.htm)或[POP](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POP.htm)指令中。

当处理器检测到堆栈异常时，它将错误代码压入异常处理程序的堆栈中。如果异常是由于不存在的堆栈段或由于在层间[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)期间新堆栈的溢出而引起的 ，则错误代码包含该段的选择器（异常处理程序可以测试描述符中的当前位以确定哪个发生异常）；否则错误代码为零。

导致该故障的指令在所有情况下都可以重新启动。推入异常处理程序堆栈的返回指针指向需要重新启动的指令。该指令通常是引起异常的指令。但是，在由于任务切换期间加载不存在的堆栈段描述符而导致堆栈异常的情况下，指示的指令是新任务的第一条指令。

当在任务切换期间发生堆栈故障时，段寄存器可能无法用于引用内存。在任务切换期间，将在检查描述符之前加载选择器值。如果发现堆栈故障，则尚未检查其余段寄存器，因此可能无法用于引用存储器。堆栈故障处理程序不应依赖于能够使用CS，SS，DS，ES，FS和GS中的值而不会引起其他异常。异常处理程序应在尝试继续执行新任务之前检查所有段寄存器。否则，稍后可能会在使诊断更加困难的情况下导致一般性保护故障。

### 9.8.13中断13-一般保护异常

所有不会导致另一个异常的保护冲突都会导致一般性保护异常。这包括（但不限于）：

1. 使用CS，DS，ES，FS或GS时超出段限制
2. 引用描述符表时超出段限制
3. 将控制权转移到不可执行的段
4. 写入只读数据段或代码段
5. 从仅执行段读取
6. 用只读描述符加载SS寄存器（除非选择器在任务切换期间来自TSS，否则将发生TSS异常
7. 使用系统段的描述符加载SS，DS，ES，FS或GS
8. 使用也不可读的可执行段的描述符加载DS，ES，FS或GS
9. 用可执行段的描述符加载SS
10. 当段寄存器包含空选择器时，通过DS，ES，FS或GS访问内存
11. 切换到繁忙的任务
12. 违反特权规则
13. PG = 1和PE = 0加载CR0。
14. 通过陷阱或中断门从V86模式到特权级别（非零）的中断或异常。
15. 超出指令长度限制（15个字节）（仅当在指令之前放置冗余前缀时才可能发生）

一般保护例外是故障。响应一般保护异常，处理器将错误代码压入异常处理程序的堆栈。如果加载描述符导致异常，则错误代码包含描述符的选择器；否则，错误代码为null。错误代码中选择器的来源可能是以下任何一种：

1. 指令的操作数。
2. 来自门的选择器，它是指令的操作数。
3. 来自TSS的选择器，涉及任务切换。

### 9.8.14中断14-页面错误

当启用分页（PG = 1）并且处理器将线性地址转换为物理地址时，处理器检测到以下情况之一，就会发生此异常：

- 地址转换所需的页面目录或页面表条目的当前位为零。
- 当前过程没有足够的特权来访问指示的页面。

处理器为页面错误处理程序提供了两项信息，可帮助诊断异常并从中恢复：

- 堆栈上的错误代码。页面错误的错误代码具有与其他异常不同的格式。错误代码告诉异常处理程序三件事：
  1. 异常是由于页面不存在还是由于访问权限冲突引起的。
  2. 发生异常时，处理器是在用户级别还是在主管级别执行。
  3. 导致异常的内存访问是读取还是写入。
- CR2（控制寄存器二）。处理器在CR2中存储导致异常的访问中使用的线性地址。异常处理程序可以使用此地址来找到相应的页面目录和页面表条目。如果在执行页面错误处理程序期间可能发生另一个页面错误，则该处理程序应将CR2压入堆栈。

#### 9.8.14.1任务切换过程中的页面错误

在任务切换期间，处理器可以访问四个段中的任何一个：

- 将原始任务的状态写入该任务的TSS中。
- 读取GDT以查找新任务的TSS描述符。
- 读取新任务的TSS，以从TSS检查段描述符的类型。
- 可以读取新任务的LDT，以验证存储在新TSS中的段寄存器。

访问这些段中的任何一个都可能导致页面错误。在后两种情况下，异常发生在新任务的上下文中。指令指针指向新任务的下一条指令，而不是导致任务切换的指令。如果操作系统的设计允许在任务切换期间发生页面错误，则应通过任务门调用页面错误处理程序。

#### 9.8.14.2堆栈指针不一致的页面错误

应特别注意确保页面错误不会导致处理器使用无效的堆栈指针（SS：ESP）。为8086系列中较早的处理器编写的软件通常使用一对指令更改为新堆栈。例如：

```
MOV SS，AX
MOV SP，StackTop
```

使用80386，因为第二条指令访问存储器，所以有可能在更改SS之后但SP接收到相应更改之前发生页面错误。此时，堆栈指针SS：SP的两个部分（或者对于32位程序，SS：ESP）是不一致的。

如果对页面错误的处理导致堆栈切换到定义良好的堆栈（即，处理程序是任务或更特权的过程），则处理器不会使用不一致的堆栈指针。但是，如果由陷阱或中断门调用页面错误处理程序，并且页面错误与页面错误处理程序具有相同的特权级别，则处理器将尝试使用当前（无效）堆栈指针指示的堆栈。

在实现分页并处理故障任务内的页面错误（带有陷阱或中断门）的系统中，以与页面错误处理程序相同的特权级别执行的软件应通过使用新的[LSS](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGS.htm)指令而不是指令来初始化新的堆栈 对如上所示。当页面错误处理程序以特权级别零（通常情况）执行时，问题的范围仅限于特权级别零代码，通常是操作系统的内核。

### 9.8.15中断16-协处理器错误

当80386检测到来自80386的ERROR＃输入引脚上的80287或80387的信号时，将报告此异常。80386仅在某些ESC指令的开始以及当 MSW的EM位为零（无仿真）时遇到WAIT指令时才测试此引脚 。