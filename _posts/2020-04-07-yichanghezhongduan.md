---
layout:     post   				    # 使用的布局（不需要改）
title:      第九章异常和中断		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-07 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# 第9章异常和中断

中断和异常是特殊类型的控制传递。它们的工作方式类似于未编程的 [CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)。他们更改正常程序流程以处理外部事件或报告错误或异常情况。中断与异常之间的区别在于，中断用于处理处理器外部的异步事件，而异常则用于处理处理器自身在执行指令过程中检测到的条件。

有两个外部中断源和两个异常源：

1. 中断
   - 可屏蔽中断，通过INTR引脚发出信号。
   - 不可屏蔽中断，通过NMI（不可屏蔽中断）引脚发出信号。
2. 例外情况
   - 检测到处理器。这些进一步分类为故障，陷阱和中止。
   - 程序。指令 [INTO](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm)， [INT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm) 3， [INT n](https://pdos.csail.mit.edu/6.828/2018/readings/i386/INT.htm)和 [BOUND](https://pdos.csail.mit.edu/6.828/2018/readings/i386/BOUND.htm)可以触发异常。这些指令通常称为“软件中断”，但是处理器将它们作为异常处理。

本章介绍了80386在保护模式下执行时提供的用于控制和响应中断的功能。

## 9.1识别中断

处理器将标识号与每种不同类型的中断或异常相关联。

为NMI和处理器识别的异常分配了0到31范围内的预定标识符。80386当前并非使用所有这些数字；而是将这些数字全部使用。英特尔保留该范围内未分配的标识符，以用于将来的扩展。

可屏蔽中断的标识符由外部中断控制器（例如Intel的8259A可编程中断控制器）确定，并在处理器的中断应答序列中传达给处理器。由8259A PIC分配的编号可以由软件指定。可以使用32到255之间的任何数字。

根据报告异常的方式以及是否支持重新启动导致异常的指令，将异常分为错误，陷阱或中止。

- 缺点

  错误是在导致异常的指令“之前”报告的异常。在指令开始执行之前或指令执行期间检测到错误。如果在指令执行过程中检测到故障，则会报告故障，并且机器将恢复为允许重新启动指令的状态。

- 陷阱

  陷阱是在检测到异常的指令之后立即在指令边界报告的异常。

- 中止

  中止是一种异常，它既不允许精确定位导致异常的指令，也不允许重启导致异常的程序。中止用于报告严重错误，例如硬件错误以及系统表中的不一致或非法值。

## 9.2启用和禁用中断

处理器仅在一条指令的结束与下一条指令的开始之间处理中断和异常。使用重复前缀重复字符串指令时，重复之间可能会发生中断和异常。因此，对长字符串的操作不会延迟中断响应。

某些条件和标志设置使处理器在指令边界处禁止某些中断和异常。

###9.2.1NMI掩盖了其他NMI

在执行NMI处理程序时，处理器将忽略NMI引脚上的其他中断信号，直到执行下一条IRET指令为止。

###9.2.2IF屏蔽INTR

IF（中断使能标志）控制通过INTR引脚发出的外部中断的接收。当IF = 0时，禁止INTR中断。当IF = 1时，允许INTR中断。与其他标志位一样，处理器响应RESET信号清除IF。[CLI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CLI.htm)和 [STI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/STI.htm)指令更改了IF的设置。

[CLI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CLI.htm)（清除中断使能标志）和 [STI](https://pdos.csail.mit.edu/6.828/2018/readings/i386/STI.htm)（设置中断使能标志）显式更改IF（标志寄存器中的位9）。仅当CPL <= IOPL时才能执行这些指令。如果在CPL> IOPL时执行保护异常，则会发生保护异常。

IF还受到以下操作的隐式影响：

- 指令 [PUSHF](https://pdos.csail.mit.edu/6.828/2018/readings/i386/PUSHF.htm)将所有标志（包括IF）存储在堆栈中，以便对其进行检查。
- 任务开关和指令 [POPF](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POPF.htm)和 [IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm)加载标志寄存器；因此，它们可用于修改IF。
- 通过中断门的中断会自动重置IF，从而禁用中断。（中断门将在本章后面说明。）

### 9.2.3射频模板调试故障

EFLAGS中的RF位控制调试故障的识别。这允许给定指令最多引发一次调试错误，而不管指令重新启动了多少次。

### 9.2.4 MOV或POP到SS会屏蔽某些中断和异常

需要更改堆栈段的软件通常使用一对指令。例如：

```
MOV SS，AX
MOV ESP，StackTop
```

如果在更改SS之后但ESP接收到相应的更改之前处理了中断或异常，则在中断处理程序或异常处理程序的持续时间内，堆栈指针SS：ESP的两个部分不一致。

为了防止这种情况，在将[MOV转换](https://pdos.csail.mit.edu/6.828/2018/readings/i386/MOV.htm)为SS并将 [POP转换](https://pdos.csail.mit.edu/6.828/2018/readings/i386/POP.htm)为SS的指令之后，80386在 更改SS的指令之后的指令边界处禁止NMI，INTR，调试异常和单步陷阱。某些异常可能仍然会发生。即页面错误和一般保护错误。始终使用80386 [LSS](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGS.htm)指令，并且不会发生此问题。

## 9.3同时中断和异常之间的优先级

如果在一个指令边界上有多个中断或异常悬而未决，则处理器一次服务一个中断或异常。处理器首先处理优先级最高的类中的待处理中断或异常，将控制权转移到中断处理程序的第一条指令。优先级较低的异常将被丢弃；较低优先级的中断将被挂起。当中断处理程序将控制权返回到中断点时，将重新发现丢弃的异常。

## 9.4中断描述符表

中断描述符表（IDT）将每个中断或异常标识符与服务于相关事件的指令的描述符相关联。像GDT和LDT一样，IDT是8字节描述符的数组。与GDT和LDT不同，IDT的第一项可能包含一个描述符。为了形成IDT的索引，处理器将中断或异常标识符乘以8。因为只有256个标识符，所以IDT不必包含超过256个描述符。它可以包含少于256个条目。仅对于实际使用的中断标识符才需要这些条目。

IDT可以驻留在物理内存中的任何位置。，所述处理器位于由IDT寄存器（IDTR）的装置的IDT。指令 [LIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGDT.htm)和 [SIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/SGDT.htm)在IDTR操作。两条指令都有一个显式操作数：内存中6字节区域的地址。下图的格式。

[LIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/LGDT.htm)（加载IDT寄存器）使用存储在操作数中的线性基址和极限值加载IDT寄存器。仅当CPL为零时才能执行该指令。创建IDT时，操作系统的初始化逻辑通常使用它。操作系统也可以使用它从一个IDT更改为另一个IDT。

[SIDT](https://pdos.csail.mit.edu/6.828/2018/readings/i386/SGDT.htm)（存储IDT寄存器）将存储在IDTR中的基数和极限值复制到存储位置。该指令可以在任何特权级别执行。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-1.gif)

## 9.5 IDT描述符

IDT可以包含三种描述符中的任何一种：

- 任务门
- 中断门
- 活板门

下图说明了任务门，80386中断门和陷阱门的格式。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-3.gif)

## 9.6中断任务和中断程序

正如[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)指令可以调用过程或任务一样，中断或异常也可以“调用”过程或任务的中断处理程序。当响应中断或异常时，处理器使用中断或异常标识符为IDT中的描述符建立索引。如果处理器索引到中断门或陷阱门，它将以类似于[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)到调用门的方式调用处理程序。如果处理器找到任务门，它将以类似于[CALL](https://pdos.csail.mit.edu/6.828/2018/readings/i386/CALL.htm)的方式导致任务切换到任务门。

###9.6.1中断程序

中断门或陷阱门间接指向将在当前执行的任务的上下文中执行的过程。门的选择器指向GDT或当前LDT中的可执行段描述符。门的偏移量字段指向中断或异常处理过程的开始。

80386调用中断或异常处理过程的方式与其调用过程大致相同 ；以下各节将说明差异。

#### 9.6.1.1中断程序堆栈

就像由于CALL指令而进行的控制传递一样，向中断或异常处理过程的控制传递也使用堆栈来存储返回到原始过程所需的信息。正如下图，一个中断推动EFLAGS指针到被中断的指令之前寄存器到堆栈。

某些类型的异常也会导致将错误代码压入堆栈。异常处理程序可以使用错误代码来帮助诊断异常。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-5.gif)

####9.6.1.2从中断程序返回

中断过程与正常过程的不同之处还在于退出过程。该 IRET指令从中断过程用于退出。IRET与RET类似， 不同之处在于 IRET将 ESP额外增加四个字节（由于堆栈上的标志）并将保存的标志移到EFLAGS寄存器中。仅当CPL为零时，才更改EFLAGS的IOPL字段。仅当CPL <= IOPL时，才更改IF标志。

#### 9.6.1.3通过中断过程标记使用

通过中断门或陷阱门的矢量中断会在TF的当前值作为EFLAGS的一部分保存到堆栈后，使TF（陷阱标志）复位。通过此操作，处理器可以防止使用单步调试的调试活动影响中断响应。随后的[IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm)指令将TF恢复为堆栈上EFLAGS映像中的值。

中断门和陷阱门之间的差异在于对IF（中断使能标志）的影响。通过中断门引导的中断会将IF复位，从而防止其他中断干扰当前的中断处理程序。随后的 [IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm) 指令将IF恢复为堆栈上EFLAGS映像中的值。通过陷阱门的中断不会改变IF。

#### 9.6.1.4中断程序中的保护

管理中断过程的特权规则与过程调用的规则类似：CPU不允许中断将控制权转移到比当前特权级别小的特权（数字更大的特权级别）的段中的过程。尝试违反此规则将导致一般保护例外。

因为通常无法预测到中断的发生，所以此特权规则有效地限制了可以执行中断和异常处理过程的特权级别。可以采用以下两种策略中的任一种来确保永不违反特权规则。

- 将处理程序放在符合条件的段中。该策略使处理程序适合某些异常情况（例如，划分错误）。这样的处理程序必须仅使用堆栈中可用的数据。如果它需要来自数据段的数据，则该数据段将必须具有特权级别3，从而使其不受保护。
- 将处理程序放置在特权级别零段中。

### 9.6.2中断任务

IDT中的任务门间接指向任务 。门的选择器指向GDT中的TSS描述符。

当中断或异常引导至IDT中的任务门时，将导致任务切换。使用单独的任务处理中断有两个优点：

- 整个上下文将自动保存。
- 可以通过其LDT或通过其页面目录为其分配单独的地址空间，从而将中断处理程序与其他任务隔离。

中断任务通过执行[IRET](https://pdos.csail.mit.edu/6.828/2018/readings/i386/IRET.htm)指令返回到被中断的任务。

如果任务切换是由具有错误代码的异常引起的，则处理器会自动将错误代码压入堆栈，该堆栈与要在中断任务中执行的第一条指令的特权级别相对应。

在80386的操作系统中使用中断任务时，实际上有两个调度程序：软件调度程序（操作系统的一部分）和硬件调度程序（处理器的中断机制的一部分）。软件调度程序的设计应考虑到这样的事实：只要启用了中断，硬件调度程序就可以调度中断任务。

## 9.7错误代码

对于与特定段相关的异常，处理器将错误代码推送到异常处理程序（无论是过程还是任务）的堆栈上。错误代码的格式如下图所示 。错误代码的格式类似于选择器的格式。但是，错误代码包含两个1位项目，而不是RPL字段：

1. 如果程序外部的事件导致异常，则处理器会将EXT位置1。
2. 如果错误代码的索引部分引用了IDT中的门描述符，则处理器将设置I位（IDT位）。

如果未设置I位，则TI位指示错误代码是指GDT（值0）还是LDT（值1）。其余的14位是所涉及的段选择器的高14位。在某些情况下，堆栈上的错误代码为空，即，低阶字中的所有位均为零。

![img](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig9-7.gif)