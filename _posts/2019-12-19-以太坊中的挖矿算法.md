---
layout:     post 
title:      以太坊
subtitle:   以太坊中的挖矿算法、难度调整算法
date:       2019-12-19
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 区块链
---

#### Memory Hard Mining Puzzle

- 因为比特币的发展导致挖矿设备越来越专业化，这就和比特币当时的设计初衷背道而驰。所以其他加密货币在设计mining puzzle的时候都会尽量做到ASIC resistance，最常用的做法是增加对内存的需求，也就是所谓的memory hard mining puzzle

####  LiteCoin的Memory Hard Mining Puzzle：scrypt

- scrypt是一个对内存要求很高的哈希函数。具体设计思想如下：
- ![](https://ftp.bmp.ovh/imgs/2019/12/ca349b9ef7baf051.jpg)
   - 开设一个很大的数组，然后按照顺序填写一些伪随机数
   - 种子节点seed通过一些运算算出一个值，放到数组的第一个位置，然后后面每一个位置的值都是前一个位置取哈希得到的。
   - 求解puzzle的时候，按照伪随机的顺序从数组中读取一些数，每次读取的位置也是和前一个数相关的。
      - 例如读取了A位置的数，之后根据A的数值进行一些运算，算出下一个要读取的位置，假如是B的位置，然后对B进行一些运算，算出C的位置。
- 这种方法的好处是：如果这个数组足够的大，那么对于挖矿的矿工来说就是Memory Hard，因为如果矿工不保存这个数组，那么挖矿的复杂度就会大幅度上升
- 但是这种方法也有一个问题：他对矿工虽然是memory hard的，但是对于轻节点来说也是memory hard的。轻节点不可能存取所有计算的数值。那样轻节点就会过大。

#### 以太坊的挖矿算法

- ![](https://ftp.bmp.ovh/imgs/2019/12/e07dff7275fdd659.jpg)
- 以太坊是使用一种memory hard mining puzzle，它使用了一大一小两个两个数据基，小的数据基是一个16M的cache，大的是一个1G的dataset，叫做DAG。
   - 轻节点只需要保存16M的cache即可，1G的DAG只需要挖矿的矿工保存
   - 具体步骤：
      - 首先从种子节点seed经过一些运算算出数组的第一个元素，然后依次取哈希，第一个元素取哈希得到第二个元素，第二个元素取哈希得到第三个元素。。。
      - 生成一个更大的数组，其中小的cache和大的dataset都是定期增长的。大的数组中的元素是从小的数组中按照伪随机的方式得到的
      - 第一次例如是读取A这个元素，读取之后对当前A的哈希值进行更新迭代，算出下一个要读取的位置，假设是B，然后把B的哈希值进行更新迭代，算出读取C的位置。从cache中读取，来回读取256次，最后算出一个数，作为大的dataset的第一个元素。然后第二个元素和第一个元素的获得方法一样，也是利用伪随机的方式读取小的数组，最后算出来一个哈希值，作为第二个元素放到大数组中。
      - 求解mining puzzle时用的是大的数组中的数，按照伪随机的顺序从大的数组中读取128个数。刚开始的时候根据区块的块头和nonce值，算出一个初始的哈希，根据这个哈希映射到大数组中的某个位置。然后进行一些运算，算出下一个要读取的位。读取的时候不止要把算出的元素读取出来，也要把右边相邻的一个元素读取出来，这样循环64次，每次读取两个
      - 最后算出一个哈希值，和难度的目标域值比较一下，是不是符合难度要求。如果不符合，那么就把nonce换一下，重新进行计算

#### ethash算法的伪代码

- 1.生成一个16M的cache，cache中每个元素都是64个字节的哈希值。第一个元素是种子seed的哈希，后面每一个元素都是前一个元素的哈希。每隔30000个区块seed会变化一次
   - ![](https://ftp.bmp.ovh/imgs/2019/12/2eef45e9187bf974.jpg)
- 2.从cache生成1G的大数据集
   - ![](https://ftp.bmp.ovh/imgs/2019/12/bf186c620a6f7c3f.jpg)
- 3.生成整个1G数据集的过程（calc_dataset）
   - ![](https://ftp.bmp.ovh/imgs/2019/12/e9254baf65133721.jpg)
- 4.矿工用来挖矿的函数和轻节点用来验证的函数
   - ![](https://ftp.bmp.ovh/imgs/2019/12/5864e98439f7111e.jpg)
   - 上面函数的参数
      - header：当前要生成的区块的块头。以太坊和比特币一样，挖矿只用到了块头的信息。
      - nonce：当前尝试的nonce值
      - full_size：大数据集中元素的个数
      - dataset：前面生成的大数据集
      - 每次读取的两个相邻的哈希值是没有任何联系的。每个都是由前面那个16M的cache中的256个元素生成的，而且256个元素的位置是按照伪随机排布的。
   - 下面函数的参数
      - header：轻节点是不挖矿的，当他收到某个矿工发布的一个区块的时候，用来验证的第一个参数header就是这个区块的块头信息
      - nonce：包含在这个区块中的nonce，是发布这个区块的矿工选好的
      - full_size：大数据集的元素个数
      - cache：轻节点的任务是验证nonce是否符合要求，验证用的是16M的cache
- 5.矿工挖矿的主循环
   - ![](https://ftp.bmp.ovh/imgs/2019/12/1b94beb32b65f737.jpg)
   - target：挖矿的难度目标，是可以动态调整的，nonce的可能取值是0~2的64次方
- 6.前面所有函数的汇总
   - ![](https://ftp.bmp.ovh/imgs/2019/12/73b59bd7dd6e125f.jpg)

#### 难度调整公式

![](https://ftp.bmp.ovh/imgs/2019/12/0a87cc56b7794901.jpg)

- ε代表设定的难度炸弹

![](https://ftp.bmp.ovh/imgs/2019/12/d97a9ca65c8ba1c0.jpg)

- -99代表难度调整的下限
- 第一个是父区块的难度除以2048。所以在调整难度的时候，不管是上调还是下调，都是按照x的整数倍进行调整，按照父区块难度的1/2048作为难度调整单位
- 第二个的ε和两个因素有关：一个是出块时间，另外一个就是有没有叔父区块。因为当前区块链的最后一个区块它包含有叔父区块的话，那么这时候系统中的货币总供应量是增加的。因为叔父区块会得到出块奖励，包含叔父区块的父区块也会得到一部分奖励。为了维持系统货币总量的稳定，那么当前正在挖的区块的难度就要提高一个等级。
- 有叔父区块的话，y=2，没有叔父区块的话，y=1。

![QqGyTA.jpg](https://s2.ax1x.com/2019/12/19/QqGyTA.jpg)

#### 难度炸弹

![QqJp79.jpg](https://s2.ax1x.com/2019/12/19/QqJp79.jpg)

- 当前的区块号除以100000，向下取整，作为2的指数。后来因为难度炸弹呈指数级上升导致挖矿难度越来越大，所以以太坊就把当前的区块号减去3000000之后，作为一个假的区块号加入到难度炸弹计算公式中。也就是图中的Hi'。

#### 以太坊发展的四个阶段

![QqYe2V.jpg](https://s2.ax1x.com/2019/12/19/QqYe2V.jpg)