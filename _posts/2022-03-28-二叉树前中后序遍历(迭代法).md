---
layout:     post   				    # 使用的布局（不需要改）
title:      二叉树前中后序遍历(迭代法)				# 标题 
subtitle:   题目类型:Midium #副标题
date:       2022-03-28 				# 时间
author:     谢玄xx 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 二叉树
---

# 问题一：二叉树的前序遍历


## 解题思路

## 代码如下
```CPP
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        stack<TreeNode*> st;
        st.push(root);//一定记得先把这个根节点压入栈
        while(!st.empty())
        {
            //先把栈内元素存储在一个变量里，再把它出栈
            TreeNode* temp = st.top();
            st.pop();
            res.push_back(temp->val);
            if(temp->left)
            {
                st.push(temp->left);
            }
            if(temp->right)
            {
                st.push(temp->right);
            }


        }
        return res;

    }
};
```


# 问题二：二叉树的后序遍历


## 解题思路

## 代码如下
```CPP
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        stack<TreeNode*> st;
        st.push(root);//一定记得先把这个根节点压入栈
        while(!st.empty())
        {
            //先把栈内元素存储在一个变量里，再把它出栈
            TreeNode* temp = st.top();
            st.pop();
            res.push_back(temp->val);
            if(temp->left)
            {
                st.push(temp->left);
            }
            if(temp->right)
            {
                st.push(temp->right);
            }


        }
        reverse(res.begin(), res.end());
        return res;

    }
};

```

# 问题三：二叉树的中序遍历


## 解题思路

## 代码如下
```CPP
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```
