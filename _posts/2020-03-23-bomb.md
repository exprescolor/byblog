---
layout:     post   				    # 使用的布局（不需要改）
title:      bomb secret			# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-23 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - bomb
---

# secret_phase

开始以为，过关之后就会进入隐藏关，后来想了想，如果直接给你，那还叫什么隐藏关卡，于是就去汇编代码里面找关键字，找到了下面的函数

```assembly
08049276 <phase_defused>:
 8049276:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
 804927c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 8049282:	89 44 24 7c          	mov    %eax,0x7c(%esp)
 8049286:	31 c0                	xor    %eax,%eax
 8049288:	83 3d c8 c3 04 08 06 	cmpl   $0x6,0x804c3c8   ;解开前六关才能进入隐藏关
 804928f:	75 72                	jne    8049303 <phase_defused+0x8d>
 8049291:	8d 44 24 2c          	lea    0x2c(%esp),%eax
 8049295:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049299:	8d 44 24 28          	lea    0x28(%esp),%eax
 804929d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80492a1:	8d 44 24 24          	lea    0x24(%esp),%eax
 80492a5:	89 44 24 08          	mov    %eax,0x8(%esp)
 80492a9:	c7 44 24 04 49 a3 04 	movl   $0x804a349,0x4(%esp)   ;%d %d %s，
 80492b0:	08 
 80492b1:	c7 04 24 d0 c4 04 08 	movl   $0x804c4d0,(%esp)
 80492b8:	e8 a3 f5 ff ff       	call   8048860 <__isoc99_sscanf@plt>
 80492bd:	83 f8 03             	cmp    $0x3,%eax   ;输入为3个的时候，取出0x804a352的内存
 80492c0:	75 35                	jne    80492f7 <phase_defused+0x81>
 80492c2:	c7 44 24 04 52 a3 04 	movl   $0x804a352,0x4(%esp)   ;DrEvil
 80492c9:	08 
 80492ca:	8d 44 24 2c          	lea    0x2c(%esp),%eax
 80492ce:	89 04 24             	mov    %eax,(%esp)
 80492d1:	e8 24 fd ff ff       	call   8048ffa <strings_not_equal>   ;比较输入的第三个参数和这个内存是否相等
 80492d6:	85 c0                	test   %eax,%eax
 80492d8:	75 1d                	jne    80492f7 <phase_defused+0x81>
 80492da:	c7 04 24 18 a2 04 08 	movl   $0x804a218,(%esp)
 80492e1:	e8 0a f5 ff ff       	call   80487f0 <puts@plt>
 80492e6:	c7 04 24 40 a2 04 08 	movl   $0x804a240,(%esp)
 80492ed:	e8 fe f4 ff ff       	call   80487f0 <puts@plt>
 80492f2:	e8 ec fb ff ff       	call   8048ee3 <secret_phase>
 80492f7:	c7 04 24 78 a2 04 08 	movl   $0x804a278,(%esp)
 80492fe:	e8 ed f4 ff ff       	call   80487f0 <puts@plt>
 8049303:	8b 44 24 7c          	mov    0x7c(%esp),%eax
 8049307:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804930e:	74 05                	je     8049315 <phase_defused+0x9f>
 8049310:	e8 ab f4 ff ff       	call   80487c0 <__stack_chk_fail@plt>
 8049315:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 804931b:	c3                   	ret    
 804931c:	66 90                	xchg   %ax,%ax
 804931e:	66 90                	xchg   %ax,%ax
```

![drevil.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd32olazlzj307r01bq2s.jpg)

以上函数表明，要想进入隐藏关卡，前提是六关要都通过，并且要在第四关触发这个函数，也就是输入三个参数，前两个是第四关的过关密码，第三个参数需要和内存中字符串相等。于是我们需要知道0x804a352处的值，并在第四关的时候提交这个字符串。我们查看内存得到这个内存是DrEvil，所以我们在第四关输入4 19 DrEvil，就可以在第六关之后进入隐藏关卡，然后来看隐藏关：

```assembly
08048ee3 <secret_phase>:
 8048ee3:	53                   	push   %ebx
 8048ee4:	83 ec 18             	sub    $0x18,%esp
 8048ee7:	e8 90 02 00 00       	call   804917c <read_line>  ;输入参数
 8048eec:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 8048ef3:	00 
 8048ef4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048efb:	00 
 8048efc:	89 04 24             	mov    %eax,(%esp)
 8048eff:	e8 cc f9 ff ff       	call   80488d0 <strtol@plt>
 8048f04:	89 c3                	mov    %eax,%ebx
 8048f06:	8d 40 ff             	lea    -0x1(%eax),%eax
 8048f09:	3d e8 03 00 00       	cmp    $0x3e8,%eax   ;输入需要小于0x3e8
 8048f0e:	76 05                	jbe    8048f15 <secret_phase+0x32>
 8048f10:	e8 f0 01 00 00       	call   8049105 <explode_bomb>
 8048f15:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048f19:	c7 04 24 88 c0 04 08 	movl   $0x804c088,(%esp)   ;查看内存 0x24
 8048f20:	e8 6d ff ff ff       	call   8048e92 <fun7>
 8048f25:	83 f8 05             	cmp    $0x5,%eax   ;函数返回值=5，否则爆炸
 8048f28:	74 05                	je     8048f2f <secret_phase+0x4c>
 8048f2a:	e8 d6 01 00 00       	call   8049105 <explode_bomb>
 8048f2f:	c7 04 24 54 a1 04 08 	movl   $0x804a154,(%esp)
 8048f36:	e8 b5 f8 ff ff       	call   80487f0 <puts@plt>
 8048f3b:	e8 36 03 00 00       	call   8049276 <phase_defused>
 8048f40:	83 c4 18             	add    $0x18,%esp
 8048f43:	5b                   	pop    %ebx
 8048f44:	c3                   	ret    
 8048f45:	66 90                	xchg   %ax,%ax
 8048f47:	66 90                	xchg   %ax,%ax
 8048f49:	66 90                	xchg   %ax,%ax
 8048f4b:	66 90                	xchg   %ax,%ax
 8048f4d:	66 90                	xchg   %ax,%ax
 8048f4f:	90                   	nop
```

这一关我们要输入一个数字，数字需要小于0x3e8，加上参数0x24，两个参数进入fun7函数，需要保证fun7的返回值是5才可以过关，然后看fun7函数

```assembly
08048e92 <fun7>:
 8048e92:	53                   	push   %ebx
 8048e93:	83 ec 18             	sub    $0x18,%esp
 8048e96:	8b 54 24 20          	mov    0x20(%esp),%edx   ;第一个参数，0x24
 8048e9a:	8b 4c 24 24          	mov    0x24(%esp),%ecx    ;第二个参数，即输入的数字
 8048e9e:	85 d2                	test   %edx,%edx
 8048ea0:	74 37                	je     8048ed9 <fun7+0x47>  ;edx=0就退出了
 8048ea2:	8b 1a                	mov    (%edx),%ebx   ;ebx=*a1
 8048ea4:	39 cb                	cmp    %ecx,%ebx      ;*a1<=a2则跳转
 8048ea6:	7e 13                	jle    8048ebb <fun7+0x29>
 8048ea8:	89 4c 24 04          	mov    %ecx,0x4(%esp)   ;大于则将a1+4的地址传入递归
 8048eac:	8b 42 04             	mov    0x4(%edx),%eax
 8048eaf:	89 04 24             	mov    %eax,(%esp)
 8048eb2:	e8 db ff ff ff       	call   8048e92 <fun7>  ;递归调用fun7
 8048eb7:	01 c0                	add    %eax,%eax    ;eax=2*eax
 8048eb9:	eb 23                	jmp    8048ede <fun7+0x4c>
 8048ebb:	b8 00 00 00 00       	mov    $0x0,%eax
 8048ec0:	39 cb                	cmp    %ecx,%ebx    ;相等则退出递归
 8048ec2:	74 1a                	je     8048ede <fun7+0x4c>
 8048ec4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 8048ec8:	8b 42 08             	mov    0x8(%edx),%eax  ;如果*a1<a2,将(a1+8)作为地址进入递归
 8048ecb:	89 04 24             	mov    %eax,(%esp)
 8048ece:	e8 bf ff ff ff       	call   8048e92 <fun7>
 8048ed3:	8d 44 00 01          	lea    0x1(%eax,%eax,1),%eax   ;eax=2*eax+1
 8048ed7:	eb 05                	jmp    8048ede <fun7+0x4c>
 8048ed9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048ede:	83 c4 18             	add    $0x18,%esp
 8048ee1:	5b                   	pop    %ebx
 8048ee2:	c3                   	ret    
```

有、难，于是我打开了ida，反汇编得到这段函数

```c++
int __cdecl fun7(_DWORD *a1, int a2)
{
  int result; // eax
  if ( !a1 )
    return -1;
  if ( *a1 > a2 )
    return 2 * fun7((_DWORD *)a1[1], a2);
  result = 0;
  if ( *a1 != a2 )
    result = 2 * fun7((_DWORD *)a1[2], a2) + 1;
  return result;
}
```

a1是个指针，*a1取指针内的值，如果a1的值大于a2，则返回 eax=2eax+1,如果不等于a2返回2eax

我们需要推出开始的数字，从5往回推，

5=2*2+1，eax=2，此时递归是al+8

2=2*1，eax=1，此时是al+4

1=2*0+1，eax=0,此时是al+8

所以我们的递归一共走了三步，一开始数字大，地址+8后比较，发现又小了，地址+4后比较又大了，再+8后比较相等，遂退出递归。

所以我们要找的这个数字就是第三个数字，于是我们查找内存数据

![屏幕截图2.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd32ns4osvj308m08nmyz.jpg)



于是我们找到三个内存中的值，第三个0x2f即为所求。

## 关于%gs

在上面<phase_defused>函数中，我看到了mov    %gs:0x14,%eax这样一句话，其中%gs是之前没有见过的指令，去查了一下：

GS是一个段寄存器,其在linux中的使用可以在  [here](javascript:void())上读取(它基本上用于每个进程数据).      

```
mov    %gs:0x14,%eax
```

该代码用于验证堆栈没有爆炸或已被证实,使用存储在GS 0x14中的值,参见[this](javascript:void()).

这是一个Linux栈溢出漏洞的利用，考察Linux canary绕过技术及ROP攻击负载的构造。

**Linux Canary介绍**

首先了解一下Linux的Canary保护机制。Canary 是Linux众多安全保护机制中的一-种，主要用于防护栈溢出攻击。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过溢出栈缓冲区，覆盖栈上保存的函数返回地址来达到劫持程序执行流的目的:

![11.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd47dtzwvyj30ql0e43yu.jpg)

针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢?--个很自然的想法是在刚进入函数时，在栈上放置- -个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。Linux Canary保护机制便是如此，如下:

![11图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd47f703w1j30pz0efglz.jpg)

攻击者如果要通过栈溢出覆盖ret,则必先覆盖Canary。如果我们能判断Canary前后是否一致， 便能够判断是否有攻击行为发生。

说明:.上述图例仅用 于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。

**Linux Canary实现**

Linux程序的Canary保护是通过gcc编译选项来控制的，gcc 与canary相关的参数及其意义分别为:

-fstack-protector:启用堆栈保护，不过只为局部变量中含有char 数组的函数插入保护代码

-fstack- protector- all:启用堆栈保护，为所有函数插入保护代码。

-fno-stack-protector:禁用堆栈保护，为默认选项。

`mov %gs: 0x14, %eax`

`mov %eax, 0x7c (%esp)`

这两行代码，在函数开始时，会取gs:0x14 处的值，并放在%esp+0x7c的地方

`mov 0x7c (%esp) , %eax`

`xor %gs:0x14, %eax`

在程序结束时，会将该值取出，并与gs:0x14 的值进行异或,如果异或的结果为0，说明canary未被修改，程序会正常结束，反之如果异或结果不为0，说明canary已经被非法修改，存在攻击行为，此时程序流程会走到_ stack_ chk_ fail，从而终止程序。

