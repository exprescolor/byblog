---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab2-part3		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-05 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

## part3：内核地址空间

​		JOS将处理器的32位线性地址空间分成两部分。我们将在lab 3中开始加载和运行的用户环境(进程)将控制下面部分的布局和内容，而内核始终保持对上面部分的完全控制。在inc/memlayout.h中，分界线是由符号ULIM任意定义的。为内核保留大约256MB的虚拟地址空间。这解释了为什么我们需要在lab 1中为内核提供如此高的链接地址:否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境中。

### 权限和故障隔离

​		因为内核和用户内存都存在于每个环境的地址空间中，所以我们必须在x86页面表中使用权限位来允许用户代码只访问地址空间的用户部分。否则，用户代码中的错误可能会覆盖内核数据，导致崩溃或更细微的故障;用户代码还可以窃取其他环境的私有数据。注意，可写权限位(PTE_W)同时影响用户和内核代码!

​		用户环境将不允许访问ULIM之上的任何内存，而内核将能够读写这些内存。对于地址范围[UTOP,ULIM]，内核和用户环境具有相同的权限:它们可以读取但不能写入这个地址范围。此地址范围用于向用户环境公开某些只读的内核数据结构。最后，UTOP下的地址空间供用户环境使用;用户环境将设置访问此内存的权限。

### 初始化内核地址空间

​		现在，我们要设置UTOP上面的地址空间:地址空间的内核部分。inc/memlayout.h显示了我们应该使用的布局。我们要使用刚才编写的函数来设置适当的线性到物理映射。

### 练习5

在调用check_page()之后，填充mem_init()中缺少的代码。

通过check_kern_pgdir()和check_page_installed_pgdir()检查代码。

题目要完成的是映射 UPAGES, KSTACK, KERNBASE虚拟地址空间到kern_pgdir。利用的是前面定义的 boot_map_region 这个函数。

1. UPAGES

这是记录物理页面使用情况的数据结构。由于用户空间同样需要访问这个数据结构，我们将用户空间的一块内存映射到存储该数据结构的物理内存上。

我们要映射的范围是把pages数组映射到线性地址UPAGES（第二个参数），大小为一个PTSIZE（第三个参数）。第四个参数是映射到的物理地址，取pages的物理地址。第五关参数perm变量设置为PTE_U，是因为这部分空间是kernel space和user space中的代码都能访问的，所以要设置PTE_U，用户有权限读取。所以代码是：

`boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);`

2. 内核栈

bootstack 表示的是栈地最低地址，由于栈向低地址生长，实际是栈顶。映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：

* [KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。

* [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。

KSTACKTOP = 0xf0000000，KSTKSIZE = 32kB。

对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：

` boot_map_region(kernel_pgdir, (uintptr_t) (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);	`

3. 内核

虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。映射全部 0xf0000000 至 0xffffffff 共 256MB 的内存地址。

访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：

` boot_map_region(kern_pgdir, (uintptr_t) KERNBASE, ROUNDUP(0xffffffff - KERNBASE, PGSIZE), 0, PTE_W | PTE_P);`

然后make一下：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdj87l8kavj30cc04gmxc.jpg)

###地址空间布局方案

我们在JOS中使用的地址空间布局并不是惟一可能的。操作系统可能将内核映射到较低的线性地址，而将线性地址空间的上部留给用户进程。x86内核一般不采取这种方法,然而,因为一个x86的向后兼容模式,称为虚拟8086模式。

