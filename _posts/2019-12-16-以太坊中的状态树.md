---
layout:     post 
title:      以太坊
subtitle:   以太坊中的状态数
date:       2019-12-16
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 区块链
---

- **探究一下以太坊中用什么样的数据结构来实现基于账户的模式**

- 我们要完成的是从账户地址（account address）到账户状态（account state）的映射。
   - 以太坊中的账户地址是160bits的，一般把他表示成40个16进制的数。
   - 状态就是外部账户和合约账户的状态

#### trie（一个简单的数据结构：前缀树）

![](https://ftp.bmp.ovh/imgs/2019/12/08bffa69ab85318d.jpg)

- 这个数据结构有几个特点
   - 1.在trie中每个节点的分支数目取决于key值中每个元素的取值范围。上图例子中每个都是英文单词，而且是小写的，所以每个节点的分叉数目最多是26个，加上一个结束标志位，表示到这个地方这个单词就结束了。在以太坊中，地址是表示成40个16进制的数，所以有时候把分叉树叫做branching factor
   - 2.trie的查找效率取决于key的长度。键值越长，查找需要访问的内存次数就越多。上图例子中每个单词的长度是不一样的。以太坊中每个键值都是40。
   - 3.哈希表可能会产生哈希碰撞。而trie是不会产生哈希碰撞的，只要两个地址不一样，最后肯定映射到树中的不同的分支
   - 4.只要给定一组输入，不管输入的顺序如何变化，最后构造出来的树一定不变
   - 5.更新的局部性很好，因为只需要更新涉及到的分支即可，不需要全部进行更新

- 但是上图示例中会对存储造成浪费，因为每个节点都只有一个子节点。把每个节点进行合并的话，就可以节省存储的开销，而且会提高查找的效率，不需要一个一个往下找了。这样就出现了**Patricia Tree（Patricia Trie）：经过了路径压缩的前缀树**
   - 压缩后的示例
   - ![](https://ftp.bmp.ovh/imgs/2019/12/4b63fcd1a8b9c31e.jpg)
   - **在键值分布比较稀疏的时候，采用路径压缩效果比较好，如下图：**
      - ![](https://ftp.bmp.ovh/imgs/2019/12/b3c7401723268625.jpg)
      - ![](https://ftp.bmp.ovh/imgs/2019/12/03e18a8e790fb7c8.jpg)

#### MPT

- MPT就是把Patricia Tree中的普通指针换成了哈希指针。所有的账户组成一个Patricia Tree，用路径压缩提高效率，然后把普通指针换成哈希指针，所以就可以计算出一个根哈希值，这个根哈希值也是写在block header中的。这个根哈希值是状态树的根哈希值，以太坊的块头中有三个根哈希值
   - 这个根哈希值的作用：
      - 1.防止篡改：只要这个数改变，其他地方的哈希值也会发生改变。也就是说每个账户的状态都会保持他的状态不被篡改；
      - 2.Merkle Proof：**可以证明账户余额有多少**：用户账户所在的分支自底向上，作为Merkle Proof发送给轻节点，轻节点就可以验证当前账户有多少钱；**可以证明账户是否存在**：也就是证明MPT中某个账户是不是存在的。如果存在的话，他是在什么样的分支中，把分支作为Merkle Proof发过去，可以证明他是不存在的。

#### Modified MPT

- 以太坊用的数据结构叫做Modified MPT。它是对MPT结构进行了一些修改。下图为示例
- ![](https://ftp.bmp.ovh/imgs/2019/12/35a878a69b2c6420.jpg)
   - 右上角为四个账户，简单起见，账户地址只设置了7位。账户状态只显示了余额，其他的账户状态没有显示出来
   - Extension Node：当树中存在路径压缩就会出现Extension Node
   - Branch Node：存在分支时就会出现Branch Node

- 示例2：
- ![](https://ftp.bmp.ovh/imgs/2019/12/cdb9e46c0d32ca21.jpg)
   - 两个相邻的区块，state root就是状态树的根哈希值。可以看出虽然每个区块都有一个状态树，但是两棵树的大部分节点是共享的。只有那些发生改变的节点需要新建一个分支

- **所以系统中的全节点需要维护的不是一棵MPT，而是每次出现一个区块，都要新建一个MPT**，只不过这些状态树中的大部分节点是共享的，只有少数发生变化的节点需要新建分支

#### 以太坊中代码的数据结构

- 块头的定义
- ![](https://ftp.bmp.ovh/imgs/2019/12/f380d7a5514237d9.jpg)
   - ParentHash：父区块的哈希值，区块链中前一个区块的哈希值
   - UncleHash：叔父区块的哈希值
   - Coinbase：挖出区块的矿工的地址
   - Root，TxHash，ReceiptHash：三棵树的根哈希值（状态树，交易树，收据树）。Root是状态树的根哈希值。TxHash是交易树的根哈希值，ReciptHash是收据树的根哈希值
   - Bloom：Bloom Filter，和收据树是相关的。提供一种高效的查询符合条件的交易的执行结果
   - Difficulty：挖矿难度
   - GasLimit，GasUsed：和汽油费相关，智能合约需要消耗汽油费。有点类似于比特币中的交易费
   - Time：当前区块大致的产生时间
   - MixDigest，Nonce：和挖矿相关的。Nonce是最后符合挖矿要求的随机数。MixDigest是对Nonce取哈希得到的值

- 区块的结构：
- ![](https://ftp.bmp.ovh/imgs/2019/12/54608bc8a29e0640.jpg)
   - header：指向block header的指针
   - uncles：指向叔父区块的block header的指针，而且他是个数组，因为一个区块可以有多个叔父区块
   - transactions：区块中的交易列表

#### 状态树中value的存储

- 状态树中保存的是键值对（key,value）。key就是地址，value就是状态。所以账户的状态怎么管理？他是怎么存储在状态树中的？
   - 他需要经过一个序列化的过程，用RLP（Recursive Length Prefix）编码做序列化之后再存储。RLP只支持一种类型，也就是nested array of bytes，也就是字节数组，可以嵌套。以太坊中所有的其他类型，整数也好，比较复杂的哈希表也好，最后都要变成字节数组。