---
layout:     post                         # 使用的布局（不需要改）
title:      通用型支付系统学习摘录           # 标题
subtitle:   支付宝(网页)/微信(Native)支付                 # 副标题
date:       2020-06-12                 # 时间
author:     AhogeK                      # 作者
header-img: https://w.wallhaven.cc/full/wy/wallhaven-wy73vx.jpg    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - 支付系统
	- 学习笔记
---

[微信支付API文档地址](https://pay.weixin.qq.com/wiki/doc/api/index.html)

[可能是最好的支付SDK](https://github.com/Pay-Group/best-pay-sdk)
*所谓的SDK就是封装的API*

在项目Maven .pom中添加此SDK
```xml
<dependency>
	<groupId>cn.springboot</groupId>
	<artifactId>best-pay-sdk</artifactId>
	<version>1.3.0</version>
</dependency>
```

如何使用可以参考该SDK项目中的[使用文档](https://github.com/Pay-Group/best-pay-sdk/blob/develop/doc/use.md)

该SDK可以通过创建 ``BestPayServiceImpl`` 来设置配置，而配置可以通过实例化 ``WxPayConfig`` 对象来配置微信支付，而这边学习用的是微信的Native支付，只需要设置公众号ID，商户号，商户密钥即可。然后可以通过``PayRequest``对象来调用支付方法。

```java
@Slf4j
@Service
public class PayService implements IPayService {

    @Override
    public void create(String orderId, BigDecimal amount) {
        WxPayConfig wxPayConfig = new WxPayConfig();
        wxPayConfig.setAppId("123456");
        wxPayConfig.setMchId("123456");
        wxPayConfig.setMchKey("123AAA456BBB");
        wxPayConfig.setNotifyUrl("http://127.0.0.1");

        BestPayServiceImpl bestPayService = new BestPayServiceImpl();
        bestPayService.setWxPayConfig(wxPayConfig);

        PayRequest request = new PayRequest();
        request.setOrderName("最好的支付sdk");
        request.setOrderId(orderId);
        request.setOrderAmount(amount.doubleValue());
        request.setPayTypeEnum(BestPayTypeEnum.WXPAY_NATIVE);

        PayResponse response = bestPayService.pay(request);
        log.info("response={}", response);
    }
}

class PayServiceTest extends PayApplicationTests {

    @Autowired
    private PayService payService;

    @Test
    void create() {
        // BigDecimal.valueOf(0.01) & new BigDecimal("0.01") 千万不要用 new BigDecimal(0.01)
        payService.create("123456789123456", BigDecimal.valueOf(0.01));
    }
}
```

*对于传``BigDecimal``的值不能直接``new BigDecimal(0.01)``这样会出现丢失精度的问题*

业务代码中利用了``@Slf4j``来输出打印,具体如何使用可以阅读此文章 - [使用SLF4J和Logback](https://www.liaoxuefeng.com/wiki/1252599548343744/1264739155914176)

##### 前端二维码生成
需要用到[jquery.qrcode.js](https://github.com/jeromeetienne/jquery-qrcode)

项目可以通过[BootCDN](https://www.bootcdn.cn/)来导入JS

```java
@Controller
@RequestMapping("/pay")
public class PayController {

    @Autowired
    private PayService payService;

    @GetMapping("/create")
    public ModelAndView create(@RequestParam("orderId") String orderId,
                                @RequestParam("amount") BigDecimal amount) {
        PayResponse payResponse = payService.create(orderId, amount);
        Map<String, String> map = new HashMap<>();
        map.put("codeUrl", payResponse.getCodeUrl());
        return new ModelAndView("create", map);
    }
}
```

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>支付</title>
</head>
<body>
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<p>微信支付</p>
<div id="wxQR"></div>
<script>
    jQuery('#wxQR').qrcode({
        text: "${codeUrl}"
    });
</script>
</body>
</html>
```

##### 微信异步通知
* notify_url要在微信后台设置吗？
模式二无需特定的URL
* notify_url一定要用域名吗？
一定要外网可访问的url且不能携带参数，不一定域名，IP也是可以 

[NATAPP](https://natapp.cn/)内网穿透工具  优惠码：12F000E2

关于异通知的内容，微信会多次发送通知，可能会重复，要做好去重处理，商户如果最终没能收到异步通知，可以调用微信支付的查询订单API确认订单状态，商户系统对于结果通知要做好签名验证，并校验返回的订单金额是否与商户侧的订单金额一致

```java
@PostMapping("/notify")
public void asyncNotify(@RequestBody String notifyDate) {
    log.info("notifyDate={}", notifyDate);
}
```
修改异步通知地址: ``wxPayConfig.setNotifyUrl("http://ahogek.natapp1.cc/pay/notify");``

通过自定义Bean注入，来实现单例化``BestPayServiceImpl``

```java
@Component
public class BestPayConfig {

    @Bean
    public BestPayServiceImpl bestPayService() {
        WxPayConfig wxPayConfig = new WxPayConfig();
        wxPayConfig.setAppId("asdafw123we4r65");
        wxPayConfig.setMchId("1483469312");
        wxPayConfig.setMchKey("ASDF65SADAF21DFVA8DF7");
        wxPayConfig.setNotifyUrl("http://ahogek.natapp1.cc/pay/notify");

        BestPayServiceImpl bestPayService = new BestPayServiceImpl();
        bestPayService.setWxPayConfig(wxPayConfig);
        return bestPayService;
    }
}
```

修改service方法，添加用于获取微信异步通知的接口

```java
@Slf4j
@Service
public class PayService implements IPayService {

    @Autowired
    private BestPayServiceImpl bestPayService;

    @Override
    public PayResponse create(String orderId, BigDecimal amount) {
        PayRequest request = new PayRequest();
        request.setOrderName("6782806-最好的支付sdk");
        request.setOrderId(orderId);
        request.setOrderAmount(amount.doubleValue());
        request.setPayTypeEnum(BestPayTypeEnum.WXPAY_NATIVE);

        PayResponse response = bestPayService.pay(request);
        log.info("response={}", response);
        return response;
    }

    @Override
    public void asyncNotify(String notifyData) {
        // 1. 签名校验
        PayResponse payResponse = bestPayService.asyncNotify(notifyData);
        log.info("payResponse={}", payResponse);
    }
}
```

通知微信不用再通知的方式

让异步通知接口 return 指定字符串 
```java
// 4. 告诉微信不用再通知了
return "<xml>\n" +
        "  <return_code><![CDATA[SUCCESS]]></return_code>\n" +
        "  <return_msg><![CDATA[OK]]></return_msg>\n" +
        "</xml>";
```

##### 支付宝发起支付流程
需要在支付宝开放平台生成所需要的商户应用私钥与商户应用公钥 另外会有支付宝公钥与支付宝私钥（看不到）


*RSA 非对称加密*
发起支付：商户（商户应月私钥签名） -> 支付宝（商户应用公钥验签）

异步通知：支付宝（支付宝私钥签名） -> 商户（支付宝公钥验签）

商户应用私钥与支付宝公钥是Java应用中需要

RSA签名不等于加密（Java代码与RSA加密不同,一般加密解密使用AES）

*修改代码，兼容微信同时，添加支付宝支付的支持*


BestPayConfig
```java
@Component
public class BestPayConfig {

    @Bean
    public BestPayServiceImpl bestPayService() {
        WxPayConfig wxPayConfig = new WxPayConfig();
        wxPayConfig.setAppId("wxd898fcb01713c658");
        wxPayConfig.setMchId("1483469312");
        wxPayConfig.setMchKey("098F6BCD4621D373CADE4E832627B4F6");
        wxPayConfig.setNotifyUrl("http://ahogek.natapp1.cc/pay/notify");

        AliPayConfig aliPayConfig = new AliPayConfig();
        aliPayConfig.setAppId("2018062960540016");
        aliPayConfig.setPrivateKey("MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDUcbUUBaTJA4ngFx1xED2WHrkS4YCi3BRD");
        aliPayConfig.setAliPayPublicKey("MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtojdtkETo4OEsQLeyyPwtWK9ZqYJANq6jjX");
        aliPayConfig.setNotifyUrl("http://ahogek.natapp1.cc/pay/notify");
```

PayController
```java
@Controller
@RequestMapping("/pay")
@Slf4j
public class PayController {

    @Autowired
    private PayService payService;

    @GetMapping("/create")
    public ModelAndView create(@RequestParam("orderId") String orderId,
                            @RequestParam("amount") BigDecimal amount,
                            @RequestParam("payType") BestPayTypeEnum bestPayTypeEnum) {
        PayResponse payResponse = payService.create(orderId, amount, bestPayTypeEnum);
        Map<String, String> map = new HashMap<>();
        // 支付方式不同，渲染就不同，CodeUrl是WXPAY_NATIVE，body是ALIPAY_PC
        if (bestPayTypeEnum == BestPayTypeEnum.WXPAY_NATIVE) {
            map.put("codeUrl", payResponse.getCodeUrl());
            return new ModelAndView("createForWxNative", map);
        } else if (bestPayTypeEnum == BestPayTypeEnum.ALIPAY_PC) {
            map.put("body", payResponse.getBody());
            return new ModelAndView("createForAlipayPc", map);
        }
        throw new RuntimeException("暂不支持的支付类型");
    }

    @PostMapping("/notify")
    @ResponseBody
    public String asyncNotify(@RequestBody String notifyDate) {
        log.info("notifyDate={}", notifyDate);
        return payService.asyncNotify(notifyDate);
    }
}
```

PayService
```java
@Slf4j
@Service
public class PayService implements IPayService {

    @Autowired
    private BestPayServiceImpl bestPayService;

    @Override
    public PayResponse create(String orderId, BigDecimal amount, BestPayTypeEnum bestPayTypeEnum) {
        // 写入数据库
        PayRequest request = new PayRequest();
        request.setOrderName("6782806-最好的支付sdk");
        request.setOrderId(orderId);
        request.setOrderAmount(amount.doubleValue());
        request.setPayTypeEnum(bestPayTypeEnum);

        PayResponse response = bestPayService.pay(request);
        log.info("response={}", response);
        return response;
    }

    @Override
    public String asyncNotify(String notifyData) {
        // 1. 签名校验
        PayResponse payResponse = bestPayService.asyncNotify(notifyData);
        log.info("payResponse={}", payResponse);

        // 2. 金额校验 （从数据库查订单）

        // 3. 修改订单支付状态
        if (payResponse.getPayPlatformEnum() == BestPayPlatformEnum.WX)
            // 4. 告诉微信不用再通知了
            return "<xml>\n" +
                    "  <return_code><![CDATA[SUCCESS]]></return_code>\n" +
                    "  <return_msg><![CDATA[OK]]></return_msg>\n" +
                    "</xml>";
        else if (payResponse.getPayPlatformEnum() == BestPayPlatformEnum.ALIPAY)
            return "success";
        throw new RuntimeException("异步通知中错误的支付平台！");
    }
}
```

##### 打通支付与数据库

*用户在发起第二次支付前，把上一次的支付订单关闭（调用支付平台API）避免用户二次支付*

先通过 MybatisGenerator 生成所需要的支付信息表相关类与xml

修改PayInfo POJO类添加一个构造，通过构造方法来注入一些传入的值

```java
@Data
public class PayInfo {
    private Integer id;

    private Integer userId;

    private Long orderNo;

    private Integer payPlatform;

    private String platformNumber;

    private String platformStatus;

    private BigDecimal payAmount;

    private Date createTime;

    private Date updateTime;

    public PayInfo(Long orderNo, Integer payPlatform, String platformStatus, BigDecimal payAmount) {
        this.orderNo = orderNo;
        this.payPlatform = payPlatform;
        this.platformStatus = platformStatus;
        this.payAmount = payAmount;
    }
}
```

在逻辑层写关于数据写入修改的部分
```java
@Slf4j
@Service
public class PayService implements IPayService {

    @Autowired
    private BestPayServiceImpl bestPayService;

    @Autowired
    private PayInfoMapper payInfoMapper;

    @Override
    public PayResponse create(String orderId, BigDecimal amount, BestPayTypeEnum bestPayTypeEnum) {
        // 写入数据库
        PayInfo payInfo = new PayInfo(Long.parseLong(orderId),vscode://vscode.github-authentication/did-authenticate?windowId=1&code=526d256eb3511b78af1a&state=9b8b1bf9-77b5-4c39-904d-3214acff9a2c
                PayPlatformEnum.getByBestPayTypeEnum(bestPayTypeEnum).getCode(),
                OrderStatusEnum.NOTPAY.name(), amount);
        payInfoMapper.insertSelective(payInfo);

        PayRequest request = new PayRequest();
        request.setOrderName("6782806-最好的支付sdk");
        request.setOrderId(orderId);
        request.setOrderAmount(amount.doubleValue());
        request.setPayTypeEnum(bestPayTypeEnum);

        PayResponse response = bestPayService.pay(request);
        log.info("response={}", response);
        return response;
    }

    @Override
    public String asyncNotify(String notifyData) {
        // 1. 签名校验
        PayResponse payResponse = bestPayService.asyncNotify(notifyData);
        log.info("payResponse={}", payResponse);

        // 2. 金额校验 （从数据库查订单）
        // 表较严重（正常情况下是不会发生的）发出告警：钉钉、短信
        PayInfo payInfo = payInfoMapper.selectByOrderNo(Long.parseLong(payResponse.getOrderId()));
        if (payInfo == null)
            throw new RuntimeException("通过orderNo查询到的结果是null");
        // 如果订单支付状态不是已支付
        if (!payInfo.getPlatformStatus().equals(OrderStatusEnum.SUCCESS.name())) {
            // Double类型比较大小，精度。1.00 1.0
            if (payInfo.getPayAmount().compareTo(BigDecimal.valueOf(payResponse.getOrderAmount())) != 0)
                // 警告
                throw new RuntimeException("异步通知中的金额和数据库里的不一致，orderNo=" + payResponse.getOrderId());
            // 3. 修改订单支付状态
            payInfo.setPlatformStatus(OrderStatusEnum.SUCCESS.name());
            payInfo.setPlatformNumber(payResponse.getOutTradeNo());
            payInfoMapper.updateByPrimaryKeySelective(payInfo);
        }

        if (payResponse.getPayPlatformEnum() == BestPayPlatformEnum.WX)
            // 4. 告诉微信不用再通知了
            return "<xml>\n" +
                    "  <return_code><![CDATA[SUCCESS]]></return_code>\n" +
                    "  <return_msg><![CDATA[OK]]></return_msg>\n" +
                    "</xml>";
        else if (payResponse.getPayPlatformEnum() == BestPayPlatformEnum.ALIPAY)
            return "success";
        throw new RuntimeException("异步通知中错误的支付平台！");
    }
}
```

PayInfoMapper 添加一个通过订单号查询订单信息的方法
``PayInfo selectByOrderNo(Long orderNo);``

```xml
<select id="selectByOrderNo" resultType="io.github.ahogek.pay.pojo.PayInfo">
select
<include refid="Base_Column_List" />
from mall_pay_info
where order_no = #{orderNo,jdbcType=BIGINT}
</select>
```

##### 微信支付完成页面跳转

ajax -> api(通过订单号查询支付状态)
已支付 -> 跳转

修改配置类方便页面获取配置中的数据
```java
@Component
public class BestPayConfig {

    @Bean
    public BestPayServiceImpl bestPayService(WxPayConfig wxPayConfig) {
        AliPayConfig aliPayConfig = new AliPayConfig();
        aliPayConfig.setAppId("2018062960540016");
        aliPayConfig.setPrivateKey("MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDUcbUUBaTJA4ngFx1xED2WHrkS4YCi3BRD");
        aliPayConfig.setAliPayPublicKey("MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtojdtkETo4OEsQLeyyPwtWK9ZqYJANq6jjX");
        aliPayConfig.setNotifyUrl("http://ahogek.natapp1.cc/pay/notify");
        aliPayConfig.setReturnUrl("http://127.0.0.1");

        BestPayServiceImpl bestPayService = new BestPayServiceImpl();
        bestPayService.setWxPayConfig(wxPayConfig);
        bestPayService.setAliPayConfig(aliPayConfig);

        return bestPayService;
    }

    @Bean
    public WxPayConfig wxPayConfig() {
        WxPayConfig wxPayConfig = new WxPayConfig();
        wxPayConfig.setAppId("wxd898fcb01713c658");
        wxPayConfig.setMchId("1483469312");
        wxPayConfig.setMchKey("098F6BCD4621D373CADE4E832627B4F6");
        wxPayConfig.setNotifyUrl("http://ahogek.natapp1.cc/pay/notify");
        wxPayConfig.setReturnUrl("http://127.0.0.1");
        return wxPayConfig;
    }
}
```

修改Controller添加通过订单号查询订单详情的接口用于页面轮询
当中创建接口也需要添加一些页面上需要的数据到map中

```java
@Controller
@RequestMapping("/pay")
@Slf4j
public class PayController {

    @Autowired
    private PayService payService;

    @Autowired
    private WxPayConfig wxPayConfig;

    @GetMapping("/create")
    public ModelAndView create(@RequestParam("orderId") String orderId,
                            @RequestParam("amount") BigDecimal amount,
                            @RequestParam("payType") BestPayTypeEnum bestPayTypeEnum) {
        PayResponse payResponse = payService.create(orderId, amount, bestPayTypeEnum);
        Map<String, String> map = new HashMap<>();
        // 支付方式不同，渲染就不同，CodeUrl是WXPAY_NATIVE，body是ALIPAY_PC
        if (bestPayTypeEnum == BestPayTypeEnum.WXPAY_NATIVE) {
            map.put("codeUrl", payResponse.getCodeUrl());
            map.put("orderId", orderId);
            map.put("returnUrl", wxPayConfig.getReturnUrl());
            return new ModelAndView("createForWxNative", map);
        } else if (bestPayTypeEnum == BestPayTypeEnum.ALIPAY_PC) {
            map.put("body", payResponse.getBody());
            return new ModelAndView("createForAlipayPc", map);
        }
        throw new RuntimeException("暂不支持的支付类型");
    }

    @PostMapping("/notify")
    @ResponseBody
    public String asyncNotify(@RequestBody String notifyDate) {
        log.info("notifyDate={}", notifyDate);
        return payService.asyncNotify(notifyDate);
    }

    @GetMapping("/queryByOrderId")
    @ResponseBody
    public PayInfo queryByOrderId(@RequestParam String orderId) {
        log.info("查询支付记录...");
        return payService.queryByOrderId(orderId);
    }
}
```

Service就是添加简单的查询返回查询对象
```java
@Override
public PayInfo queryByOrderId(String orderId) {
    return payInfoMapper.selectByOrderNo(Long.parseLong(orderId));
}
```

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>支付</title>
</head>
<body>
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<p>微信支付</p>
<div id="wxQR"></div>
<div id="orderId" hidden >${orderId}</div>
<div id="returnUrl" hidden >${returnUrl}</div>
<script>
    jQuery('#wxQR').qrcode({
        text: "${codeUrl}"
    });

    $(function () {
        // 定时器
        setInterval(function () {
            console.log('开始查询支付状态...')
            $.ajax({
                url: '/pay/queryByOrderId',
                data: {
                    'orderId': $('#orderId').text()
                },
                success: function (result) {
                    console.log(result)
                    if (result.platformStatus != null && result.platformStatus === 'SUCCESS') {
                        location.href = $('#returnUrl').text()
                    }
                },
                error: function (result) {
                    alert(result)
                }
            })
        }, 2000)
    })
</script>
</body>
</html>
```

##### 规范配置

application.yml
```yml
wx:
  appId: wxd898fcb01713c658
  mchId: 1483469312
  mchKey: 098F6BCD4621D373CADE4E832627B4F6
  notifyUrl: 098F6BCD4621D373CADE4E832627B4F6
  returnUrl: http://127.0.0.1

alipay:
  appId: 2018062960540016
  privateKey: "MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDUcbUUBaTJA4ngFx1xED2WHr"
  publicKey: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtojdtkETo4OEsQLeyyPwtWK9ZqYJAN"
  notifyUrl: http://ahogek.natapp1.cc/pay/notify
  returnUrl: http://127.0.0.1
```

WxAccountConfig.java
```java
@Component
@ConfigurationProperties(prefix = "wx")
@Data
public class WxAccountConfig {

    private String appId;

    private String mchId;

    private String mchKey;

    private String notifyUrl;

    private String returnUrl;
}
```

AlipayAccountConfig.java
```java
@Component
@ConfigurationProperties(prefix = "alipay")
@Data
public class AlipayAccountConfig {

    private String appId;

    private String privateKey;

    private String publicKey;

    private String notifyUrl;

    private String returnUrl;
}
```

BestPayConfig.java
```java
@Component
public class BestPayConfig {

    @Autowired
    WxAccountConfig wxAccountConfig;

    @Autowired
    AlipayAccountConfig alipayAccountConfig;

    @Bean
    public BestPayServiceImpl bestPayService(WxPayConfig wxPayConfig) {
        AliPayConfig aliPayConfig = new AliPayConfig();
        aliPayConfig.setAppId(alipayAccountConfig.getAppId());
        aliPayConfig.setPrivateKey(alipayAccountConfig.getPrivateKey());
        aliPayConfig.setAliPayPublicKey(alipayAccountConfig.getPublicKey());
        aliPayConfig.setNotifyUrl(alipayAccountConfig.getNotifyUrl());
        aliPayConfig.setReturnUrl(alipayAccountConfig.getReturnUrl());

        BestPayServiceImpl bestPayService = new BestPayServiceImpl();
        bestPayService.setWxPayConfig(wxPayConfig);
        bestPayService.setAliPayConfig(aliPayConfig);

        return bestPayService;
    }

    @Bean
    public WxPayConfig wxPayConfig() {
        WxPayConfig wxPayConfig = new WxPayConfig();
        wxPayConfig.setAppId(wxAccountConfig.getAppId());
        wxPayConfig.setMchId(wxAccountConfig.getMchId());
        wxPayConfig.setMchKey(wxAccountConfig.getMchKey());
        wxPayConfig.setNotifyUrl(wxAccountConfig.getNotifyUrl());
        wxPayConfig.setReturnUrl(wxAccountConfig.getReturnUrl());
        return wxPayConfig;
    }
}
```

[配置类Configuration Annotation Proessor not found in classpath](https://blog.csdn.net/w05980598/article/details/79167826)