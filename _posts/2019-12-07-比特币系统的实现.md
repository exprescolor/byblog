---
layout:     post 
title:      区块链
subtitle:   比特币系统的具体实现
date:       2019-12-07
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 区块链
---

#### UTXO

- 区块链是一个去中心化的账本，而比特币采用的是一种基于交易的账本模式（transaction-based ledger），还有一种是基于账户的账本模式（account-based ledger）。每个区块中记录的是交易信息，但是系统当中并没有哪一个地方显式的记录每一个账户中有多少钱，这个需要用交易记录来推算
- **比特币中的全结点要维护一个叫做UTXO的数据结构（Unspent Transaction Output）**：区块链上有很多交易，有些交易的输出可能已经被花掉了，有些还没有被花掉，所有那些还没有被花掉的输出的集合就叫做UTXO。一个交易可能有多个输出
- UTXO集合中的每个元素要给出产生这个输出的交易的哈希值以及他在这个交易中是第几个输出
- UTXO的主要作用是检测double spending，每发生一次交易，就要检测用户所花掉的比特币是不是在UTXO中，如果不在，则表示是非法的。所以全节点要在内存中维护UTXO，以便快速检测double spending
- 每个交易会消耗掉一些输出，但是又会产生一些新的输出
- 每个交易都要保证总输出=总输入（total inputs=total outputs）。但是有些交易可能会产生总输出略微小于总输入的情况，这里面的差额就作为交易费给获得记账权发布区块的那个节点
   - 结点消耗资源来竞争记账权，一是为了获得出块奖励，发布一个区块，可以得到一定数量的比特币作为报酬。但是光有这个出块奖励可能是不够的，发布区块的那个结点为什么要把你的交易打包在他的区块中？这样做对他有什么好处？比如某一个比较自私的结点，他可能发布区块的时候只包含他自己的那个交易，别的交易都不管，因为把别的交易打包进去对他自己没什么好处，而且还有一定的代价，因为你需要验证这个交易的合法性，而且区块中的交易多的话占用的带宽也比较多，在网络上传播的速度也会变慢。所以只存在出块奖励的话就会出现有的节点不管别人的交易，只存储自己的交易。**所以比特币系统就设计了第二个机制，也就是上面说的交易费（transaction fee）**

#### 区块链中的简单例子

![Qqdrg1.png](https://s2.ax1x.com/2019/12/19/Qqdrg1.png)

- 各个单词的解释：
   - Number Of Transaction：当前区块中包含的交易数量
   - Output Total：总共输出的比特币数量
   - Transaction Fees：总的交易费
   - Block Reward：出块奖励
   - Height：区块的序号
   - TimeStamp：当前区块的时间戳
   - Difficulty：挖矿的难度（每隔2016个区块就要调整难度，保持出块时间在十分钟左右）
   - Nonce：挖矿时尝试的随机数
   - Hash：当前区块的块头的哈希值
   - Previous Block：前一个区块的块头的哈希值
   - Merkle Root：当前区块中包含的交易组成的Merkle Tree的根哈希值

![QqdgHO.png](https://s2.ax1x.com/2019/12/19/QqdgHO.png)

- nNonce：代表的是32位的无符号整数，挖矿时要不断调整nonce的取值，但是这个nonce最多只有2的32次方个可能的取值。就算把nonce的值全部尝试一遍，也可能找不到符合难度要求的，因为比特币的价格上涨的太快，挖矿的人过多，挖矿难度已经被调的非常高，单纯靠调整block header里面nonce的域，比较大的概率是找不到符合要求的，搜索空间不够大。所以我们可以调节block header中其他域的范围（这里直接给出结论：可以更改Merkle Tree的根哈希值和区块的产生时间）

![Qqdbb8.png](https://s2.ax1x.com/2019/12/19/Qqdbb8.png)

- 上图是block header中各个域的描述
   - version：当前使用的比特币协议的版本号，这个是无法更改的
   - pervious block header hash：前一个区块块头的哈希值，这个无法更改
   - merkle root hash：Merkle Tree的根哈希值
   - time：当前区块产生的时间。这个是有一定的调整余地的，比特币系统不要求非常精准的时间，可以对这里的时间在一定范围内进行调整
   - nBits：挖矿时用到的目标域值，这个是编码后的版本，因为他只有四个字节，这个只能按照协议中的要求定期进行调整，不能随意更改
   - nonce：通常调整的随机数nonce
- **为什么可以更改Merkle Tree的根哈希值？**
   - 如图是一个小型区块链
   - ![QqdLVS.png](https://s2.ax1x.com/2019/12/19/QqdLVS.png)
   - 首先，左下角的tx是铸币交易，我们更改了这个交易的域之后，它对应的哈希值就会发生变化，从而一路网上影响到block header根哈希值（如下）
   - ![QqdX5Q.png](https://s2.ax1x.com/2019/12/19/QqdX5Q.png)
   - 所以我们可以通过更改铸币交易的域来更改最终的根哈希值。所以真正挖矿的时候只有两层循环：外层循环调整这个铸币交易的extra nonce，算出block header里面的根哈希值之后，内层循环再调整header里面的nonce

- 如图是一个比特币转账交易
- ![Qqdz2n.png](https://s2.ax1x.com/2019/12/19/Qqdz2n.png)
   - 上面写的output指的是说他们花掉的是之前某个交易的output，这笔交易的两个输出还没有被花掉（Unspend）
   - 输入和输出都是用脚本的形式来指定，比特币系统中验证交易的合法性就是把当前交易的Input Scripts和上一个提供币的来源的交易的Output Scripts配对后执行来完成的。如果输入脚本和输出脚本拼接在一起能够顺利执行，不出现错误，那么这个交易就是合法的。

- 下图是一个错误示例
- ![QqwFVU.png](https://s2.ax1x.com/2019/12/19/QqwFVU.png)
   - 上图在求哈希的过程中把所有信息组合在一起求的哈希，实际上只需要block header中的信息来求哈希值

#### 挖矿过程的概率分析

- 挖矿就是不断的尝试各种nonce来求解puzzle，每次尝试nonce可以看作是一个Bernoulli trial（伯努利试验：在同样的条件下重复地、相互独立地进行的一种随机试验，其特点是该随机试验只有两种可能结果：发生或者不发生。典型的示例就是掷硬币）
- 伯努利试验的一个特性就是无记忆性，也就是说，无论你尝试多少次，他的概率一直就是这么大，不可能随着你尝试的次数越多发生改变。
- 应用到挖矿上也就是说：每个新的区块产生的时间是10分钟，在过了十分钟之后再进行当前挖矿操作，他并不会减少时间，依旧需要十分钟才能产生下一个区块（正常思想是你进行了十分钟，那么你就积累了十分钟的工作量，那么你越往后应该是越快能挖到矿）。这样的操作反而保证了挖矿的公平性（因为算力越大的机器，他们能够在十分钟内尝试的nonce越多，在超过十分钟后，就需要重新开始，否则对于算力小的设备就会产生不成一直维持在某一个值不会改变）。

#### 比特币的总量分析

- 出块奖励（block reward）是系统中产生新的比特币的唯一途径，而出块奖励是每隔四年就要减半的（具体运算过程省略）。根据Geometric series来计算，可以算出比特币的所有数量大概是2100万个。比特币的稀缺性是人为造成的。
- 对于一个去中心化的，没有membership的系统，挖矿提供了一种根据算力来进行投票的有效手段，只要大部分算力是掌握在诚实的结点手里，系统的安全性就能够得到保证

#### 比特币的安全性分析

- 假设大部分算力是掌握在诚实的矿工手中，我们能得到什么样的安全保证？能不能保证写入区块链的交易都是合法的？
- 挖矿给的只是概率上的保证，只能说有比较大的概率下一个区块是由一个诚实的矿工所发布的，但是不能保证记账权不会落到有恶意的结点手里。
   - 假设有一个结点获得了记账权，他也不能够把其他人的钱转走，因为他不知道其他用户的私钥；如果他强行把一个交易写入到区块链中，诚实的结点并不会接受这个非法交易，他只会沿着上一条合法的区块进行挖矿操作。判断攻击是否成功的标准是看诚实的结点是不是认可这个交易。
   - 对于double spending，比特币系统默认的是在当前交易写入区块链之后，等待之后六个区块的生成，当生成六个区块后，才认为写入到区块链的那个交易是不可篡改的。
- 比特币协议中规定每个区块的大小不能超过1Mb

#### Selfish Mining

- 正常情况下，我们挖到一个区块马上就发布出去，因为你不发布，别人把这个区块发布之后，你就得不到出块奖励了
- 而selfish mining是挖到区块之后先不发布
- 具体作用先按下不表