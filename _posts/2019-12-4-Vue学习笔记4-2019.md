---
layout:     post                        # 使用的布局（不需要改）
title:      VUE学习笔记4               # 标题
subtitle:   组件化应用构建     # 副标题
date:       2019-12-4                 # 时间
author:     AhogeK                      # 作者
header-img: https://ahogek.github.io/img/home-bg-o.jpg     # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - 学习笔记
    - VUE
---
### Vue 组件化应用构建

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：

![vue组件](https://cn.vuejs.org/images/components.png)

在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：

![vuecomponentcode](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191204171030.png)

现在你可以用它构建另一个组件模板：

![vuecomponentcode2](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191204181325.png)

但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 ``prop``：

![vuecomponentcode3](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191204181537.png)

现在，我们可以使用 ``v-bind`` 指令将待办项传到循环输出的每个组件中：

![vuecomponentcode3](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191204181731.png)

尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 ``<todo-item>`` 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。

#### 自定义元素的关系

你可能已经注意到 Vue 组件非常类似于*自定义元素*——它是 **Web 组件规范**的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 **Slot API** 与 ``is`` 特性。但是，还是有几个关键差别：

Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。

Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。

虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，<u>依然有很好的互操作性</u>。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。

![vuecomponentcode4](https://ahogek-oss.oss-cn-hangzhou.aliyuncs.com/blog-img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191204182326.png)