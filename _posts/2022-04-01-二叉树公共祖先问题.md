---
layout:     post   				    # 使用的布局（不需要改）
title:      LC235&236题————二叉树公共祖先问题				# 标题 
subtitle:   题目类型:Midium #副标题
date:       2022-04-01 				# 时间
author:     谢玄xx 						# 作者
header-img: img/bit (1).jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 二叉树
---

# 235题——二叉搜索树的公共祖先


## 解题思路1

遇到这种题要首先想到递归法。

* 如果根节点为空，直接返回NULL；
* 如果left和right有一个为根节点，那么他俩的公共祖先必为根节点；
* 如果两个目标节点有一个为空，那么就返回另一个节点；
* 如果目标节点分居左右子树，那么必返回root；
* 如果上述情况均不满足(不可能)，就返回NULL。

## 代码如下
```CPP
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
{
	if(!root) return NULL;
	auto left = lowestCommonAncestor(root->left, p, q);
	auto rihgt = lowestCommonAncestor(root->right, p, q);
	if(root == p || root == q) return root;
	if(left == NULL) return right;
	if(right == NULL) return left;
	if(left && right) return root;
	return NULL;
}
```


## 解题思路2

采用栈的思想解决问题。问题的解决一共有两步：

* 首先从根节点开始遍历，到目标节点为止，记录途径节点，将其存放在栈内；
* 遍历到目标节点时，将两个栈从根节点开始比较。最后一个完全相同地址所对应的节点即为所求。

# 235题——二叉树的公共祖先


## 解题思路

