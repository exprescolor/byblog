---
layout:     post                        # 使用的布局（不需要改）
title:      MyBatis Plus 学习笔记              # 标题
subtitle:   个人学习记录                  # 副标题
date:       2020-04-13                  # 时间
author:     AhogeK                      # 作者
header-img:  https://ahogek.github.io/img/post-unix-linux.jpg    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - SpringBoot
    - 学习笔记
---
# 入门
### MP 分页插件
> 在MybatisPlusConfig配置类中添加分页方法并通过spring bean 管理

```java
@Configuration
public class MybatisPlusConfig {
	
	@Bean
	public PaginationInterceptor paginationInterceptor() {
		return new PaginationInterceptor();
	}
}
```

### 实体类注解

``@TableId`` [主键注解](https://mp.baomidou.com/guide/annotation.html#tableid)

``@TableField``[字段注解(非主键)](https://mp.baomidou.com/guide/annotation.html#tablefield)

Service层的CRUD配置

```java
public interface UserService extends IService<User> {

}

@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
	
}
```

#### MP一系列查询方法

AR模式直接使用实体类进行增删改查

```java
User user = new User();
user.setName("朱旋风");
user.setAge(28);
user.setEmail("zhc@gmail.com");W
user.setManagerId(6L);
user.setCreateTime(LocalDateTime.now());
boolean insert = user.insert();

User user = new User();
User selectUser = user.selectById(1242738829767946242L);
System.out.println(user == selectUser);
System.out.println(selectUser);
```

Query 得多种用法

``LambdaQueryWrapper<User> lambdaQuery = Wrappers.<User>lambdaQuery();``

``List<User> list = userService.lambdaQuery().gt(User::getAge, 25).like(User::getName, "朱").list();``

两种 LambdaUpdate

```java
LambdaUpdateWrapper<User> lambdaUpdateWrapper = new LambdaUpdateWrapper<>();
lambdaUpdateWrapper.eq(User::getRealName, "shimin").set(User::getAge, 34);
Integer rows = userMapper.update(null, lambdaUpdateWrapper);


LambdaUpdateChainWrapper<User> lambdaUpdateChainWrapper = new LambdaUpdateChainWrapper<>(userMapper);
boolean update = lambdaUpdateChainWrapper.eq(User::getRealName, "shimin").set(User::getAge, 33).update();
```

---
# 进阶
## 逻辑删除
### mp的相关配置

```yml
mybatis-plus:
  global-config:
    db-config:
      logic-not-delete-value: 0
      logic-delete-value: 1
```
**以上的 0未删除 1删除是默认配置可不进行配置**

*如果 Mybatis plus 的版本是低于 3.1 需要在配置类中配置 ISqlInjector Bean*

```java
@Bean
public ISqlInjector sqlInjector() {
    return new LogicSqlInjector();
}
```

最后在实体类中的删除标识字段上配置注解
``@TableLogic``

完成后，对表进行CRUD都会对是否删除进行判断 注：**对自定义查询无效**

其中，查询中会注意到查询还是带了标识，不过查询不想要，可以去除，只需在实体类的标识属性上添加配置注解
``@TableField(select = false)``

#### 关于 customSqlSegment
此项用于自定义查询中，在传参中传入 Wrapper 并用``@param``配置标识名，一般使用``Constants.WRAPPER`` 即ew
随后在查询中使用 ``${ew.customSqlSegment}`` 即可无需添加 where 包含的条件

```sql
select * from user ${ew.customSqlSegment}
```

## 自动填充
### 实体类注解
在需要进行自动填充的属性上设置自动填充注解
``@TableField(fill=FieldFill.INSERT)`` *插入时填充，其他还包括更新时，插入或更新时等*

### 创建处理类
创建用于自动填充的处理类，并实现 *MetaObjectHandler* 接口

早期版本 MP 通过 ``setInsertFieldValByName`` 函数进行字段的自动填充
最新版本已废弃
使用 ``strictInsertFill`` 函数进行填充
``strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now())``

``metaObject.hasSetter("createTime")`` 可查看是否包含指定字段（实体类的属性名），在有的情况再进行填充

## 乐观锁

在 MP 配置类配置乐观锁

```java
@Bean
public OptimisticLockerInterceptor optimisticLockerInterceptor() {
  return new OptimisticLockerInterceptor();
}
```

在实体类需要进行乐观锁得字段属性上配置 ``@Version`` 即可

## 性能分析

已移除MP自带的性能解析器，使用第三方插件
*p6spy 详细查阅 MP 官方文档*

## 多租户
### 多租户配置

```java
/**
  * 多租户 依赖于 分页插件
  */
@Bean
public PaginationInterceptor paginationInterceptor() {
  PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
  // 配置多租户解析接口
  ArrayList<ISqlParser> sqlParserList = new ArrayList<>();
  TenantSqlParser tenantSqlParser = new TenantSqlParser();
  tenantSqlParser.setTenantHandler(new TenantHandler(){
    
    /**
      * 多租户字段是什么（表中字段名）
      */
    @Override
    public String getTenantIdColumn() {
      return "manager_id";
    }
    
    /**
      * 租户信息 实际manager_id值
      */
    @Override
    public Expression getTenantId(boolean where) {
      return new LongValue(1087982257332887553L);
    }
    
    /**
      * 哪些加租户信息哪些不加
      * false 即返回加上租户信息
      */
    @Override
    public boolean doTableFilter(String tableName) {
      // 不加租户信息
      if ("role".equals(tableName)) {
        // 如果查得时角色表不加租户信息
        return true;
      }
      return false;
    }
  });
  sqlParserList.add(tenantSqlParser);
  paginationInterceptor.setSqlParserList(sqlParserList);
  paginationInterceptor.setSqlParserFilter(new ISqlParserFilter() {
    
    /**
      * 过滤方法不加入租户信息Constants
      */
    @Override
    public boolean doFilter(MetaObject metaObject) {
      MappedStatement mappedStatement = SqlParserHelper.getMappedStatement(metaObject);
      if ("io.github.ahogek.mphigh.dao.UserMapper.selectById".equals(mappedStatement.getId())) {
        return true;
      }
      return false;
    }
  });
  return paginationInterceptor;
}
```

*可直接再Mapper得方法中添加 ``@SqlParser(filter = true)``注解来确认是否过滤*

## 动态表
### 动态表配置
```java
// 配置动态表解析器
DynamicTableNameParser dynamicTableNameParser = new DynamicTableNameParser();
Map<String, ITableNameHandler> tableNameHandlerMap = new HashMap<>();
tableNameHandlerMap.put("user", new ITableNameHandler() {
  
  @Override
  public String dynamicTableName(MetaObject metaObject, String sql, String tableName) {
    return myTableName.get();
  }
});
dynamicTableNameParser.setTableNameHandlerMap(tableNameHandlerMap);
// 配置多租户解析接口
ArrayList<ISqlParser> sqlParserList = new ArrayList<>();
sqlParserList.add(dynamicTableNameParser);
```

**dynamicTableName返回一个表名 需要一个域存储，可以是ThreadLocal，request域等，若查询方法被多租户过滤，其动态配置不生效**

## SQL注入器

```java
/**
 * SQL 注入器
 * 
 * @author AhogeK
 *
 */
@Component
public class MySqlInjector extends DefaultSqlInjector {

	@Override
	public List<AbstractMethod> getMethodList(Class<?> mapperClass) {
		List<AbstractMethod> methodList = super.getMethodList(mapperClass);
		methodList.add(new DeleteAllMethod());
		methodList.add(new InsertBatchSomeColumn(t -> !t.isLogicDelete()&&!t.getColumn().equals("age")));
		return methodList;
	}
	
}
```

*其中 ``new InsertBatchSomeColumn(t -> !t.isLogicDelete()&&!t.getColumn().equals("age"))`` 是选装件*

#### 自定义查询方法

```java
public class DeleteAllMethod extends AbstractMethod {
	
	/**
	 * 自定义方法
	 */
	@Override
	public MappedStatement injectMappedStatement(Class<?> mapperClass, Class<?> modelClass, TableInfo tableInfo) {
		// 执行的sql
		String sql = "delete from " + tableInfo.getTableName();
		// mapper 接口方法名
		String method = "deleteAll";
		SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);
		return addDeleteMappedStatement(mapperClass, method, sqlSource);
	}

}
```

可以新建一个公共mapper继承 BaseMapper 用于设置自定义方法 而普通方法继承此公共mapper

```java
public interface MyMapper<T> extends BaseMapper<T> {
	
	/**
	 * 自定义 sql 删除所有，返回影响行数
	 * 
	 * @return
	 */
	int deleteAll();
	
	int insertBatchSomeColumn(List<T> list);
}

```