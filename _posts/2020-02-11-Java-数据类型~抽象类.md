---
layout:     post 
title:      Java：数据类型~抽象类
subtitle:   Java总结
date:       2020-02-11
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - Java
---

##  Java

### Java基础

#### 一、数据类型

基本类型

- byte/8
- char/16
- short/16
- int/32
- float/32
- long/64
- double/64
- boolean/~

boolean只有两个值：true，false，可以用1bit来存储，到那时具体大小没有规定。JVM会在编译时期将boolean类型的数据转化成int，使用1来表示true，0表示false。JVM支持boolean数组，但是是通过读写byte数组来实现的。

---------------

包装类型

- 基本类型都有对应的包装类型，基本类型和其对应的包装类型之间的赋值使用自动装箱和拆箱完成

```java
Integer x=2;  //装箱
int y=x;  //拆箱
```

-----------------

缓存池

- `new Integer(123)`和`Integer.valueOf(123)`的区别在于：
   - new Integer(123)每次都会新建一个对象
   - Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用

```java
Integer x=new Integer(123);
Integer y=new Integer(123);
System.out.println(x==y);   //false
Integer z=Integer.valueOf(123);
Integer k=Integer.valueOf(123);
System.out.println(z==k);   //true
```

valueOf()方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池中的内容。

```java
public static Integer valueOf(int i) {
	if (i >= IntegerCache.low && i <= IntegerCache.high)
	return IntegerCache.cache[i + (-IntegerCache.low)];
	return new Integer(i);
}
```

在Java8中，Integer缓存池的默认大小是-128~127
编译器会在自动装箱的过程调用valueOf()方法，因此多个值相同且在缓存池范围的Integer实例使用自动装箱来创建，那么就会引用相同的对象。

基本类型对应的缓冲池如下
- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。
在JDK 1.8所有的数值类缓冲池中，Integer的缓冲池IntegerCache很特殊，这个缓冲池的下限是-128，上限是127，但是这个上限是可调的，在启动JVM的时候，通过-`XX:AutoBoxCacheMax=<size>`来指定这个缓冲池的大小，该选项在JVM初始化的时候会设定一个名为java.lang.IntegerCache.high系统属性，然后IntegerCache初始化的时候就会读取该系统属性来决定上限。

-----------------

#### 二、String

String被声明为final，因此他不能被集继承
在Java8中，String内部使用char数组存储数据
```java
public final class String
implements java.io.Serializable, Comparable<String>, CharSequence {
	/** The value is used for character storage. */
	private final char value[];
}
```

在Java9之后，String类的实现改用byte数组存储字符串，同时使用coder来标识使用了哪种编码
```java
public final class String
	implements java.io.Serializable, Comparable<String>, 	CharSequence {
	/** The value is used for character storage. */
	private final byte[] value;
	/** The identifier of the encoding used to encode the bytes in {@code value}. */
	private final byte coder;
}
```

value数组被声明为final，这意味着value数组初始化之后就不能再引用其他数组，并且String内部没有改变value数组的方法，因此可以保证String不变。

----------------------

**不变的好处**

1. 可以缓存hash值：因为String的hash值经常被使用，例如String用作HashMap的key。不可变的特性可以使得hash也不可变，因此只需要进行一次计算。
2. String Pool的需要：如果一个String对象已经被创建过了，那么就会从String Pool中取得引用。只有String是不可变的，才可能使用String Pool。
3. 安全性：String经常作为参数，String不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果String是可变的，那么在网络连接过程中，String被改变，改变String对象的那一方以为现在连接的是其他主机，而实际情况不一定是。
4. 线程安全：String不可变性天生具备线程安全，可以在多个线程中安全的使用。

------------------------

**String、StringBuffer、StringBuilder**

1. 可变性：String不可变，StringBuffer和StringBuilder可变
2. 线程安全：String不可变，因此是安全的；StringBuilder不是线程安全的；StringBuffer是线程安全的，内部使用synchronized进行同步。

-------------------------

**String Pool**

字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时就确定，不仅如此，还可以使用String的intern()方法在运行过程中将字符串添加到String Pool中。
当一个字符串调用intern()方法时，如果String Pool中已经存在一个字符串和该字符串值相等（使用equals()方法进行确定），那么就会返回String Pool中字符串的引用；否则，就会在String Pool中添加一个新的字符串，并返回这个新字符串的引用。
下面示例中，s1和s2采用new String()的方式新建了两个不同字符串，而s3和s4是通过s1.intern()方法取得一个字符串引用。intern()首先把s1引用的字符串放到String Pool中，然后返回这个字符串引用。因此s3和s4引用的是同一个字符串。
```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2); // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4); // true
```

如果使用的是“bbb”这种字面量的形式创建字符串，会自动的将字符串放到String Pool中
```java
String s5="bbb";
String s6="bbb";
System.out.println(s5 == s6); // true
```

在Java7之前，String Pool被放在运行时常量池中，它属于永久代。而在Java7，String Pool被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误。

--------------------

**new String("abc")**

使用这种方法一共会创建两个字符串对象（前提是String Pool中还没有“abc”字符串对象）
- “abc“属于字符串字面量，因此编译时会在String Pool中创建一个字符串对象，指向这个”abc“字符串字面量
- 而使用new的方式会在堆中创建一个字符串对象

----------------------------------

#### 三、运算

参数传递

Java的参数是以值传递的形式传入方法中，而不是引用传递
以下代码中Dog dog的dog是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其他对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。

```java
public class Dog {
	String name;
	Dog(String name) {
		this.name = name;
	}
	String getName() {
		return this.name;
	}
	void setName(String name) {
		this.name = name;
	}
	String getObjectAddress() {
		return super.toString();
	}
	
	private static void func(Dog dog) {
		System.out.println(dog.getObjectAddress()); // Dog@4554617c
		dog = new Dog("B");
		System.out.println(dog.getObjectAddress()); // Dog@74a14482
		System.out.println(dog.getName()); // B
	}
}
```

如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容
```java
class PassByValueExample {
	public static void main(String[] args) {
		Dog dog = new Dog("A");
		func(dog);
		System.out.println(dog.getName()); // B
	}
	private static void func(Dog dog) {
		dog.setName("B");
	}
}
```

--------------------

**float和double**

Java不能隐式执行向下转型，因为这会使得精度降低
1.1字面量属于double类型，不能直接将1.1直接赋值给float变量，因为这是向下转型
1.1f字面量才是float类型

隐式类型转换
因为字面量1是int类型，它比short类型精度要高，因此不能隐式地将int类型向下转型为short类型。但是使用+=或者++运算符可以执行隐式类型转换
```java
short s1=1;
s1=s1+1;   //错误
s1+=1;    //正确
```

上面的语句相当于将s1+1的计算结果进行了向下转型
```java
s1=(short)(s1+1);
```

------------------------------

**switch**

从Java7开始，可以在switch条件判断语句中使用String对象。
```java
String s = "a";
switch (s) {
	case "a":
		System.out.println("aaa");
		break;
	case "b":
		System.out.println("bbb");
		break;
}
```

switch不支持long，是因为switch的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用if比较合适。

-------------------------

#### 四、继承

访问权限

Java中有三个访问权限修饰符：private，protected以及public，如果不加访问修饰符，则标识包级可见
可以对类或类中成员（字段以及方法）加上访问修饰符
- 类可见表示其他类可以用这个类创建实例对象
- 成员可见表示其他类可以用这个类的实例对象访问到该成员

protected用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。
设计料号的模块会隐藏所有的实现细节，把他的API与他的实现清晰的隔离开来。模块之间只通过他们的API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。
如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换规则。
字段绝不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample拥有id公有字段，如果在某个时刻，我们想要使用int存储id字段，那么就需要修改所有的客户端代码。
```java
public class AccessExample {
	public String id;
}
```

可以使用公有的getter和setter方法来替换公有字段，这样的话就可以控制对字段的修改行为
```java
public class AccessExample {
	private int id;
	public String getId() {
		return id + "";
	}
	public void setId(String id) {
		this.id = Integer.valueOf(id);
	}
}
```

但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员就不会有特别大的影响。
```java
public class AccessWithInnerClassExample {
	private class InnerClass {
		int x;
	}
	private InnerClass innerClass;
	public AccessWithInnerClassExample() {
		innerClass = new InnerClass();
	}
	public int getValue() {
		return innerClass.x; // 直接访问
	}
}
```

-----------------------------

**抽象类与接口**

- 1.抽象类

抽象类和抽象方法都使用abstract关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类和普通类的最大区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。
```java
public abstract class AbstractClassExample {
	protected int x;
	private int y;
	public abstract void func1();
	public void func2() {
		System.out.println("func2");
	}
}

public class AbstractExtendClassExample extends AbstractClassExample {
	@Override
	public void func1() {
		System.out.println("func1");
	}
}

// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
```

-------------------------

- 2.接口

接口是抽象类的延伸，在Java8之前，他可以看作是一个完全抽象的类，也就是说它不能有任何的方法实现。
从Java8开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口维护成本太高了。在Java8之前，如果一个接口想要添加新的方法，那么就要修改所有实现了该接口的类。
接口的成员（字段+方法）默认都是public的，并且不允许定义为private或者protected
接口的默认字段都是static和final的
```java
public interface InterfaceExample {
	void func1();
	default void func2(){
		System.out.println("func2");
	}
	int x = 123;
	// int y; // Variable 'y' might not have been initialized
	public int z = 0; // Modifier 'public' is redundant for interface fields
	// private int k = 0; // Modifier 'private' not allowed here
	// protected int l = 0; // Modifier 'protected' not allowed here
	// private void fun3(); // Modifier 'private' not allowed here
}

public class InterfaceImplementExample implements InterfaceExample {
	@Override
	public void func1() {
		System.out.println("func1");
	}
}

// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
```

-----------------------------

- 3.比较
   - 从设计层面上看，抽象类提供了一种IS-A关系，那么就必须满足里氏替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种LIKE-A关系，他只是提供一种实现契约，并不要求接口和实现接口的类具有IS-A关系。
   - 从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类
   - 接口的字段只能是static和final类型的，而抽象类的字段没有这种限制
   - 接口的成员只能是public的，而抽象类的成员可以有多种访问权限。

-----------------------------

- 4.使用选择
- 使用接口：
   - 需要让不相关的类都实现一个方法，例如不相关的类都可以实现Compareable 接口中的 compareTo() 方法；
   - 需要使用多重继承
- 使用抽象类
   - 需要在几个相关的类中共享代码
   - 需要能够控制继承来的成员的访问权限，而不是都为public
   - 需要继承非静态和非常量字段

在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活的为一个类添加行为。并且从Java8开始，接口也可以有默认的方法实现，使得修改接口的成本也变得很低。