---
layout:     post                        # 使用的布局（不需要改）
title:      NIO编程基础               # 标题
subtitle:     # 副标题
date:       2020-06-06                  # 时间
author:     AhogeK                      # 作者
header-img:  https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fi.stack.imgur.com%2FEdv8s.jpg&f=1&nofb=1    # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - NIO
---
### NIO
>NIO(New I/O)是Java用来代替I/O的第二个I/O系统，它支持面向缓冲的，基于通道的I/O操作方法。

NIO支持面向缓冲，基于通道的I/O操作方法。可以实现高速I/O。

Java NIO有三个基本的组件

![NIO组件](https://www.yiibai.com/uploads/images/201709/2809/347160956_79963.png)

NIO读写的基本过程：

NIO通道读取  通道中创建一个缓冲区 -> 请求通道读取缓冲区数据

NIO通道写入  通道中创建一个缓冲区 -> 在缓冲区中填充数据 -> 要求通道写入数据

读写操作的核心部件
* Channels
* Buffers
* Selectors

NIO中主要使用的通道
* DatagramChannel
* SocketChannel
* FileChannel
* ServerSocketChannel

**上述通道涵盖UDP|TCP网络I/O及文件I/O**

NIO中主要的核心缓冲区
* CharBuffer
* DoubleBuffer
* IntBuffer
* ByteBuffer
* ShortBuffer
* FloatBuffer

在NIO提供了“选择器”的概念，可用于监视多个通道对象，可单线程监视多通道数据。
![NIO选择器](https://www.yiibai.com/uploads/images/201709/2809/842170920_76561.png)

#### Java NIO包
<table>
<thead>
<tr>
<th>包名称</th>
<th>使用/目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>java.nio</code></td>
<td>它是NIO系统的顶级包，NIO系统封装了各种类型的缓冲区。</td>
</tr>
<tr>
<td><code>java.nio.charset</code></td>
<td>它封装了字符集，并且还支持分别将字符转换为字节和字节到编码器和解码器的操作。</td>
</tr>
<tr>
<td><code>java.nio.charset.spi</code></td>
<td>它支持字符集服务提供者</td>
</tr>
<tr>
<td><code>java.nio.channels</code></td>
<td>它支持通道，这些通道本质上是打开I/O连接。</td>
</tr>
<tr>
<td><code>java.nio.channels.spi</code></td>
<td>它支持频道的服务提供者</td>
</tr>
<tr>
<td><code>java.nio.file</code></td>
<td>它提供对文件的支持</td>
</tr>
<tr>
<td><code>java.nio.file.spi</code></td>
<td>它支持文件系统的服务提供者</td>
</tr>
<tr>
<td><code>java.nio.file.attribute</code></td>
<td>它提供对文件属性的支持</td>
</tr>
</tbody>
</table>

#### Java IO与NIO比较

<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于阻塞I/O操作</td>
<td>基于非阻塞I/O操作</td>
</tr>
<tr>
<td>面向流的</td>
<td>面向缓存的</td>
</tr>
<tr>
<td>通道不可用</td>
<td>通道可用于非阻塞I/O操作</td>
</tr>
<tr>
<td>选择器不可用</td>
<td>选择器可用于非阻塞I/O操作</td>
</tr>
</tbody>
</table>

##### 阻塞与非阻塞I/O
* 阻塞I/O指当线程在调用读或写操作时，线程会被阻塞。Java I/O的各种流都是阻塞的。
* 非阻塞I/O是不需要等待完成数据的写入或读取，NIO是允许线程在请求向通道写入数据时不等待它完成继续做其他事

##### 面向流与面向缓冲
* 面向流指I/O操作需要从流中读取一个或多个字节，这样的方式效率很低。
![面向流](https://www.yiibai.com/uploads/images/201709/2809/851080928_53643.png)
* 面向缓冲指I/O是在缓冲器中进行读写，使用通道进行进一步的数据处理。

* 区别
  * 流可以用于单向数据传输
  * 通道提供双向数据传输

![面向缓冲](https://www.yiibai.com/uploads/images/201709/2809/885080931_71346.png)

##### 通道(Channels)
通道是在实体和字节缓冲区之间有效传输数据的媒介。通常通道与操作系统文件描述符具有一对一关系，用于提供平台独立操作功能。

##### 选择器(Selectors)
选择器是可选择通道的多路复用器，可用作可以进入非阻塞模式的特殊类型的通道。它可以使单线程处理多个通道。

#### Java NIO通道
NIO Channels 类的层次结构：
![通道类层次结构](https://www.yiibai.com/uploads/images/201709/2809/827080947_43814.png)
上述类中有阻塞与非阻塞，NIO主要关注于非阻塞类

在Java NIO中，主要使用的通道：
* FileChannel: 文件通道，用于文件读取数据。它只通过调用``getChannel()``方法来创建对象。**不能直接创建``FileChannel``对象**
  * ```java
    FileInputStream fis = new FileInputStream("/home/ahogek/file-read.txt");
    ReadableByteChannel rbc = fis.getChannel();
    ```
* DatagramChannel: 数据报通道可以通过UDP通过网络读取和写入数据。它使用工厂方法来创建新对象。下面是打开和关闭该通道的方法
  * ```java
    DatagramChannel ch = DatagramChannel.open();
    DatagramChannel ch = DatagramChannel.close();
    ```
* SocketChannel: TCP数据报通道，使用工厂方法创建
  * ```java
    SocketChannel ch = SocketChannel.open();
    ch.connect(new InetSocketAddress("somehost", someport));
    SocketChannel ch = SocketChannel.close();
    ```
* ServerSocketChannel: 允许用户监听传入的TCP连接，与Web服务器相同。对于每个传入的连接，都会为连接创建一个SocketChannel
  * ```java
    ServerSocketChannel ch = ServerSocketChannel.open();
    ch.socket().bind(new InetSocketAddress(somelocalport));
    ServerSocketChannel ch = ServerSocketChannel.close();
    ```

FileChannel的简单应用

```java
public class ChannelDemo {

	public static void main(String[] args) {
		String relativelyPath = System.getProperty("user.dir");
		try {
			FileInputStream fis = new FileInputStream(relativelyPath + "/testin.txt");
			ReadableByteChannel rbc = fis.getChannel();
			FileOutputStream fos = new FileOutputStream(relativelyPath + "/testout.txt");
			WritableByteChannel wbc = fos.getChannel();
			copyData(rbc, wbc);
			rbc.close();
			wbc.close();
			fis.close();
			fos.close();
			System.out.println("Copy Data finished.");
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static void copyData(ReadableByteChannel rbc, WritableByteChannel wbc) {
		ByteBuffer bb = ByteBuffer.allocate(20 * 1024);
		try {
			while (rbc.read(bb) != -1) {
				bb.flip();
				while (bb.hasRemaining()) {
					wbc.write(bb);
				}
				bb.clear();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

#### Java NIO缓冲区
> NIO缓冲区(Buffers)定义了所有缓冲区的通用核心功能：限制，容量和当前位置。NIO缓冲区用于与NIO通道进行交互。

Java NIO缓冲区是写入数据的内存块，以便在稍后再次进行读取，内存块用NIO缓冲对象包装，这样可以提供更简单的方法来处理内存块

![buffer](https://www.yiibai.com/uploads/images/201709/2809/124090952_19645.png)



*ByteBuffer的基本使用*
```java
public class BufferTest {
	@Test
	public void bufferTest() {
		// Allocate a new byte buffer
		ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
		System.out.println(byteBuffer.position());
		System.out.println(byteBuffer.limit());
		System.out.println(byteBuffer.capacity());
		System.out.println("++++++++++++++++++++++++++++");
		byteBuffer.put("First Data in byte buffer.".getBytes());
		System.out.println(byteBuffer.position());
		System.out.println(byteBuffer.limit());
		System.out.println(byteBuffer.capacity());
		System.out.println("++++++++++++++++++++++++++++");
		byteBuffer.flip();
		System.out.println(byteBuffer.position());
		System.out.println(byteBuffer.limit());
		System.out.println(byteBuffer.capacity());
		System.out.println("++++++++++++++++++++++++++++");
		byte[] data = new byte[byteBuffer.limit()];
		byteBuffer.get(data);
		System.out.println(new String(data, 0, data.length));
		System.out.println(byteBuffer.position());
		System.out.println(byteBuffer.limit());
		System.out.println(byteBuffer.capacity());
		System.out.println("++++++++++++++++++++++++++++");
		byteBuffer.rewind();
		System.out.println(byteBuffer.position());
		System.out.println(byteBuffer.limit());
		System.out.println(byteBuffer.capacity());
		System.out.println("++++++++++++++++++++++++++++");
		byteBuffer.clear();
		System.out.println(byteBuffer.position());
		System.out.println(byteBuffer.limit());
		System.out.println(byteBuffer.capacity());
	}
}
```

ByteBuffer的*mark*和*reset*方法的使用

```java
public class MarkAndReset {

	public static void main(String[] args) {
		ByteBuffer bb = ByteBuffer.allocate(10);
		String str = "AhogeK";
		bb.put(str.getBytes());
		bb.flip();
		byte[] data = new byte[bb.limit()];
		bb.get(data);
		System.out.println(new String(data, 0, data.length));
		bb.flip();
		System.out.println(bb.position());
		System.out.println(bb.limit());
		data = new byte[bb.limit()];
		bb.get(data, 0, 2);
		bb.mark();
		System.out.println(new String(data, 0, 2));
		System.out.println(bb.position());
		bb.get(data, 0, 2);
		System.out.println(new String(data, 0, 2));
		System.out.println(bb.position());
		bb.reset();
		bb.get(data, 0, 2);
		System.out.println(new String(data, 0, 2));
		System.out.println(bb.position());
	}
}
```

##### 直接缓冲区与非直接缓冲区的区别
非直接缓冲区：通过``allocate()``方法分配缓冲区，将缓冲区建立在JVM的内存中

直接缓冲区：通过``allocateDirect()``方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率

一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配他们。

示例：
```java
public class DirectOrNot {

	@Test
	public void directTest() {
		long start = System.currentTimeMillis();
		try {
			FileChannel inChannel = FileChannel.open(
					Paths.get(System.getProperty("user.dir") + "/testin.txt"), StandardOpenOption.READ);
			FileChannel outChannel = FileChannel.open(Paths.get(
					System.getProperty("user.dir") + "/testout.txt"), 
					StandardOpenOption.WRITE, StandardOpenOption.READ);
			MappedByteBuffer inMbb = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size());
			MappedByteBuffer outMbb = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size());
			// read and write directly with memory.
			byte[] data = new byte[inMbb.limit()];
			inMbb.get(data);
			outMbb.put(data);
			inChannel.close();
			outChannel.close();
			long end = System.currentTimeMillis();
			System.out.println("end - start = " + (end - start));
		} catch (IOException e) { 
			e.printStackTrace();
		}
	}
	
	@Test
	public void notDirect() {
		long start = System.currentTimeMillis();
		try {
			FileInputStream fis = new FileInputStream(System.getProperty("user.dir") + "/testin.txt");
			FileOutputStream fos = new FileOutputStream(System.getProperty("user.dir") + "/testout.txt");
			FileChannel inFc = fis.getChannel();
			FileChannel outFc = fos.getChannel();
			ByteBuffer bb = ByteBuffer.allocate(1024);
			while (inFc.read(bb) != -1) {
				bb.flip();
				outFc.write(bb);
				bb.clear();
			}
			inFc.close();
			outFc.close();
			fis.close();
			fos.close();
			long end = System.currentTimeMillis();
			System.out.println("end - start = " + (end - start));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

代码中 ``FileChannel``的``map()``函数是内存映射文件

提到内存映射文件，这里可以说下它的前生，IO包中的``RandomAccessFile``，它是用来访问那些保存数据记录的文件的，你就可以用seek( )方法来访问记录，并进行读写了。

#### Java NIO分散/聚集或向量I/O
> 这是一个简单但功能强大的技术，它可以使用单个``write()``函数将字节从一组缓冲区写入流，并且可以使用单个``read()``函数将字节从流读取到一组缓冲区中。

##### 分散读取
分散读取是将数据从单个通道读取多个缓冲区中的数据

##### 聚集写入
聚集写入是将数据从多个缓冲区写入单个通道

示例：

```java
public class ScatterGatherIO {
	public static void main(String[] args) {
		String data = "This is a demo for scatter and gater I/O";
		gatherBytes(data);
		scatterBytes();
	}

	private static void scatterBytes() {
		String relativelyPath = System.getProperty("user.dir");
		// The first buffer is used for holding a random number
		ByteBuffer bb1 = ByteBuffer.allocate(8);
		// The second buffer is used for holding a data that we want to write
		ByteBuffer bb2 = ByteBuffer.allocate(400);
		ScatteringByteChannel sbc = createChannelInstance(relativelyPath + "/testout.txt", false);
		// Reading a data from the channel
		try {
			sbc.read(new ByteBuffer[] {bb1, bb2});
		} catch (IOException e) {
			e.printStackTrace();
		}
		// Read the two buffers separately
		bb1.rewind();
		bb2.rewind();
		
		int bufferOne = bb1.asIntBuffer().get();
		String bufferTwo = bb2.asCharBuffer().toString();
		// Verification of content
		System.out.println(bufferOne);
		System.out.println(bufferTwo);
	}

	private static void gatherBytes(String data) {
		String relativelyPath = System.getProperty("user.dir");
		// The first buffer is used for holding a random number
		ByteBuffer bb1 = ByteBuffer.allocate(8);
		// The second buffer is used for holding a data that we want to write
		ByteBuffer bb2 = ByteBuffer.allocate(400);
		bb1.asIntBuffer().put(420);
		bb2.asCharBuffer().put(data);
		GatheringByteChannel gbc = createChannelInstance(relativelyPath+"/testout.txt", true);
		// Write the data into file
		try {
			gbc.write(new ByteBuffer[] {bb1, bb2});
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static FileChannel createChannelInstance(String file, boolean isOutput) {
		FileChannel fc = null;
		try {
			if (isOutput) {
				fc = new FileOutputStream(file).getChannel();
			} else {
				fc = new FileInputStream(file).getChannel();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return fc;
	}
}
```

#### 字符集 Charset
* 编码： 字符串 -> 字节数组
* 解码： 字节数组 -> 字符串

```java
public class CharsetTest {

	public static void main(String[] args) {
		// get a char-set object for the named char-set(UTF-8).
		Charset c1 = Charset.forName("UTF8");
		CharsetEncoder ce = c1.newEncoder();
		CharsetDecoder cd = c1.newDecoder();
		CharBuffer cb = CharBuffer.allocate(1024);
		cb.put("This is String data put to the char buffer");
		cb.flip();
		try {
			ByteBuffer bb = ce.encode(cb);
			System.out.println(bb.capacity());
			System.out.println(bb.limit());
			for (int i = 0; i < bb.limit(); i++) {
				System.out.print(bb.get() + " ");
				System.out.println();
			}
			bb.flip();
			CharBuffer decode = cd.decode(bb);
			System.out.println(decode.toString());
			System.out.println("----------------------------------");
			Charset gbk = Charset.forName("GBK");
			CharsetDecoder gbkDecoder = gbk.newDecoder();
			bb.flip();
			CharBuffer gbkDUtf = gbkDecoder.decode(bb);
			System.out.println(gbkDUtf.toString());
		} catch (CharacterCodingException e) {
			e.printStackTrace();
		}
	}
}
```

---
【参考相关文章阅读】
1. *[Java NIO教程](https://www.yiibai.com/java_nio/)*
2. *[Java RandomAccessFile用法](https://blog.csdn.net/akon_vm/article/details/7429245)*