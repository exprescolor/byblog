---
layout:     post
title:      C语言练习题
subtitle:   C
date:       2024-05-17
author:     zhengyu
header-img: img/program.png
catalog: true
tags:
    - program
---

# 5/17号

## 1、主函数main也有参数：int main(int argc,char **argv)

## 2、下面关于delete描述错误的是（）

> A 他必须用于new返回的指针 <br>
> B 使用他删除对象时要调用[析构函数](#析构函数) <br>
> C 对一个指针可以使用多次该运算符 <br>
> D 指针名前只有一对方括号符号，不管所删除数组的维数
```text
答案：C，不能对一个指针进行多次delete，对一个指针delete之后，它所指向的那片内存已经被回收，可能会分配用于其他数据，如果再次delete则会导致数据丢失。
delete用于释放new的创建的内存，delete[] 用于释放new创建的数组内存。
使用delete释放的对象内存时会调用对象的（隐士调用）析构函数。
```

## 4、在32位平台上

```
struct {
	unsigned char a;
    int b;
    short c
} s;
```

请问s的起始地址下面说法正确的是（）

> 答案：四字节对齐

```
struct STUDENT
{
    char a;
    char b;
    char c;
    char d;
    char e;
    int f;
}data;
```



![image-20240517205651429](/img/字节对齐.png)

## 5、在64位机器上sizeof(a) sizeof(b)大小分别是（）

```
char a[10];
char *b = (char*)malloc(10*sizeof(char));
```

> 答案： 64位系统中，指针占8个字节，32位系统中，指针占4个字节。 
>
>   a是一个字符数组，大小为10*sizeof(char)，占10字节。

## 6、下列运算符中优先级最高的是（ ）

> A <  
>
> B +  
>
> C &&
>
> D !=

> 答案：B
> <是6级, +是4级, &&是11级, !=是7级 所以加号的优先级最高。
>
> ！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符
>
> 算术运算符： +  -  *  /  %  ^  ！ ···
> 关系运算符(6个)： ==  !=  >  >=  <  <=
> 赋值运算符： =  +=  -=  *=  /=  %= ···
> 逻辑运算符：&&  ||
>
> 淡云一笔，鞍落三服 
>
> (单目)(算术)(移位)(比较),(按位)(逻辑)(三目)(赋值) 
>
> 后缀自增（`++`）和后缀自减（`--`）运算符的优先级高于前缀自增（`++`）、前缀自减（`--`）、解引用（`*`）、取地址（`&`）、取负（`-`）、取反（`~`）等运算符。 

| 优先级 | 运算符                              | 结合性   | 名称 |
| ------ | ----------------------------------- | -------- | ---- |
| 1      | `() [] -> .`                        | 从左到右 |      |
| 2      | `++ -- + - ! ~ & * (type) sizeof`   | 从右到左 |      |
| 3      | `* / %`                             | 从左到右 |      |
| 4      | `+ -`                               | 从左到右 |      |
| 5      | `<< >>`                             | 从左到右 |      |
| 6      | `< <= > >=`                         | 从左到右 |      |
| 7      | `== !=`                             | 从左到右 |      |
| 8      | `&`                                 | 从左到右 |      |
| 9      | `^`                                 | 从左到右 |      |
| 10     | `|`                                 | 从左到右 |      |
| 11     | `&&`                                | 从左到右 |      |
| 12     | `||`                                | 从左到右 |      |
| 13     | `? :`                               | 从右到左 |      |
| 14     | `= += -= *= /= %= <<= >>= &= ^= |=` | 从右到左 |      |
| 15     | `,`                                 | 从左到右 |      |

![img](https://uploadfiles.nowcoder.com/images/20200824/243827773_1598264387617_EF60E972A84D8C08A55321DDC816FCD8) 



## 7、以下程序的运行结果是（）

```
#include <stdio.h> 
int main() { 
    int sum, pad,pAd; 
    sum = pad = 5; 
    pAd = ++sum, pAd++, ++pad; 
    printf("%d\n",pAd); 
}
```

> A 5  
>
> B 6
>
> C 7
>
> D 8

> 答案：C ，根据优先级计算，由于赋值表达式优先级高于逗号，所以第五行代码等价于
>
> (pAd = ++sum), pAd++, ++pad;
>
> 因此是7

## 9、在下列C代码中：如果指向非空树的根的指针作为参数传递，则DoSomething函数的返回值是（）

```
struct Celode
{
  struct Celode *lchild;
  int element;
  struct Celode *rChild;
}
  
int DoSomething(struct Celode *ptr)
{
    int value = 0;
    if (ptr != NULL)
    {
      if (ptr -> lChild != NULL)
        value = 1 + DoSomething(ptr -> lChild);
      if (ptr -> rChild != NULL)
        value = max(value, 1 + DoSomething(ptr -> rChild));
    }
    return (value);
}
```

> A 树的叶节点数
>
> B 树的节点数
>
> C 树的内部节点数
>
> D 树的高度



> 分析：如果是树的节点树就应该是加，而不是判断max，因此直接得到答案D



# 5/18号

## 1、对于C/C++语言的函数，下列叙述中正确的是（ ）

> A  函数的定义不能嵌套，但是函数调用可以嵌套
>
> B  函数的定义可以嵌套，但函数调用不能嵌套
>
> C  函数的定义和调用都不能嵌套
>
> D  函数的定义和调用都可以嵌套

> 答案：A C语言中函数定义不能嵌套，但是函数调用可以嵌套

## 2、以下程序的输出结果是（）

```
int main() {
    char ch[3][5]={"AAAA","BBB","CC"};
    printf("\"%s\"\n",ch[1]);
}
```

>A   "AAAA"
>B   "BBB"
>C   "BBBCC"
>D   "CC"

> 答案：B 
>
> 解析：ch[0]，ch[1]，ch[2]这种都是列指针（一维指针），而ch，ch+1，ch+2是行指针（数组指针），所以题目中ch[1]表示指向第二行首元素的列指针；

## 4、以下正确的函数定义形式是（）

> A double fun(int x,int y)
> B double fun (int x;int y)
> C double fun (int x,inty)；
> D double fun (intx,y)；

> 答案：A
>
> 解析：函数定义时每个形参都必须指明数据类型符，形参之间必须以逗号隔开，所
>
> 以B和D是错误的，另外，函数定义时末尾不能带分号，只有函数说明时才带分号，所以
>
> C也是错误的。故正确答案是A。

## 5、对于以下代码，char* p=new char[100];说法正确的是（）

> A p和new出来的内存都在栈上
> B p和new出来的内存都在堆上
> C p在堆上，new出来的在栈上
> D p在栈上，new出来的在堆上

> [内存布局](#内存布局)
>
> 答案：D
>
> 解析：new 出来的对象放在堆中，局部变量放在栈中。

## 6、m++ 和 ++m的区别

## 8、有以下程序，输出结果是：

```
#include <stdio. h>
int fun( int a )
{
    int b = 0;
    static int c = 3;
    a = ( c + +,b + + );
    return ( a );
}
main( )
{
    int a = 2,i,k;
    for( i = 0;i<2;i + + )
        k = fun( a + + );
    printf("%d\n",k );
}
```

> A 4
> B 0
> C 1
> D 2

> 答案：B
>
> 解析：这个题目主要分析第六行代码，由于逗号是最低优先级运算符，如果没有括号的话，    
>
> a1=(表达式1,表达式2);           a2=表达式1,表达式2;    
>
> a1是表达式2的结果，而a2是表达式1的结果
>
> 对于函数内的c来说是一个[局部静态变量](#局部静态变量)



## 9、下面程序运行结果是3，5 轻微横线处选择合适的代码

![image-20240518180146080](/img/5_18_ninth.png)

> A p++ ->n
> B (++p) ->n
> C (a+1) ->n
> D (p+1) ->n

> 答案：BCD
>
> 解析：BCD可以输出3，5 A. p++ ->n相当于p->n; p++ ，所以输出的是3，3 B.（++p）->n，p现在指向的是a数组的第二个元素，即{ 5, "def"}这个结构体元素，会输出3， 5 C.（a + 1）->n，a + 1是{ 5, "def" }元素的地址，所以会输出3,，5 D.（p + 1）->n，p + 1是增加的偏移量，即第二个元素的地址，会输出3，5

## 10.下面哪些运算符不能被重载（）

> A 三目运算符“?:”
> B 作用域运算符“::”
> C 对象成员运算符“.”
> D 指针成员运算符“->”

> 答案：ABC
>
> 解析：  不能被重载的运算符只有五个，分别是 
>
>     1.  .  （成员访问运算符） 
>     2.  *（成员指针访问运算符） 
>     3.  ::  （域运算符） 
>     4.  sizeof  （长度运算符） 
>   5. ?:    （条件运算符）
>
>  前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。



# 5/19号



## 1、下面代码段的输出为（）

```
int a = 5, b = -5;
printf("%d,%d", a%(-4), b%(-4));
```

> A  1,-1
> B  1,1
> C  -1,1
> D  -1,-1

> 答案：A
>
> 解析：对于除法/来说，（-m)/n 和 m/(-n) 等于-(m/n) 
>
> 但是对于取余%来说，(-m)%n = -(m % n)
>
> m % (-n) = m%n

## 2、一个 C 语言程序是由（）

> A 一个主程序和若干子程序组成
> B 函数组成
> C 若干过程组成
> D 若干子程序组成

> 答案：B
>
> 解析：函数是C程序的基本单位，一个C语言源程序是由一个main函数和若干其他函数组成的

## 3、运行下面这段C语言程序之后，输出在屏幕上的结果是：

```
#include<stdio.h>
void foobar(int a, int *b, int **c)
{
    int *p = &a;
    *p = 101;
    *c = b;
    b = p;
}
 
int main()
{
    int a = 1;
    int b = 2;
    int c = 3;
    int *p = &c;
    foobar(a, &b, &p);
    printf("a=%d, b=%d, c=%d, *p=%d\n", a, b, c, *p);
    return (0);
}
```

> A a=1, b=2, c=3, *p=2
> B a=101, b=2, c=3, *p=2
> C a=101, b=101, c=2, *p=3
> D a=1, b=101, c=2, *p=3

> 答案：A
>
> 分析：首先对于a来说，在foobar中是以值的形式传递的，因此无论怎么修改都不会影响main函数中的值，所以a=1不会变
>
> 函数中b传递的是主函数中b的指针，语句b = p, 其中p指向的是函数foobar内局部变量a 的地址，让传递过去的指针换了指向的数据，原来函数中的b不会由影响，如果修改为*b = *p,则原函数中的b会变化
>
> 对于c来说，他是将指向c的一个指针的地址传入，*c = b，也就是让主函数中的p指针指向了主函数中的b的地址
>
> 

## 4、对于 32 位机器，则下面代码输出结果为（）

```
#include<iostream>
#include<string>
 
using namespace std;
 
typedef struct data_ {
    int a[10];
} data_t;
 
typedef struct descriptor_ {
    data_t* ptr;
    char data[0];
} desc_t;
 
int main() {
    cout << sizeof(desc_t) << endl;
    return 0;
}
```

> A 40
> B 4
> C8 
> D 0

> 答案：B
>
> 解析：首先就是对于一个32为系统指针是4字节，64位操作系统指针是8字节，然后是char data[0]是一个柔性数组，它默认不占用内存，用来指示数组可以在运行时动态分配内存。
>
> 此外对于64位操作系统大部分int也都是四字节



## 5、下列程序的功能是将 s 中的字符串按长度由小到大排列，请为横线处选择合适的程序（）

```c
#include <stdio.h>
#include <string.h>
 
void f(char *p[], int n) {
    char *t;
    int i, j;
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (strlen(*(p + i)) > strlen(*(p + j))) {
                t = *(p + i);
                *(p + i) = *(p + j);
                *(p + j) = t;
            }
}
 
int main() {
    char *s[] = {"abc", "abcdef", "abbd"};
    f(s, 3);
    for (int i = 0; i < 3; i++)
        printf("%s\n", ____);
    return 0;
}
```

> A  s+i
> B  s[i]
> C  *s[i]
> D  &s[i]

> 答案：B
>
> 解析：对于s + i来说，s是一个char \*\*类型的指针,所以在他运算结束后还是char \*\*类型
>
> 对于s[i]来说，是一个指向字符的指针类型 (char*)，因此用来输出%s的结果
>
> 对于\*s[i]直接就是该字符串，
>
> &s[i]和第一个结果一致

## 6、若变量a, i已正确定义，且i已正确赋值，合法的语句是（ ）

> A a = int(i);
> B a == 1
> C ++i;
> D a = a++ = 5;

> 答案：C
>
> 解析：首先是题目，i已经正确赋值，则可以进行++操作，对于D来说，a没有正确赋值，也无法作比较，
>
> 对于答案A来说，强制类型转换是（int）i；

## 7、2022 迅雷 C++，现在有以下语句： 则执行后，变量sz的值将得到

```C
struct _THUNDER{ 
  int iVersion; 
  char cTag; 
  char cAdv; 
  int iUser; 
  char cEnd; 
  }Thunder; 
  int sz=sizeof(Thunder); 
  
```

> A 11
> B 12
> C 13
> D 16

> 答案：16 [sizeof](#sizeof)
>
> 解析： 结构体成员按照定义时的顺序依次存储在连续的内存空间，但是结构体的大小并不是简单的把所有成员大小相加，而是遵循一定的规则，需要考虑到系统在存储结构体变量时的地址对齐问题。
>
> 1、 没有成员的结构体占用的空间是多少个字节？ 答：1字节，确保每个实例都有一个唯一的地址。
>
> 2、在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：
>
> ​       （1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 
>
> ​	   （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 

## 8、2022 腾讯 C++ 假设MyClass为一个类，则执行“MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是？

> A 2
> B 4
> C 5
> D 9

> 正确答案：C
>
> 解析：MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。

## 9、2021 海康威视 Makefile下面哪个初始化是非法的（按照顺序）

```
A int i = 1
B const int ic = i
C const int *pic = &ic
D int*const cpi = &ic
```

> 答案：D
>
> 解析：A变量i初始化正确，接着使用ic为整型常量，在运行时由i赋值，随后(const int )\* =&(const int)
>
> 但是对于D来说，(int *  const)= &(const int)因此是错误的
>
> 

## 10、2022 迅雷 C++有如下程序段：请问运行Test函数结果是：

```
  voidGetMemeory(char*p) 
  { 
  p=(char*)malloc(100); 
  ｝ 
  voidtest() 
  { 
  char *str=NULL; 
  GetMemory(str); 
  strcpy(str,”Thunder”); 
  strcat(str+2,“Downloader”); 
  printf(str); 
  }
```

> A ThunderDownloader
> B underDownloader
> C Thunderownloader
> D 程序崩溃

> 答案：D
>
> 解析：由于str一开始为Null，而在函数中申请的内存空间随着该函数运行结束，则分配的内存空间也被释放掉，因此str指针指向的还是空，所以后续进行strcpy操作会报错。





# 5/20号

## 1、2022 迅雷 C++ 下列for循环的循环体执行次数为

```
for(int i=10, j=1; i=j=0; i++, j--)
```

> A 0
>
> B 1
>
> C 无限
>
> D 其他选项都不对

>  答案: A
>
> 解析：对于i=j=0;这个表达式最后返回的结果是0，根据 C 语言的运算符优先级和结合性，表达式 `i = j = 0` 会从右向左进行计算。 
>
> - `j = 0` 将 `j` 设置为 0，并且表达式 `j = 0` 的值也是 0。
> - `i = 0` 将 `i` 设置为 0，并且表达式 `i = 0` 的值也是 0。
> - 因此，条件部分 `i = j = 0` 的最终值是 0。 

## 2、2022 迅雷 C++ a,b均为不等于0的整形变量，以下关系式恒成立的是：

> A a\*b/a\*b==1
>
> B a/b*b/a==1
>
> C a/b*b+a%b==a
>
> D a/b*b==a

> 正确答案：C
>
> 你的答案：A   你得按着乘法规则来，把题目看完
>
> 对于C来说，除以一个一个数之后再加上对这个数的余数就是原来的值



## 3、以下属于main函数参数的是

> A argc
>
> B envp
>
> C main
>
> D argv

> main函数有三个参数，argc、argv和envp，它的标准写法如下：
> int main(int argc,char *argv[],char *envp[])
> ** int argc，存放了命令行参数的个数。
> char argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。
> char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。 



## 4、设：char w; int x; float y; double z; 则表达式: w*x+z-y 值的数据类型是（） 

```
A float
B double
C int
D char
```

> 答案：B
>
> 解析: 低级向高级转化。 若要高精度向低精度转化则需要进行强制转换（int）i



## 5、以下代码编译有错误，哪个选项能解决编译错误？ 

```
class A {
    public:
        int GetValue() const {
            vv = 1;
            return vv;
         }
    private:
        int vv;
};
```

> A 改变成员变量"vv"为"mutable int vv"
>
> B 改变成员函数"GetValue"的声明，以使其不是const的
>
> C 都不能修复编译错误
>
> D 都可以修复编译错误

> 答案： D
>
> 解析：对于这个题目考的是[常函数](#常函数)和mutable关键字，普通成员函数后面加上 const 修饰，就是常函数。 
>
> 常函数中的 this 指针是常指针，不能在常函数中对成员变量进行修改，只能读取； 如果想要在常函数中对成员变量进行修改，可以在成员变量前加上 mutable 关键字进行修饰；
> 常函数可以被普通对象或者常对象调用，但是常对象只能调用常函数，常对象只能读成员。 

## 6、求函数返回值，输入x=9999

```
int func(int x){
    int count = 0;
    while (x){
        count++;
        x = x&(x - 1);//与运算
    }
    return count;
}
```

> A 8
>
> B 9
>
> C 10
>
> D 12

> 答案：A
>
> 解析：对于 &(与运算) ^（异或运算）|（或运算）他们是如何计算的，
>
> 假设A=60， B=13,以二进制形式表示结果为：
>
> A = 0011 1100    B = 0000 1101 
>
> A&B = 0000 1100
>
> A | B = 0011 1101
>
> A ^ B = 0011 0001  
>
> - **基本性质**：相同为 0，不同为 1，与自身异或为 0，与 0 异或为自身。
>
> 对于这个题目总结规律，一个数与他的减一的数相与，则他的结果为他的二进制数的表现形式中最右侧的1变为0，对于9999的二进制为10011100001111一共八个1，则可运算八次

## 7、函数作用：将整型数组p中n个数据增大，以下代码的实现有错误，下面哪句话的表述是正确的？ 

```
void increment_ints (int p [ ], int n)
{
  assert(p != NULL);  /* 确保p不为空指针 */
  assert(n >= 0);  /* 确保n不为负数 */
  while (n)  /* 循环n次. */
  {
    *p++;          /* 增大p*/
    p++, n--;      /* p指向下一位，n减1 */
  }
}
```

> A \*p++应该改为(\*p)++
>
> B 数组的值是一个不能改变的值，所以p不能直接被修改。应该使用一个和p相关联的指针来完成这个操作。
>
> C while循环的条件必须是一个布尔类型的表达式，表达式应该为n!=0.
>
> D p不应该定义为变长的数组，参数中不应该包含参数n。

> 答案：A
>
> 解析：首先还是优先级的问题，后缀++和--的优先级高于前缀++和--，然后高于解引用\*,所以对于第八行代码，应该是*（p++ ）, 对于B选项，来说，数组作为参数传递的时候可以使用形参名进行增加

## 8、假设在上下文和头文件正常的情况以下，下面程序的结果是什么（） 

```
char* f(char *str, char ch) {
    char *it1 = str;
    char *it2 = str;
    while (*it2 != '\0') {
        while (*it2 == ch) { it2++; }
        *it1++ = *it2++;
     }
    return str;
}
int main(int argc, char *argv[]) {
    char *a = new char[10];
    strcpy(a, "abcdcccd");
    cout << f(a, 'c');
}
```

> A abdcccd
>
> B abdd
>
> C abcc
>
> D abddcccd

> 答案：D
>
> 仔细阅读代码

## 9、若有以下说明和定义语句： 考虑内存对齐，则变量aa所占内存的字节数是（    

```
union uti {
    int n;
    double g;
    char ch[9];
} 
struct srt {
    float xy;
    union uti uv;
} aa;
```

> A 9
>
> B 8
>
> C 24
>
> D 13

> 答案：C
>
> 解析：为了确定union的大小，我们对齐的时候应该参照内部的数据类型的最大对齐字节，但是在实际计算的时候又要考虑char ch[9]，所以他的实际大小是16字节，但是对齐是八字节。
>
> 对齐和该结构体的大小是两个概念



## 5/21号

## 1、有如下程序段： 则对函数fun的调用语句正确的是 

```C
char fun(char *);
main() { char *s = "one", a[5] = {0}, (*f1)(char *) = fun, ch; }
```

> A  *f1(&a);
>
> B  f1（*s）;
>
> C  f1(&ch);
>
> D  ch = *f1(s);要改成（*f1）(s)才正确

> 答案：CD
>
> 解析：对于A来说，应该是(\*f1)(&a[0])
>
> B: f1(s)  其实也不太对，s应该是const char \*
>
> 对于函数指针来说，使用该函数指针的方法只能为p()和(*p)() 



## 2、T是一个数据类型，关于std::vector::at 和 std::vector::operator[] 描述正确的是：

> A  at总是做边界检查， operator[] 不做边界检查.
>
> B  at 不做边界检查， operator[] 做边界检查.
>
> C  at和operator[] 是一样的

> 答案：A
>
> 解析：访问vector中的数据时，使用两种方法来访问。 
>
> 1、  vector::at()    //主要推荐使用，因为at()进行了边界检查 ，如果索引越界 `std::out_of_range` 异常 
> 2、  vector::operator[]  //为了与C语言兼容 
>
> - `vector::at()`：由于包含边界检查，访问速度相对较慢。
> - `vector::operator[]`：没有边界检查，访问速度更快。
> - `vector::at()`：进行边界检查，如果索引越界会抛出 `std::out_of_range` 异常。
> - `vector::operator[]`：不进行边界检查，如果索引越界，行为未定义。

## 3、编译错误和运行时错误：

在 C++ 中，如果分母为 0，则会发生运行时错误 ,上述代码中的 `try-catch` 块并不会捕获到除以零的错误，因为这是一个未定义行为，不是 C++ 标准库抛出的异常。 

对于浮点数除以零，根据 IEEE 754 标准，结果是无穷大（`INF`）或负无穷大（`-INF`），不会抛出异常。以下是一个示例 



## 4、以下叙述中正确的是（） 

> A  结构体数组名不能作为实参传给函数
>
> B 结构体变量的地址不能作为实参传给函数
>
> C 结构体中可以含有指向本结构体的指针成员
>
> D 即使是同类型的结构体变量，也不能进行整体赋值

> 答案：C
>
> 解析：对于D来说，类型相同的结构体变量，可以进行整体赋值



## 5、32位系统下，对于下面的结构体A和B，sizeof（A），sizeof（B）的结果分别是（） 

> 主要时对于#pragma pack(``2``)代码的理解，当设置这个之后，设置结构体对齐方式为2字节
>
> 当#pragma pack()  回复默认对齐方式
>
> 答案为：8,12 

```
#include <stdio.h>
#pragma pack(2)
struct A
{
   int a;
   char b;
   short c;
};
#pragma pack()
#pragma pack(4)
struct B
{
   char b;
   int a;
   short c;
};
#pragma pack()
int main()
{
   printf(“sizeof(A)=%d,sizeof(B)=%d\n”,sizeof(A),sizeof(B));
   return 0;
}
```



## 6、下面对一维数组 a 进行正确的初始化的语句是（） 

> A  int a[10] = (0, 0, 0, 0, 0); //注:这里是小括号
>
> B  int a[10] = {};
>
> C  int a[10] = {10};
>
> D  int a[10] = {10, 0, -1};

> 答案：BCD
>
> 对于B选项，这个是正确的直接全部初始化为0

## 7、下面说法中正确的是（） 

> A  若全局变量仅在单个C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度
>
> B  若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度
>
> C  设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题
>
> D  静态全局变量使用过多，可那会导致动态存储区(堆栈)溢出

> 答案：A
>
> 解析：A选项：变量分为全局变量和局部变量，局部变量和形参的作用域是函数内部，全局变量的作用域是整个文件。但是可以通过一个extern的全局变量拓展全局变量的作用域，也可以通过定义一个static的全局变量限制这个拓展
>
> B:如果全局变量仅仅由单个函数访问， 不存在耦合度的问题
>
> C：动态全局变量，静态全局变量，静态局部变量的声明周期都为程序运行期间，其中进行局部变量的生存周期虽然为整个源程序，但是其作用域仍然与局部变量相同，当推出函数时，改变了还存在，但是不能使用 
>
> D: 全局变量和静态变量都是存储在静态存储区，所以在递归调用是不会压栈，也不会造成堆栈溢出。  

## 8、以下函数用法正确的个数是： 

```
void test1(){
    unsigned char array[MAX_CHAR+1],i;
    for(i = 0;i <= MAX_CHAR;i++){
        array[i] = i;
    }
}
char*test2(){
    char p[] = "hello world";
    return p;
}
char *p = test2();
void test3(){
    char str[10];
    str++;
    *str = '0';
}
```

> A 0
>
> B 1
>
> C 2
>
> D 3

> 答案：A
>
> 解析：重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255. 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。 第二个问题： 重点在于函数中p的身份，他是一个指针，还是数组名； 如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。 例子中p是数组名，所以会出错，p所指的地址是随机值。 若是把char p[]="hello";改成char *p="hello";就可以了。 第三个问题： 重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.） 

## 9、声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（ 

> A  (int *p[10])(int*)
>
> B  int [10]*p(int *)
>
> C int (*(*p)[10])(int *)
>
> D int ((int *)[10])*p
>
> E 以上选项都不正确

> 答案：C
>
> 解析：首先顶一个数组指针，int (\*ptr)[10],接着定义一个函数指针int (\*pf)(int \*),接着定义一个元素时函数指针的指针数组，即将这个(\*ptr)[10]作为一个整体代替pf,.

## 10、有如下代码: 

```
struct A1{
    virtual ~A1(){}
};
struct A2{
    virtual ~A2(){}
};
struct B1 : A1, A2{};
int main()
{
 B1 d;
 A1* pb1 = &d;
 A2* pb2 = dynamic_cast<A2*>(pb1);  //L1
 A2* pb22 = static_cast<A2*>(pb1);  //L2
 return 0;
}
```

> A  L1语句编译失败，L2语句编译通过
>
> B  L1语句编译通过，L2语句编译失败
>
> C  L1，L2都编译失败
>
> D  L1，L2都编译通过

> 正确答案：B 
>
> 解析：
>
> - C 风格的类型转换（C-style casting）：使用一对圆括号来实现类型转换，如 `(int)x`。
> - 函数风格的类型转换（Function-style casting）：使用 C++ 的类型转换函数来实现类型转换，如 `int(x)`。
> - `static_cast`：用于执行静态类型转换，具有较强的类型检查。 static_cast<目标类型>(原类型)  目标类型和源类型之间必须一个方向可以自动类型转换，否则就会出现 错误。  
> - `dynamic_cast`：用于执行动态类型转换，通常用于类的多态类型转换。dynamic_cast<目标类型>(原类型)  源类型和目标类型之间必须存在继承关系，否则会出现错误。  
> - `const_cast`：用于移除变量的 `const` 属性或添加 `const` 属性。const_cast<目标类型>(原类型)  源类型和目标类型必须是指针或引用，且间除了const属性外，其它都相同，否则就会出现错误。   
> - `reinterpret_cast`：用于执行底层的指针类型之间的转换，通常用于需要对底层数据进行原始操作时。 reinterpret_cast<目标类型>(原类型)  只能把整数转换成指针或把指针转换成整数，否则就会出现错误。 `reinterpret_cast` 并不仅仅限制于整数和指针之间的转换，它可以执行任意类型之间的转换，但是其使用具有风险，可能导致未定义的行为。 应尽量避免使用。


































































































































# 外链知识（设置一个锚点能够跳转到这个位置）

## <a name="析构函数">析构函数</a>







## <a name="常函数">常函数</a>

常函数（const member function）是成员函数的一种，它承诺不修改对象的状态。常函数在声明和定义时都需要使用 `const` 关键字进行修饰。这样可以确保在常函数内部不会修改任何成员变量。 

使用常函数有几个重要的原因：

1. **保证不修改对象状态**：常函数可以防止无意中修改对象的状态，这有助于保持对象的一致性。
2. **提高代码可读性**：通过将某些函数声明为常函数，程序员可以更明确地表达函数的意图，即这些函数不会修改对象。
3. **允许常对象调用**：只有常函数才能被常对象（const objects）调用。

常对象：const MyClass obj;  // 常对象 

### 重点总结

1. **声明常函数**：在成员函数声明和定义的结尾处加上 `const` 关键字。
2. **常对象**：常对象只能调用常函数，不能调用非常函数。
3. **常函数的限制**：常函数中不能修改类的成员变量，除非它们是 `mutable` 修饰的。

## <a name="内存布局">内存布局</a>

栈（Stack）：由编译器自动管理，用于存放函数的局部变量、函数参数、返回地址等，具有动态特性，内存地址从高地址向低地址增长。
堆（Heap）：由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。 用于动态内存分配，如通过malloc、calloc、realloc函数分配的内存）

数据段（Data Segment）：包括已经初始化的全局变量和静态变量，内存地址固定。

BSS段（BSS(Block Started by Symbol) Segment）：包括未初始化的全局变量和静态变量，在程序开始执行前，这个段会被操作系统清零

代码段（Text Segment）：用于存放程序的可执行指令，内存地址固定



## <a name="局部静态变量">局部静态变量</a>

> 局部静态变量是声明在函数内部，但使用static关键字修饰的变量。它们具有以下特点：
>
> * 存储位置: 尽管他是一个静态变量，但是他和全局变量存储在一个数据段或者BSS段
> * 生命周期：局部静态变量的生命周期是整个程序运行期间。它们在第一次调用定义它们的函数时初始化，并在程序终止时销毁。
> * 作用域：它们的作用域仅限于定义它们的函数。尽管它们的值在函数的多次调用之间保持不变，但它们不能被函数外部的代码直接访问。
>
> 初始化
>
> * 默认初始化：如果局部静态变量没有显式初始化，则会被初始化为零（对于基本数据类型）。
> * 显式初始化：可以在定义局部静态变量时显式地给它们赋初始值。这个初始化只在变量第一次被创建时进行一次。

## <a name="sizeof">sizeof和strlen</a>

| 特点         | `sizeof`                   | `strlen`                   |
| ------------ | -------------------------- | -------------------------- |
| 计算内容     | 数据类型或对象占用的字节数 | 以 `\0` 结尾的字符串的长度 |
| 计算时机     | 编译时                     | 运行时                     |
| 作用范围     | 任何数据类型               | 仅限以 `\0` 结尾的字符串   |
| 包括 `\0` 吗 | 包括（如果是字符数组）     | 不包括                     |



## <a name="指针数组">指针数组和数组指针</a>

### 指针数组

> 指针数组是一个数组，其中每个元素都是一个指针。这个数组可以存储多个指针，通常指向相同类型的数据。 

```
tpye *array[size]
```

```
#include <stdio.h>

int main() {
    int a = 1, b = 2, c = 3;
    int *ptrArray[3]; // 定义一个指针数组，包含3个指向整数的指针

    ptrArray[0] = &a;
    ptrArray[1] = &b;
    ptrArray[2] = &c;

    for (int i = 0; i < 3; i++) {
        printf("Value at ptrArray[%d] = %d\n", i, *ptrArray[i]);
    }

    return 0;
}

```







### 数组指针

> 数组指针是一个指向数组的指针。这意味着指针本身指向一个数组，并且该数组的元素类型和大小是已知的。 

```
type (*pointerName)[size];
```

```
#include <stdio.h>

int main() {
    int array[5] = {1, 2, 3, 4, 5};
    int (*arrayPtr)[5]; // 定义一个指向包含5个整数的数组的指针

    arrayPtr = &array;

    for (int i = 0; i < 5; i++) {
        printf("Value at array[%d] = %d\n", i, (*arrayPtr)[i]);
    }

    return 0;
}

```







## <a name="指针函数">指针函数和函数指针</a>

### 函数指针

> 函数指针是指指向一个函数的指针，可以通过这个指针完成对函数的调用

* 定义

```
type (*func)(parameter_list)
```

```C
#include <stdio.h>

// 定义一个函数
int add(int a, int b) {
    return a + b;
}

int main() {
    // 定义一个函数指针，指向返回int类型并接受两个int参数的函数
    int (*func_ptr)(int, int) = add;

    // 使用函数指针调用函数
    int result = func_ptr(3, 4);

    printf("Result: %d\n", result); // 输出: Result: 7

    return 0;
}

```



### 指针函数

> 指针函数是指一个函数的返回值是一个指针

* 定义

```C
return_type *function_name(parameter_list);
```

```
#include <stdio.h>

// 定义一个返回int指针的函数
int* find_max(int *a, int *b) {
    return (*a > *b) ? a : b;
}

int main() {
    int x = 5;
    int y = 10;

    // 调用指针函数
    int *max = find_max(&x, &y);

    printf("Max value: %d\n", *max); // 输出: Max value: 10

    return 0;
}
```





## <a name="指针常量">指针常量和常量指针</a>

它们的区别主要在于“谁是常量”，即指针本身是常量，还是指针指向的数据是常量。

**常量指针**

* 常量指针是指向常量数据的指针。通过常量指针，不能修改它所指向的对象的值。

* 声明方式：

```
const int *ptr;
int const *ptr;
```



**指针常量（Constant Pointer）**

* 指针常量是指针本身是常量。一旦初始化后，不能改变指针指向的地址，但可以通过指针修改指向的对象的值（前提是指向的对象不是常量）。
* 声明方式

```
int *const ptr;
```





## <a name="string">string.h</a>

### 字符串操作方法：

1、strcpy 和 strncpy

* strcpy 函数用于将源字符串复制到目标字符串中。

```
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "Hello, World!";
    char dest[50];

    strcpy(dest, src);
    printf("Destination: %s\n", dest); // 输出: Destination: Hello, World!

    return 0;
}
//注意：目标数组必须有足够的空间来存储源字符串及其末尾的空字符 \0。
```

* strncpy 函数是 strcpy 的安全版本，允许指定复制的最大字符数。
  * 如果源字符串长度大于指定的字符数，目标字符串不会自动加上空字符，需要手动添加

* strlen 函数用于计算字符串的长度（不包括末尾的空字符 \0）。

* strcmp 和 strncmp   用于比较字符串

* strcat和 strncat  
  * strcat 函数用于将源字符串追加到目标字符串的末尾。
* strchr 和 strrchr
  * strchr 函数用于在字符串中查找第一次出现的指定字符。
  * strrchr最后一次出现的位置
* strstr 查找子字符串第一次出现的位置





































































