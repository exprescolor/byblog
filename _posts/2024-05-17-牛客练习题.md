---
layout:     post
title:      C语言练习题
subtitle:   C
date:       2024-05-17
author:     zhengyu
header-img: img/program.png
catalog: true
tags:
    - program
---

# 5/17号

## 1、主函数main也有参数：int main(int argc,char **argv)

## 2、下面关于delete描述错误的是（）

> A 他必须用于new返回的指针 <br>
> B 使用他删除对象时要调用[析构函数](#析构函数) <br>
> C 对一个指针可以使用多次该运算符 <br>
> D 指针名前只有一对方括号符号，不管所删除数组的维数
```text
答案：C，不能对一个指针进行多次delete，对一个指针delete之后，它所指向的那片内存已经被回收，可能会分配用于其他数据，如果再次delete则会导致数据丢失。
delete用于释放new的创建的内存，delete[] 用于释放new创建的数组内存。
使用delete释放的对象内存时会调用对象的（隐士调用）析构函数。
```

## 4、在32位平台上

```
struct {
	unsigned char a;
    int b;
    short c
} s;
```

请问s的起始地址下面说法正确的是（）

> 答案：四字节对齐

```
struct STUDENT
{
    char a;
    char b;
    char c;
    char d;
    char e;
    int f;
}data;
```



![image-20240517205651429](/img/字节对齐.png)

## 5、在64位机器上sizeof(a) sizeof(b)大小分别是（）

```
char a[10];
char *b = (char*)malloc(10*sizeof(char));
```

> 答案： 64位系统中，指针占8个字节，32位系统中，指针占4个字节。 
>
>   a是一个字符数组，大小为10*sizeof(char)，占10字节。

## 6、下列运算符中优先级最高的是（ ）

> A <  
>
> B +  
>
> C &&
>
> D !=

> 答案：B
>  <是6级, +是4级, &&是11级, !=是7级 所以加号的优先级最高。
>
> ！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符
>
> 算术运算符： +  -  *  /  %  ^  ！ ···
> 关系运算符(6个)： ==  !=  >  >=  <  <=
> 赋值运算符： =  +=  -=  *=  /=  %= ···
> 逻辑运算符：&&  ||
>
>   淡云一笔，鞍落三服 
>
>   (单目)(算术)(移位)(比较),(按位)(逻辑)(三目)(赋值) 

| 优先级 | 运算符                              | 结合性   | 名称 |
| ------ | ----------------------------------- | -------- | ---- |
| 1      | `() [] -> .`                        | 从左到右 |      |
| 2      | `++ -- + - ! ~ & * (type) sizeof`   | 从右到左 |      |
| 3      | `* / %`                             | 从左到右 |      |
| 4      | `+ -`                               | 从左到右 |      |
| 5      | `<< >>`                             | 从左到右 |      |
| 6      | `< <= > >=`                         | 从左到右 |      |
| 7      | `== !=`                             | 从左到右 |      |
| 8      | `&`                                 | 从左到右 |      |
| 9      | `^`                                 | 从左到右 |      |
| 10     | `|`                                 | 从左到右 |      |
| 11     | `&&`                                | 从左到右 |      |
| 12     | `||`                                | 从左到右 |      |
| 13     | `? :`                               | 从右到左 |      |
| 14     | `= += -= *= /= %= <<= >>= &= ^= |=` | 从右到左 |      |
| 15     | `,`                                 | 从左到右 |      |

## 7、以下程序的运行结果是（）

```
#include <stdio.h> 
int main() { 
    int sum, pad,pAd; 
    sum = pad = 5; 
    pAd = ++sum, pAd++, ++pad; 
    printf("%d\n",pAd); 
}
```

> A 5  
>
> B 6
>
> C 7
>
> D 8

> 答案：C ，根据优先级计算，由于赋值表达式优先级高于逗号，所以第五行代码等价于
>
> (pAd = ++sum), pAd++, ++pad;
>
> 因此是7

## 9、在下列C代码中：如果指向非空树的根的指针作为参数传递，则DoSomething函数的返回值是（）

```
struct Celode
{
  struct Celode *lchild;
  int element;
  struct Celode *rChild;
}
  
int DoSomething(struct Celode *ptr)
{
    int value = 0;
    if (ptr != NULL)
    {
      if (ptr -> lChild != NULL)
        value = 1 + DoSomething(ptr -> lChild);
      if (ptr -> rChild != NULL)
        value = max(value, 1 + DoSomething(ptr -> rChild));
    }
    return (value);
}
```

> A 树的叶节点数
>
> B 树的节点数
>
> C 树的内部节点数
>
> D 树的高度



> 分析：如果是树的节点树就应该是加，而不是判断max，因此直接得到答案D



# 5/19号

## 1、对于C/C++语言的函数，下列叙述中正确的是（ ）

> A  函数的定义不能嵌套，但是函数调用可以嵌套
>
> B  函数的定义可以嵌套，但函数调用不能嵌套
>
> C  函数的定义和调用都不能嵌套
>
> D  函数的定义和调用都可以嵌套

> 答案：A C语言中函数定义不能嵌套，但是函数调用可以嵌套

## 2、以下程序的输出结果是（）

```
int main() {
    char ch[3][5]={"AAAA","BBB","CC"};
    printf("\"%s\"\n",ch[1]);
}
```

>A   "AAAA"
>B   "BBB"
>C   "BBBCC"
>D   "CC"

> 答案：B 
>
> 解析：ch[0]，ch[1]，ch[2]这种都是列指针（一维指针），而ch，ch+1，ch+2是行指针（数组指针），所以题目中ch[1]表示指向第二行首元素的列指针；

## 4、以下正确的函数定义形式是（）

> A double fun(int x,int y)
> B double fun (int x;int y)
> C double fun (int x,inty)；
> D double fun (intx,y)；

> 答案：A
>
> 解析：函数定义时每个形参都必须指明数据类型符，形参之间必须以逗号隔开，所
>
> 以B和D是错误的，另外，函数定义时末尾不能带分号，只有函数说明时才带分号，所以
>
> C也是错误的。故正确答案是A。

## 5、对于以下代码，char* p=new char[100];说法正确的是（）

> A p和new出来的内存都在栈上
> B p和new出来的内存都在堆上
> C p在堆上，new出来的在栈上
> D p在栈上，new出来的在堆上

> [内存布局](#内存布局)
>
> 答案：D
>
> 解析：new 出来的对象放在堆中，局部变量放在栈中。

## 6、m++ 和 ++m的区别

## 8、有以下程序，输出结果是：

```
#include <stdio. h>
int fun( int a )
{
    int b = 0;
    static int c = 3;
    a = ( c + +,b + + );
    return ( a );
}
main( )
{
    int a = 2,i,k;
    for( i = 0;i<2;i + + )
        k = fun( a + + );
    printf("%d\n",k );
}
```

> A 4
> B 0
> C 1
> D 2

> 答案：B
>
> 解析：这个题目主要分析第六行代码，由于逗号是最低优先级运算符，如果没有括号的话，    
>
> a1=(表达式1,表达式2);           a2=表达式1,表达式2;    
>
> a1是表达式2的结果，而a2是表达式1的结果
>
> 对于函数内的c来说是一个[局部静态变量](#局部静态变量)



## 9、下面程序运行结果是3，5 轻微横线处选择合适的代码

![image-20240518180146080](/img/5_18_ninth.png)

> A p++ ->n
> B (++p) ->n
> C (a+1) ->n
> D (p+1) ->n

> 答案：BCD
>
> 解析：BCD可以输出3，5 A. p++ ->n相当于p->n; p++ ，所以输出的是3，3 B.（++p）->n，p现在指向的是a数组的第二个元素，即{ 5, "def"}这个结构体元素，会输出3， 5 C.（a + 1）->n，a + 1是{ 5, "def" }元素的地址，所以会输出3,，5 D.（p + 1）->n，p + 1是增加的偏移量，即第二个元素的地址，会输出3，5

## 10.下面哪些运算符不能被重载（）

> A 三目运算符“?:”
> B 作用域运算符“::”
> C 对象成员运算符“.”
> D 指针成员运算符“->”

> 答案：ABC
>
> 解析：  不能被重载的运算符只有五个，分别是 
>
>     1.  .  （成员访问运算符） 
>     2.  *（成员指针访问运算符） 
>     3.  ::  （域运算符） 
>     4.  sizeof  （长度运算符） 
>   5. ?:    （条件运算符）
>
>  前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。




















































# 外链知识（设置一个锚点能够跳转到这个位置）

## <a name="析构函数">析构函数</a>



## <a name="内存布局">内存布局</a>

栈（Stack）：由编译器自动管理，用于存放函数的局部变量、函数参数、返回地址等，具有动态特性，内存地址从高地址向低地址增长。
堆（Heap）：由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。 用于动态内存分配，如通过malloc、calloc、realloc函数分配的内存）

数据段（Data Segment）：包括已经初始化的全局变量和静态变量，内存地址固定。

BSS段（BSS(Block Started by Symbol) Segment）：包括未初始化的全局变量和静态变量，在程序开始执行前，这个段会被操作系统清零

代码段（Text Segment）：用于存放程序的可执行指令，内存地址固定



## <a name="局部静态变量">局部静态变量</a>

> 局部静态变量是声明在函数内部，但使用static关键字修饰的变量。它们具有以下特点：
>
> * 存储位置: 尽管他是一个静态变量，但是他和全局变量存储在一个数据段或者BSS段
> * 生命周期：局部静态变量的生命周期是整个程序运行期间。它们在第一次调用定义它们的函数时初始化，并在程序终止时销毁。
> * 作用域：它们的作用域仅限于定义它们的函数。尽管它们的值在函数的多次调用之间保持不变，但它们不能被函数外部的代码直接访问。
>
> 初始化
>
> * 默认初始化：如果局部静态变量没有显式初始化，则会被初始化为零（对于基本数据类型）。
> * 显式初始化：可以在定义局部静态变量时显式地给它们赋初始值。这个初始化只在变量第一次被创建时进行一次。