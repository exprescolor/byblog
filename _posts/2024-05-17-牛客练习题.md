---
layout:     post
title:      C语言练习题
subtitle:   C
date:       2024-05-17
author:     zhengyu
header-img: img/program.png
catalog: true
tags:
    - program
---

# 5/17号

## 1、主函数main也有参数：int main(int argc,char **argv)

## 2、下面关于delete描述错误的是（）

> A 他必须用于new返回的指针 <br>
> B 使用他删除对象时要调用[析构函数](#析构函数) <br>
> C 对一个指针可以使用多次该运算符 <br>
> D 指针名前只有一对方括号符号，不管所删除数组的维数
```text
答案：C，不能对一个指针进行多次delete，对一个指针delete之后，它所指向的那片内存已经被回收，可能会分配用于其他数据，如果再次delete则会导致数据丢失。
delete用于释放new的创建的内存，delete[] 用于释放new创建的数组内存。
使用delete释放的对象内存时会调用对象的（隐士调用）析构函数。
```

## 4、在32位平台上

```
struct {
	unsigned char a;
    int b;
    short c
} s;
```

请问s的起始地址下面说法正确的是（）

> 答案：四字节对齐

```
struct STUDENT
{
    char a;
    char b;
    char c;
    char d;
    char e;
    int f;
}data;
```



![image-20240517205651429](/img/字节对齐.png)

## 5、在64位机器上sizeof(a) sizeof(b)大小分别是（）

```
char a[10];
char *b = (char*)malloc(10*sizeof(char));
```

> 答案： 64位系统中，指针占8个字节，32位系统中，指针占4个字节。 
>
>   a是一个字符数组，大小为10*sizeof(char)，占10字节。

## 6、下列运算符中优先级最高的是（ ）

> A <  
>
> B +  
>
> C &&
>
> D !=

> 答案：B
>  <是6级, +是4级, &&是11级, !=是7级 所以加号的优先级最高。
>
> ！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符
>
> 算术运算符： +  -  *  /  %  ^  ！ ···
> 关系运算符(6个)： ==  !=  >  >=  <  <=
> 赋值运算符： =  +=  -=  *=  /=  %= ···
> 逻辑运算符：&&  ||
>
>   淡云一笔，鞍落三服 
>
>   (单目)(算术)(移位)(比较),(按位)(逻辑)(三目)(赋值) 

| 优先级 | 运算符                              | 结合性   | 名称 |
| ------ | ----------------------------------- | -------- | ---- |
| 1      | `() [] -> .`                        | 从左到右 |      |
| 2      | `++ -- + - ! ~ & * (type) sizeof`   | 从右到左 |      |
| 3      | `* / %`                             | 从左到右 |      |
| 4      | `+ -`                               | 从左到右 |      |
| 5      | `<< >>`                             | 从左到右 |      |
| 6      | `< <= > >=`                         | 从左到右 |      |
| 7      | `== !=`                             | 从左到右 |      |
| 8      | `&`                                 | 从左到右 |      |
| 9      | `^`                                 | 从左到右 |      |
| 10     | `|`                                 | 从左到右 |      |
| 11     | `&&`                                | 从左到右 |      |
| 12     | `||`                                | 从左到右 |      |
| 13     | `? :`                               | 从右到左 |      |
| 14     | `= += -= *= /= %= <<= >>= &= ^= |=` | 从右到左 |      |
| 15     | `,`                                 | 从左到右 |      |

## 7、以下程序的运行结果是（）

```
#include <stdio.h> 
int main() { 
    int sum, pad,pAd; 
    sum = pad = 5; 
    pAd = ++sum, pAd++, ++pad; 
    printf("%d\n",pAd); 
}
```

> A 5  
>
> B 6
>
> C 7
>
> D 8

> 答案：C ，根据优先级计算，由于赋值表达式优先级高于逗号，所以第五行代码等价于
>
> (pAd = ++sum), pAd++, ++pad;
>
> 因此是7

## 9、在下列C代码中：如果指向非空树的根的指针作为参数传递，则DoSomething函数的返回值是（）

```
struct Celode
{
  struct Celode *lchild;
  int element;
  struct Celode *rChild;
}
  
int DoSomething(struct Celode *ptr)
{
    int value = 0;
    if (ptr != NULL)
    {
      if (ptr -> lChild != NULL)
        value = 1 + DoSomething(ptr -> lChild);
      if (ptr -> rChild != NULL)
        value = max(value, 1 + DoSomething(ptr -> rChild));
    }
    return (value);
}
```

> A 树的叶节点数
>
> B 树的节点数
>
> C 树的内部节点数
>
> D 树的高度



> 分析：如果是树的节点树就应该是加，而不是判断max，因此直接得到答案D



# 5/18号

## 1、对于C/C++语言的函数，下列叙述中正确的是（ ）

> A  函数的定义不能嵌套，但是函数调用可以嵌套
>
> B  函数的定义可以嵌套，但函数调用不能嵌套
>
> C  函数的定义和调用都不能嵌套
>
> D  函数的定义和调用都可以嵌套

> 答案：A C语言中函数定义不能嵌套，但是函数调用可以嵌套

## 2、以下程序的输出结果是（）

```
int main() {
    char ch[3][5]={"AAAA","BBB","CC"};
    printf("\"%s\"\n",ch[1]);
}
```

>A   "AAAA"
>B   "BBB"
>C   "BBBCC"
>D   "CC"

> 答案：B 
>
> 解析：ch[0]，ch[1]，ch[2]这种都是列指针（一维指针），而ch，ch+1，ch+2是行指针（数组指针），所以题目中ch[1]表示指向第二行首元素的列指针；

## 4、以下正确的函数定义形式是（）

> A double fun(int x,int y)
> B double fun (int x;int y)
> C double fun (int x,inty)；
> D double fun (intx,y)；

> 答案：A
>
> 解析：函数定义时每个形参都必须指明数据类型符，形参之间必须以逗号隔开，所
>
> 以B和D是错误的，另外，函数定义时末尾不能带分号，只有函数说明时才带分号，所以
>
> C也是错误的。故正确答案是A。

## 5、对于以下代码，char* p=new char[100];说法正确的是（）

> A p和new出来的内存都在栈上
> B p和new出来的内存都在堆上
> C p在堆上，new出来的在栈上
> D p在栈上，new出来的在堆上

> [内存布局](#内存布局)
>
> 答案：D
>
> 解析：new 出来的对象放在堆中，局部变量放在栈中。

## 6、m++ 和 ++m的区别

## 8、有以下程序，输出结果是：

```
#include <stdio. h>
int fun( int a )
{
    int b = 0;
    static int c = 3;
    a = ( c + +,b + + );
    return ( a );
}
main( )
{
    int a = 2,i,k;
    for( i = 0;i<2;i + + )
        k = fun( a + + );
    printf("%d\n",k );
}
```

> A 4
> B 0
> C 1
> D 2

> 答案：B
>
> 解析：这个题目主要分析第六行代码，由于逗号是最低优先级运算符，如果没有括号的话，    
>
> a1=(表达式1,表达式2);           a2=表达式1,表达式2;    
>
> a1是表达式2的结果，而a2是表达式1的结果
>
> 对于函数内的c来说是一个[局部静态变量](#局部静态变量)



## 9、下面程序运行结果是3，5 轻微横线处选择合适的代码

![image-20240518180146080](/img/5_18_ninth.png)

> A p++ ->n
> B (++p) ->n
> C (a+1) ->n
> D (p+1) ->n

> 答案：BCD
>
> 解析：BCD可以输出3，5 A. p++ ->n相当于p->n; p++ ，所以输出的是3，3 B.（++p）->n，p现在指向的是a数组的第二个元素，即{ 5, "def"}这个结构体元素，会输出3， 5 C.（a + 1）->n，a + 1是{ 5, "def" }元素的地址，所以会输出3,，5 D.（p + 1）->n，p + 1是增加的偏移量，即第二个元素的地址，会输出3，5

## 10.下面哪些运算符不能被重载（）

> A 三目运算符“?:”
> B 作用域运算符“::”
> C 对象成员运算符“.”
> D 指针成员运算符“->”

> 答案：ABC
>
> 解析：  不能被重载的运算符只有五个，分别是 
>
>     1.  .  （成员访问运算符） 
>     2.  *（成员指针访问运算符） 
>     3.  ::  （域运算符） 
>     4.  sizeof  （长度运算符） 
>   5. ?:    （条件运算符）
>
>  前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。



# 5/19号



## 1、下面代码段的输出为（）

```
int a = 5, b = -5;
printf("%d,%d", a%(-4), b%(-4));
```

> A  1,-1
> B  1,1
> C  -1,1
> D  -1,-1

> 答案：A
>
> 解析：对于除法/来说，（-m)/n 和 m/(-n) 等于-(m/n) 
>
> 但是对于取余%来说，(-m)%n = -(m % n)
>
> m % (-n) = m%n

## 2、一个 C 语言程序是由（）

> A 一个主程序和若干子程序组成
> B 函数组成
> C 若干过程组成
> D 若干子程序组成

> 答案：B
>
> 解析：函数是C程序的基本单位，一个C语言源程序是由一个main函数和若干其他函数组成的

## 3、运行下面这段C语言程序之后，输出在屏幕上的结果是：

```
#include<stdio.h>
void foobar(int a, int *b, int **c)
{
    int *p = &a;
    *p = 101;
    *c = b;
    b = p;
}
 
int main()
{
    int a = 1;
    int b = 2;
    int c = 3;
    int *p = &c;
    foobar(a, &b, &p);
    printf("a=%d, b=%d, c=%d, *p=%d\n", a, b, c, *p);
    return (0);
}
```

> A a=1, b=2, c=3, *p=2
> B a=101, b=2, c=3, *p=2
> C a=101, b=101, c=2, *p=3
> D a=1, b=101, c=2, *p=3

> 答案：A
>
> 分析：首先对于a来说，在foobar中是以值的形式传递的，因此无论怎么修改都不会影响main函数中的值，所以a=1不会变
>
> 函数中b传递的是主函数中b的指针，语句b = p, 其中p指向的是函数foobar内局部变量a 的地址，让传递过去的指针换了指向的数据，原来函数中的b不会由影响，如果修改为*b = *p,则原函数中的b会变化
>
> 对于c来说，他是将指向c的一个指针的地址传入，*c = b，也就是让主函数中的p指针指向了主函数中的b的地址
>
> 

## 4、对于 32 位机器，则下面代码输出结果为（）

```
#include<iostream>
#include<string>
 
using namespace std;
 
typedef struct data_ {
    int a[10];
} data_t;
 
typedef struct descriptor_ {
    data_t* ptr;
    char data[0];
} desc_t;
 
int main() {
    cout << sizeof(desc_t) << endl;
    return 0;
}
```

> A 40
> B 4
> C8 
> D 0

> 答案：B
>
> 解析：首先就是对于一个32为系统指针是4字节，64位操作系统指针是8字节，然后是char data[0]是一个柔性数组，它默认不占用内存，用来指示数组可以在运行时动态分配内存。
>
> 此外对于64位操作系统大部分int也都是四字节



## 5、下列程序的功能是将 s 中的字符串按长度由小到大排列，请为横线处选择合适的程序（）

```c
#include <stdio.h>
#include <string.h>
 
void f(char *p[], int n) {
    char *t;
    int i, j;
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (strlen(*(p + i)) > strlen(*(p + j))) {
                t = *(p + i);
                *(p + i) = *(p + j);
                *(p + j) = t;
            }
}
 
int main() {
    char *s[] = {"abc", "abcdef", "abbd"};
    f(s, 3);
    for (int i = 0; i < 3; i++)
        printf("%s\n", ____);
    return 0;
}
```

> A  s+i
> B  s[i]
> C  *s[i]
> D  &s[i]

> 答案：B
>
> 解析：对于s + i来说，s是一个char \*\*类型的指针,所以在他运算结束后还是char \*\*类型
>
> 对于s[i]来说，是一个指向字符的指针类型 (char*)，因此用来输出%s的结果
>
> 对于\*s[i]直接就是该字符串，
>
> &s[i]和第一个结果一致

## 6、若变量a, i已正确定义，且i已正确赋值，合法的语句是（ ）

> A a = int(i);
> B a == 1
> C ++i;
> D a = a++ = 5;

> 答案：C
>
> 解析：首先是题目，i已经正确赋值，则可以进行++操作，对于D来说，a没有正确赋值，也无法作比较，
>
> 对于答案A来说，强制类型转换是（int）i；

## 7、2022 迅雷 C++，现在有以下语句： 则执行后，变量sz的值将得到

```C
struct _THUNDER{ 
  int iVersion; 
  char cTag; 
  char cAdv; 
  int iUser; 
  char cEnd; 
  }Thunder; 
  int sz=sizeof(Thunder); 
  
```

> A 11
> B 12
> C 13
> D 16

> 答案：16 [sizeof](#sizeof)
>
> 解析： 结构体成员按照定义时的顺序依次存储在连续的内存空间，但是结构体的大小并不是简单的把所有成员大小相加，而是遵循一定的规则，需要考虑到系统在存储结构体变量时的地址对齐问题。
>
> 1、 没有成员的结构体占用的空间是多少个字节？ 答：1字节，确保每个实例都有一个唯一的地址。
>
> 2、在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：
>
> ​       （1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 
>
> ​	   （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 

## 8、2022 腾讯 C++ 假设MyClass为一个类，则执行“MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是？

> A 2
> B 4
> C 5
> D 9

> 正确答案：C
>
> 解析：MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。

## 9、2021 海康威视 Makefile下面哪个初始化是非法的（按照顺序）

```
A int i = 1
B const int ic = i
C const int *pic = &ic
D int*const cpi = &ic
```

> 答案：D
>
> 解析：A变量i初始化正确，接着使用ic为整型常量，在运行时由i赋值，随后(const int )\* =&(const int)
>
> 但是对于D来说，(int *  const)= &(const int)因此是错误的
>
> 

## 10、2022 迅雷 C++有如下程序段：请问运行Test函数结果是：

```
  voidGetMemeory(char*p) 
  { 
  p=(char*)malloc(100); 
  ｝ 
  voidtest() 
  { 
  char *str=NULL; 
  GetMemory(str); 
  strcpy(str,”Thunder”); 
  strcat(str+2,“Downloader”); 
  printf(str); 
  }
```

> A ThunderDownloader
> B underDownloader
> C Thunderownloader
> D 程序崩溃

> 答案：D
>
> 解析：由于str一开始为Null，而在函数中申请的内存空间随着该函数运行结束，则分配的内存空间也被释放掉，因此str指针指向的还是空，所以后续进行strcpy操作会报错。
















# 外链知识（设置一个锚点能够跳转到这个位置）

## <a name="析构函数">析构函数</a>



## <a name="内存布局">内存布局</a>

栈（Stack）：由编译器自动管理，用于存放函数的局部变量、函数参数、返回地址等，具有动态特性，内存地址从高地址向低地址增长。
堆（Heap）：由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。 用于动态内存分配，如通过malloc、calloc、realloc函数分配的内存）

数据段（Data Segment）：包括已经初始化的全局变量和静态变量，内存地址固定。

BSS段（BSS(Block Started by Symbol) Segment）：包括未初始化的全局变量和静态变量，在程序开始执行前，这个段会被操作系统清零

代码段（Text Segment）：用于存放程序的可执行指令，内存地址固定



## <a name="局部静态变量">局部静态变量</a>

> 局部静态变量是声明在函数内部，但使用static关键字修饰的变量。它们具有以下特点：
>
> * 存储位置: 尽管他是一个静态变量，但是他和全局变量存储在一个数据段或者BSS段
> * 生命周期：局部静态变量的生命周期是整个程序运行期间。它们在第一次调用定义它们的函数时初始化，并在程序终止时销毁。
> * 作用域：它们的作用域仅限于定义它们的函数。尽管它们的值在函数的多次调用之间保持不变，但它们不能被函数外部的代码直接访问。
>
> 初始化
>
> * 默认初始化：如果局部静态变量没有显式初始化，则会被初始化为零（对于基本数据类型）。
> * 显式初始化：可以在定义局部静态变量时显式地给它们赋初始值。这个初始化只在变量第一次被创建时进行一次。

## <a name="sizeof">sizeof和strlen</a>

| 特点         | `sizeof`                   | `strlen`                   |
| ------------ | -------------------------- | -------------------------- |
| 计算内容     | 数据类型或对象占用的字节数 | 以 `\0` 结尾的字符串的长度 |
| 计算时机     | 编译时                     | 运行时                     |
| 作用范围     | 任何数据类型               | 仅限以 `\0` 结尾的字符串   |
| 包括 `\0` 吗 | 包括（如果是字符数组）     | 不包括                     |



## <a name="指针数组">指针数组和数组指针</a>





## <a name="指针函数">指针函数和函数指针</a>





## <a name="指针常量">指针常量和常量指针</a>

它们的区别主要在于“谁是常量”，即指针本身是常量，还是指针指向的数据是常量。

**常量指针**

* 常量指针是指向常量数据的指针。通过常量指针，不能修改它所指向的对象的值。

* 声明方式：

```
const int *ptr;
int const *ptr;
```



**指针常量（Constant Pointer）**

* 指针常量是指针本身是常量。一旦初始化后，不能改变指针指向的地址，但可以通过指针修改指向的对象的值（前提是指向的对象不是常量）。
* 声明方式

```
int *const ptr;
```





## <a name="string">string.h</a>

### 字符串操作方法：

1、strcpy 和 strncpy

* strcpy 函数用于将源字符串复制到目标字符串中。

```
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "Hello, World!";
    char dest[50];

    strcpy(dest, src);
    printf("Destination: %s\n", dest); // 输出: Destination: Hello, World!

    return 0;
}
//注意：目标数组必须有足够的空间来存储源字符串及其末尾的空字符 \0。
```

* strncpy 函数是 strcpy 的安全版本，允许指定复制的最大字符数。
  * 如果源字符串长度大于指定的字符数，目标字符串不会自动加上空字符，需要手动添加

* strlen 函数用于计算字符串的长度（不包括末尾的空字符 \0）。

* strcmp 和 strncmp   用于比较字符串

* strcat和 strncat  
  * strcat 函数用于将源字符串追加到目标字符串的末尾。
* strchr 和 strrchr
  * strchr 函数用于在字符串中查找第一次出现的指定字符。
  * strrchr最后一次出现的位置
* strstr 查找子字符串第一次出现的位置





































































