---
layout:     post   				    # 使用的布局（不需要改）
title:      死锁现象与解决方法				# 标题 
subtitle:    #副标题
date:       2022-04-27 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea2.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 面向对象
    - 八股
---

# 前言

死锁现象与本人所处的开发环境与开发状态相关度不高。但作为几乎必然会出现的开发现象，死锁相关知识点理应被重视。
当前本项目所涉及到类似“死锁”现象都集中于使三极管/MOSFET强制发一个高电平，之后电路就进入了平稳运行状态。这种处理方式是通过连接仿真器进行在线仿真，修改寄存器对应标志位来实现的。下面我们将关注在纯软件开发工作中，死锁现象的解释与可能的解决方案。

![](https://raw.githubusercontent.com/xie96808/xie96808.github.io/master/img/sisuo.jpg)

# 什么是死锁？

死锁（Deadlock）：是指**两个或两个以上的进程**在执行过程(申请资源)中，因**争夺资源**而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。称此时系统处于死锁状态或系统产生了死锁。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。我们称这些永远在**互相等待**的进程为死锁进程。

这句话的核心在于三处：
1. “两个或两个以上的进程”：也就是说死锁必定是在并发“进程”（这里的进程可以看作是一个泛指，具体要看这个系统是什么）间产生，单个进程不会产生死锁。  
2. “资源争夺”：这些并发的进程必须互相争夺资源，如果一个系统存在并发的进程，但是大家都井水不犯河水，那么也不会产生死锁。  
3. 造成的结果是这些进程进入一种状态，各个进程都无法继续推进，如果没有外力，这些进程无法跳出这个状态。

或许，死锁的最好例证是：Kansas 立法机构在 20 世纪初通过的一项法律，其中说道：“当两列列车在十字路口逼近时，它们应完全停下来，并且在一列列车开走之前另一列列车不能再次启动。”

# 如何处理死锁状态？

一般来说，处理死锁问题有三种方法：
1. 通过协议来预防或避免死锁，确保系统不会进入死锁状态。
2. 可以允许系统进入死锁状态，然后检测它，并加以恢复。
3. 可以忽视这个问题，认为死锁不可能在系统内发生。

