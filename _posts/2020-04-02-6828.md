---
layout:     post   				    # 使用的布局（不需要改）
title:      828-lab2-part2(1)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-02 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# part2：虚拟内存

## 虚拟地址，线性地址和物理地址

​		在x86中，虚拟地址由段选择器和段内的偏移量组成。线性地址是在段转换之后，页面转换之前得到的地址。物理地址是在段和页转换之后最终得到的地址，也是最终在硬件总线上输出到RAM的地址。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfj7ouv3mj30i804vq31.jpg)

​		C指针是虚拟地址的“偏移量”组件。在boot/boot.S，我们安装了一个全局描述符表(GDT)，它通过将所有段的基本地址设置为0并限制为0xffffffff来有效地禁用段转换。因此，“选择器”没有效果，线性地址总是等于虚拟地址的偏移量。在lab 3中，我们将不得不与分段进行更多的交互以设置特权级别，但是对于内存翻译，我们可以忽略整个JOS实验室中的分段，而只关注页面翻译。

​		还记得在lab 1的第3部分中，我们安装了一个简单的page表，这样内核就可以在它的链接地址0xf0100000处运行，即使它实际上是装载在物理内存中，就在ROM BIOS的上面0x00100000处。该页表仅映射了4MB的内存。在您将在这个实验室为JOS设置的虚拟地址空间布局中，我们将扩展它，以映射从虚拟地址0xf0000000开始的第一个256MB物理内存，并映射虚拟地址空间的许多其他区域。

### 练习3

虽然GDB只能通过虚拟地址访问QEMU的内存，但在设置虚拟内存时检查物理内存通常是有用的。查看来自实验室工具指南的QEMU监视器命令，特别是xp命令，它允许您检查物理内存。要访问QEMU监视器，请在终端中按Ctrl-a - c(相同的绑定返回到串行控制台)。

使用QEMU监视器中的xp命令和GDB中的x命令检查相应物理地址和虚拟地址的内存，确保看到相同的数据。

我们的QEMU补丁版本提供了一个info pg命令，它可能也很有用:它显示了当前页表的紧凑但详细的表示，包括所有映射的内存范围、权限和标志。Stock QEMU还提供了一个info mem命令，该命令显示了被映射的虚拟地址范围和权限的概述。

题目中提供的命令好像不行，我在网上找了另一个打开monitor的指令：

`qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log `

打开monitor之后，我们可以输入info registers指令来查看寄存器状态：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfjibuid9j30ny0gqadt.jpg)

输入info mem指令 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。

输入info pg指令 展示当前页表的结构。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfjixu3drj30k60gqn03.jpg)

​		

​		从在CPU上执行的代码来看，一旦我们进入保护模式(我们在boot/boot. s中输入的第一件事)，就无法直接使用线性或物理地址。所有内存引用都被解释为虚拟地址，并由MMU进行翻译，这意味着C中的所有指针都是虚拟地址。

​		JOS内核经常需要将地址作为不透明的值或整数进行操作，而不取消对它们的引用，例如在物理内存分配器中。有时是虚拟地址，有时是物理地址。为了帮助记录代码，JOS源代码区分了两种情况:uintptr_t类型表示不透明的虚拟地址，而physaddr_t类型表示物理地址。这两种类型实际上都是32位整数(uint32_t)的同义词，因此编译器不会阻止您将一种类型分配给另一种类型!由于它们是整数类型(而不是指针)，如果您试图取消对它们的引用，编译器将会发出警告。

​		JOS内核可以通过首先将uintptr_t转换为指针类型来取消对它的引用。相反，内核不能理智地取消对物理地址的引用，因为MMU转换所有内存引用。如果您将一个physaddr_t转换为一个指针并取消引用它，您可能能够加载并存储到结果地址(硬件将把它解释为一个虚拟地址)，但是您可能不会得到您想要的内存位置。

总结：

| C type       | Address type |
| ------------ | ------------ |
| `T*`         | Virtual      |
| `uintptr_t`  | Virtual      |
| `physaddr_t` | Physical     |

​		JOS内核有时需要读取或修改它只知道物理地址的内存。例如，将映射添加到页表可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接加载和存储到物理地址。JOS从虚拟地址0xf0000000处的物理地址0开始重新映射所有物理内存的原因之一是，帮助内核读写它只知道物理地址的内存。为了将物理地址转换成内核实际上可以读写的虚拟地址，内核必须向物理地址添加0xf0000000，以便在重新映射的区域中找到它对应的虚拟地址。我们应该使用KADDR(pa)来进行添加。

​		JOS内核有时还需要根据存储内核数据结构的内存的虚拟地址查找物理地址。内核全局变量和由boot_alloc()分配的内存位于加载内核的区域，从0xf0000000开始，这正是我们映射所有物理内存的区域。因此，要将这个区域中的虚拟地址转换为物理地址，内核只需减去0xf0000000。我们应该用PADDR(va)来做减法。

## 引用计数

在未来的实验中，我们将经常在多个虚拟地址(或多个环境的地址空间)上同时映射相同的物理页面。我们将在struct PageInfo对应于物理页面的pp_ref字段中保留对每个物理页面的引用数量的计数。当一个物理页面的这个计数变为0时，该页面可以被释放，因为它不再被使用。通常，这个计数应该等于在所有页表中物理页出现在UTOP之下的次数(UTOP之上的映射大部分是在启动时由内核设置的，并且不应该被释放，因此不需要引用计数)。我们还将使用它来跟踪保存到页目录页的指针数量，进而跟踪页目录对页表页的引用数量。

使用page_alloc时要小心。它返回的页面的引用计数总是0，因此，一旦我们对返回的页面做了一些操作(比如将其插入到页表中)，pp_ref就应该增加。有时这是由其他函数处理的(例如，page_insert)，有时调用page_alloc的函数必须直接执行。

## 页表管理

现在，我们要编写一组管理页表的例程:插入和删除线性到物理的映射，以及在需要时创建页表页。

### 练习4

在kern/pmap文件中实现下列函数的代码：

```
pgdir_walk()
boot_map_region()
page_lookup()
page_remove()
page_insert()
```

从mem_init()调用check_page()，测试页表管理例程。

pgdir_walk()函数：

给定'pgdir'，一个指向页面目录的指针，pgdir_walk返回一个指向线性地址'va'的页表条目(PTE)的指针。这需要遍历两级页面表结构。相关页表页可能还不存在。如果这是真的，并且create == false，那么pgdir_walk返NULL。否则，pgdir_walk使用page_alloc分配一个新的页表页。

-如果分配失败，pgdir_walk返回NULL。

-否则，新页的引用计数将增加，该页将被清除，pgdir_walk将返回一个指向新页表页的指针。

提示1:您可以使用kern/pmap.h中的page2pa()将PageInfo *转换为它所引用的页面的物理地址。

提示2:x86 MMU同时检查页面目录和页面表中的权限位，因此将页面目录中的权限保留为比严格必要的权限更宽松是安全的。

提示3:在inc/mmu.h中查找操作页表和页目录条目的有用宏。

```c
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	unsigned int page_off;
       pte_t * page_base = NULL;
       struct PageInfo* new_page = NULL;
       //通过页目录表求得这个虚拟地址所在的页表页对于与页目录中的页目录项地址 dic_entry_ptr
       unsigned int dic_off = PDX(va);
       pde_t * dic_entry_ptr = pgdir + dic_off;
 		//判断这个页目录项对应的页表页是否已经在内存中
       if(!(*dic_entry_ptr & PTE_P))
       {
           //如果不在且create为true则分配新的页，并且把这个页的信息添加到页目录项dic_entry_ptr中
             if(create)
             {
                    new_page = page_alloc(1);
                    if(new_page == NULL) return NULL;
                    new_page->pp_ref++;
                    *dic_entry_ptr = (page2pa(new_page) | PTE_P | PTE_W | PTE_U);
             }
            else
                return NULL;      
       }  
    	//如果在，计算这个页表页的基地址page_base，然后返回va所对应页表项的地址 &page_base[page_off]
       page_off = PTX(va);
       page_base = KADDR(PTE_ADDR(*dic_entry_ptr));
       return &page_base[page_off];
	//return NULL;
}
```

然后再看boot_map_region()函数

在以pgdir为根的页表中，将虚拟地址空间的[va, va+size]映射到物理[pa, pa+size]。Size是PGSIZE的倍数，va和pa都是页面对齐的。

对条目使用perm|PTE_P权限位。

此函数仅用于设置UTOP之上的“静态”映射。因此，它应该“不”更改映射页面上的pp_ref字段。

提示:TA解决方案使用pgdir_walk

```c
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
 int nadd;
     pte_t *entry = NULL;
   //把一个虚拟页和物理页的映射关系存放到响应的页表项中。直到把size个字节的内存都分配完。
     for(nadd = 0; nadd < size; nadd += PGSIZE)
     {
         entry = pgdir_walk(pgdir,(void *)va, 1);    //Get the table entry of this page.
         *entry = (pa | perm | PTE_P);
        
         pa += PGSIZE;
         va += PGSIZE;
         
     }
}
```

page_insert()函数：

实现将物理页面“pp”映射到虚拟地址“va”。

页表条目的权限(最低12位)应该设置为“perm|PTE_P”。

要求：

-如果已经有一个页面映射在'va'，它应该是page_remove()d。

-如有需要，应根据需要分配一个页表并将其插入“pgdir”。

如果插入成功，pp-&gt;pp_ref应该增加。

-如果以前在“va”上有一个页面，则TLB必须无效。

大小写提示:确保考虑在相同的pgdir中的相同虚拟地址重新插入相同的pp时会发生什么。

但是，尽量不要在代码中区分这种情况，因为这经常会导致一些细微的bug;有一种优雅的方法可以在一个代码路径中处理所有内容。

```c
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
    //通过pgdir_walk函数求出虚拟地址va所对应的页表项
	pte_t *entry = NULL;
    entry =  pgdir_walk(pgdir, va, 1);    
    if(entry == NULL) return -E_NO_MEM;
 	//修改pp_ref的值
    pp->pp_ref++;
    //查看这个页表项，确定va是否已经被映射，如果被映射，则删除这个映射
    if((*entry) & PTE_P)            
    {
        tlb_invalidate(pgdir, va);
        page_remove(pgdir, va);
    }
    //把va和pp之间的映射关系加入到页表项中
    *entry = (page2pa(pp) | perm | PTE_P);
    pgdir[PDX(va)] |= perm;                 
	return 0;
}
```

page_lookup函数：

返回映射到虚拟地址'va'的页面。

如果pte_store不为零，则在其中存储此页的pte地址。这是page_remove使用的，可以用来验证syscall参数的页面权限，但是不应该被大多数调用者使用。

如果在va没有映射页面，则返回NULL。

提示:TA解决方案使用pgdir_walk和pa2page。

```c
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	 pte_t *entry = NULL;
     struct PageInfo *ret = NULL;
 	//调用pgdir_walk函数获取这个va对应的页表项
     entry = pgdir_walk(pgdir, va, 0);
     if(entry == NULL)
         return NULL;
     if(!(*entry & PTE_P))
         return NULL;
     //把这个页表项的内容存放到pte_store中
     ret = pa2page(PTE_ADDR(*entry));
     if(pte_store != NULL)
     {
         *pte_store = entry;
     }
    //返回结构体
     return ret;

}
```

page_remove函数：

在虚拟地址“va”处取消对物理页面的映射。

如果该地址没有物理页面，则不执行任何操作。

细节:

-物理页上的参考计数pp_ref应该递减。

-如果refcount为0，则释放物理页。

\- pg表中“va”对应的条目应设置为0。

(如有PTE)

-如果从页表中删除一个条目，则TLB必须无效。

提示:TA解决方案是使用page_lookup、tlb_invalidate和page_decf实现的。

```c
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t *pte = NULL;
     struct PageInfo *page = page_lookup(pgdir, va, &pte);
     if(page == NULL) return ;    
     
     page_decref(page);
     tlb_invalidate(pgdir, va);
     *pte = 0;
}
```

然后make一下：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfteu0n4dj30ar021wee.jpg)