---
layout:     post   				    # 使用的布局（不需要改）
title:      6828-lab3-partA(3)		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-08 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

### Basics of Protected Control Transfer

​		异常和中断都是“受保护的控制传输”，它导致处理器从用户模式切换到内核模式(CPL=0)，而不给用户模式代码任何机会来干扰内核或其他环境的功能。在Intel的术语中，中断是受保护的控制传输，它是由通常位于处理器外部的异步事件引起的，例如外部设备I/O活动的通知。相反，一个例外是当前运行的代码同步地引起的受保护的控制传输，例如由于除0或无效的内存访问。

​		为了确保这些受保护的控制传输实际上是受保护的，处理器的中断/异常机制被设计成当中断或异常发生时，当前运行的代码不会随意选择内核的输入位置或方式。相反，处理器确保只能在严格控制的条件下输入内核。在x86上，有两种机制共同提供这种保护:

1. **中断描述符表**。处理器确保中断和异常只能在内核本身确定的几个特定的、定义良好的入口点上输入内核，而不能由在中断或异常发生时运行的代码来输入。

   x86允许内核中最多256个不同的中断或异常入口点，每个都有不同的中断向量。向量是0到255之间的数字。中断的向量是由中断的源决定的:不同的设备、错误条件和对内核的应用程序请求用不同的向量产生中断。CPU使用这个向量作为到处理器的中断描述符表(IDT)的索引，内核将IDT设置在内核专用内存中，非常类似于GDT。从该表中适当的条目，处理器加载:

   - 加载到指令指针(EIP)寄存器的值，指向指定处理该类型异常的内核代码。
   - 要加载到代码段(CS)寄存器中的值，该寄存器以0-1位的形式包含要运行异常处理程序的特权级别。(在JOS，所有异常都在内核模式下处理，特权级别为0。)

2. **任务状态段** 

   处理器需要一个地方保存旧处理器中断或异常发生前的状态,如EIP的原始值和CS在处理器调用异常处理程序之前,所以老状态的异常处理程序可以稍后恢复和恢复中断的代码从那里离开。但这对旧处理器状态保存区反过来必须免受未经授权的用户模式代码;否则，有bug或恶意的用户代码可能危及内核。

   因此，当x86处理器发生中断或陷阱，导致从用户到内核模式的权限级别发生变化时，它还会切换到内核内存中的堆栈。称为任务状态段(TSS)的结构指定该堆栈所在的段选择器和地址。处理器(在这个新堆栈上)推送SS、ESP、EFLAGS、CS、EIP和一个可选的错误代码。然后从中断描述符中加载CS和EIP，并设置ESP和SS以引用新堆栈。

   尽管TSS很大，并且可能有多种用途，但是JOS只使用它来定义处理器从用户模式转换到内核模式时应该切换到的内核堆栈。由于JOS中的“内核模式”是x86上的特权级别0，所以在进入内核模式时，处理器使用TSS的ESP0和SS0字段来定义内核堆栈。JOS不使用任何其他TSS字段。

### 异常和中断的类型

​		x86处理器可以在内部生成的所有同步异常都使用0到31之间的中断向量，因此映射到IDT条目0-31。例如，页面错误总是通过vector 14导致异常。大于31的中断向量仅用于软件中断，软件中断可由int指令生成，或外部设备在需要注意时引起的异步硬件中断。

​		在本节中，我们将扩展JOS来处理0-31向量中内部生成的x86异常。在下一节中，我们将让JOS处理软件中断向量48 (0x30)，它是JOS(相当随意地)使用的系统调用中断向量。在实验室4中，我们将扩展JOS来处理外部产生的硬件中断，如时钟中断。

#### 一个例子

​		让我们将这些片段放在一起，并通过一个示例进行跟踪。假设处理器在用户环境中执行代码，遇到一条试图除0的divide指令。

1. 处理器切换到由TSS的SS0和ESP0字段定义的堆栈，在JOS中，这两个字段分别包含GD_KD和KSTACKTOP值。

2. 处理器将异常参数推入内核堆栈，从地址KSTACKTOP开始:

   ```
    +--------------------+ KSTACKTOP             
                        | 0x00000 | old SS   |     " - 4
                        |      old ESP       |     " - 8
                        |     old EFLAGS     |     " - 12
                        | 0x00000 | old CS   |     " - 16
                        |      old EIP       |     " - 20 <---- ESP 
                        +--------------------+             
   ```

3. 因为我们正在处理一个分割错误，也就是x86上的中断向量0，所以处理器读取IDT条目0并设置CS:EIP来指向条目所描述的处理函数。
4. 处理程序函数接受控制并处理异常，例如通过终止用户环境。

对于某些类型的x86异常，除了上面的“标准”之外，处理器还会将另一个包含错误代码的字推到堆栈上。页面错误异常(编号14)是一个重要的示例。请参阅80386手册，以确定处理器为哪个异常号推送错误代码，以及在这种情况下错误代码的含义。当处理器推送错误代码时，从用户模式进入异常处理程序时，堆栈将如下图所示:

```
  +--------------------+ KSTACKTOP             
                     | 0x00000 | old SS   |     " - 4
                     |      old ESP       |     " - 8
                     |     old EFLAGS     |     " - 12
                     | 0x00000 | old CS   |     " - 16
                     |      old EIP       |     " - 20
                     |     error code     |     " - 24 <---- ESP
                     +--------------------+             
```

### 嵌套异常和中断

​		处理器可以从内核和用户模式获取异常和中断。但是，只有在从用户模式进入内核时，x86处理器才会在将旧的寄存器状态推入堆栈并通过IDT调用适当的异常处理程序之前自动切换堆栈。如果在发生中断或异常时处理器已经处于内核模式(CS寄存器的低2位已经为零)，那么CPU只是在相同的内核堆栈上推送更多的值。通过这种方式，内核可以优雅地处理由类中的代码引起的嵌套异常。

​		如果处理器已经处于内核模式并接受嵌套异常，因为它不需要切换堆栈，所以它不会保存旧的SS或ESP寄存器。对于不推送错误代码的异常类型，内核堆栈因此在异常处理程序的入口看起来像下面这样:

```
   +--------------------+ <---- old ESP
                     |     old EFLAGS     |     " - 4
                     | 0x00000 | old CS   |     " - 8
                     |      old EIP       |     " - 12
                     +--------------------+             
```

​		对于推送错误代码的异常类型，处理器会像以前一样，在旧的EIP之后立即推送错误代码。

​		对于处理器的嵌套异常功能有一个重要的警告。如果处理器在已经处于内核模式时发生异常，并且由于缺乏堆栈空间等原因无法将其旧状态推入内核堆栈，那么处理器就无法进行任何恢复，因此它只能重置自己。不用说，内核的设计应该避免这种情况的发生。

### 设置IDT

​		现在我们应该拥有了设置IDT和处理JOS中的异常所需的基本信息。现在，我们将设置IDT来处理中断向量0-31(处理器异常)。我们将在稍后的实验室中处理系统调用中断，并在稍后的实验室中添加32-47中断(设备IRQs)。

​		头文件inc/trap.h和kern/trap.h包含与中断和异常相关的重要定义，我们需要熟悉这些定义。文件kern/trap.h包含对内核严格私有的定义，而inc/trap.h包含对用户级程序和库可能也有用的定义。

​		注意:0-31范围内的一些异常由Intel定义并保留。因为它们永远不会由处理器生成，所以如何处理它们并不重要。

​		整体控制流程如下:

```
      IDT                   trapentry.S         trap.c
   
+----------------+                        
|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)
|                |             // do stuff      {
|                |             call trap          // handle the exception/interrupt
|                |             // ...           }
+----------------+
|   &handler2    |--------> handler2:
|                |            // do stuff
|                |            call trap
|                |            // ...
+----------------+
       .
       .
       .
+----------------+
|   &handlerX    |--------> handlerX:
|                |             // do stuff
|                |             call trap
|                |             // ...
+----------------+
```

​		每个异常或中断在trapentry.S和trap_init()中都应该有自己的处理程序。应该使用这些处理程序的地址初始化IDT。每个处理程序都应该在堆栈上构建一个struct Trapframe(参见inc/trap.h)，并使用指向Trapframe的指针调用trap()(在trap.c中)。然后，trap()处理异常/中断或分派到特定的处理程序函数。

#### 练习4

编辑trapentry.S和inc/trap.h并实现上述功能。宏TRAPHANDLER和TRAPHANDLER_NOEC在trapentry.S中。我们需要在trapentry中添加一个入口点。为inc/trap中定义的每个陷阱(使用那些宏)。我们必须提供TRAPHANDLER宏所引用的_alltraps。还需要修改trap_init()来初始化idt，使其指向trapentre . s中定义的每个入口点;SETGATE宏在这里会有帮助。

_alltraps应该:

1. 把值压入堆栈使堆栈看起来像一个结构体 Trapframe

　2. 加载 GD_KD 的值到 %ds, %es寄存器中

　3. 把%esp的值压入，并且传递一个指向Trapframe的指针到trap()函数中。

　4. 调用trap

考虑使用pushal指令，它会很好的和结构体 Trapframe 的布局配合好。

trapentry.S的代码为：

```c
/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
//使用TRAPHANDLER和TRAPHANDLER_NOEC宏创建0~16号中断的中断处理函数。TRAPHANDLER和TRAPHANDLER_NOEC创建的函数都会跳转到_alltraps处
TRAPHANDLER_NOEC(handler0, T_DIVIDE)
TRAPHANDLER_NOEC(handler1, T_DEBUG)
TRAPHANDLER_NOEC(handler2, T_NMI)
TRAPHANDLER_NOEC(handler3, T_BRKPT)
TRAPHANDLER_NOEC(handler4, T_OFLOW)
TRAPHANDLER_NOEC(handler5, T_BOUND)
TRAPHANDLER_NOEC(handler6, T_ILLOP)
TRAPHANDLER(handler7, T_DEVICE)
TRAPHANDLER_NOEC(handler8, T_DBLFLT)
TRAPHANDLER(handler10, T_TSS)
TRAPHANDLER(handler11, T_SEGNP)
TRAPHANDLER(handler12, T_STACK)
TRAPHANDLER(handler13, T_GPFLT)
TRAPHANDLER(handler14, T_PGFLT)
TRAPHANDLER_NOEC(handler16, T_FPERR)
TRAPHANDLER_NOEC(handler48, T_SYSCALL)

/*
 * Lab 3: Your code here for _alltraps
 */
    //参考inc/trap.h中的Trapframe结构。tf_ss，tf_esp，tf_eflags，tf_cs，tf_eip，tf_err在中断发生时由处理器压入，所以现在只需要压入剩下寄存器（%ds,%es,通用寄存器）
	//切换到内核数据段
_alltraps:
        pushl %ds 
        pushl %es 
        pushal
        movw $GD_KD, %ax
        movw %ax, %ds 
        movw %ax, %es 
        pushl %esp
        call trap /*never return*/
```

trap_init()函数中将会对系统的IDT表进行初始化设置,代码为：

```c
void
trap_init(void)
{
    extern struct Segdesc gdt[];

    // LAB 3: Your code here.
    void handler0();
    void handler1();
    void handler2();
    void handler3();
    void handler4();
    void handler5();
    void handler6();
    void handler7();
    void handler8();
    void handler10();
    void handler11();
    void handler12();
    void handler13();
    void handler14();
    void handler15();
    void handler16();
    void handler48();

    SETGATE(idt[T_DIVIDE], 0, GD_KT, handler0, 0); 
    SETGATE(idt[T_DEBUG], 0, GD_KT, handler1, 0); 
    SETGATE(idt[T_NMI], 0, GD_KT, handler2, 0); 

    // T_BRKPT DPL 3
    SETGATE(idt[T_BRKPT], 0, GD_KT, handler3, 3); 

    SETGATE(idt[T_OFLOW], 0, GD_KT, handler4, 0); 
    SETGATE(idt[T_BOUND], 0, GD_KT, handler5, 0); 
    SETGATE(idt[T_ILLOP], 0, GD_KT, handler6, 0); 
    SETGATE(idt[T_DEVICE], 0, GD_KT, handler7, 0); 
    SETGATE(idt[T_DBLFLT], 0, GD_KT, handler8, 0); 
    SETGATE(idt[T_TSS], 0, GD_KT, handler10, 0); 
    SETGATE(idt[T_SEGNP], 0, GD_KT, handler11, 0); 
    SETGATE(idt[T_STACK], 0, GD_KT, handler12, 0); 
    SETGATE(idt[T_GPFLT], 0, GD_KT, handler13, 0); 
    SETGATE(idt[T_PGFLT], 0, GD_KT, handler14, 0); 
    SETGATE(idt[T_FPERR], 0, GD_KT, handler16, 0); 

    // T_SYSCALL DPL 3
    SETGATE(idt[T_SYSCALL], 0, GD_KT, handler48, 3); 

    // Per-CPU setup 
    trap_init_percpu();
}
```

