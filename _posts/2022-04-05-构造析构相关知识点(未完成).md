---
layout:     post   				    # 使用的布局（不需要改）
title:      构造函数与析构函数相关知识点				# 标题 
subtitle:   面向对象的程序设计 #副标题
date:       2022-04-05 				# 时间
author:     谢玄xx 						# 作者
header-img: img/beckground.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - LeetCode
    - 面向对象
---

本期Blog素材来源： 北京大学郭炜老师——C++面向对象程序设计 [链接戳这里](https://www.bilibili.com/video/BV1ob411q7vb?p=7)



* **导航窗格**

    * [基本概念](#基本概念)
    
    * [为什么需要构造函数](#为什么需要构造函数)
    
    * [拷贝构造函数](#拷贝构造函数)

    * [类型转换构造函数](#类型转换构造函数)

    * [析构函数](#析构函数)





# 基本概念

* 构造函数——名字为类名，可以有参数，不能有返回值，void也不行。
* 作用：对对象进行**初始化**。
* 如果类定义时没有写构造函数，则编译器自动生成一个默认的无参构造函数。
* 对象生成的那一刻，构造函数就自动被调用；对象一旦生成，就再也不能在其上执行构造函数了。对象所占用的存储空间**不是由构造函数分配的**。当调用构造函数时，对象的内存空间已经被分配好了(房子已经盖好了)，构造函数只是做一些初始化工作(装修)。
* 一个类可以有**多个**构造函数。

# 为什么需要构造函数

* 构造函数可以执行必要的初始化工作。有了构造函数，我们就不用专门写初始化函数，也不用担心忘了调用初始化函数。
* 请注意，初始化非常重要！未初始化的对象使用起来很有可能会出错。打个比方，在做LeetCode的时候，我经常因为忘记初始化而WA...郁闷。
* 

# 拷贝构造函数

## 调用常见场景

一个类有且仅有一个拷贝构造函数。

拷贝构造函数会在三种情况下起作用：
1. 用一个对象去初始化同类的另一个对象时；
2. 如果某函数有一个**参数**是类A的对象，那么该函数被调用时，类A的拷贝构造函数将被调用。有点绕，试着理解一下，很好理解的！
3. 如果函数的**返回值**为类A的对象时，则函数返回时，A的拷贝构造函数被调用。

```CPP
//第2条的解释
class A
{
public:
    A(){}
    A(A & a)
    {
        cout << "已调用拷贝构造函数" << endl;
    }
};

void func(A a1) {}  //这个a1也是个对象。他是如何被初始化的呢？调用拷贝构造函数
int main()
{
    A a2;
    func(a2);
    return 0;
}
//因此上述程序的运行结果就是：已调用拷贝构造函数
```

```CPP
//第3条的解释
class A
{
    public:
    int v;
    A(int n)
    {
        v = n;
    }
    A(const A & a)
    {
        v = a.v;
        cout << "已调用拷贝构造函数" << endl;
    }
};

A Func()
{
    A b(4);
    return b;
}
int main()
{
    cout << Func().v << endl;
    return 0;
}
```


## 拷贝构造函数缺省

```CPP
class Complex
{
private:
    double real, imag;    
};

Complex c1;  //自动调用缺省无参构造函数
Complex c1(c2);  //调用缺省无参拷贝构造函数，将c2初始化地和c1一样
```

## 不调用的场景

**请注意**，对象间的赋值并不导致拷贝构造函数被调用！
```CPP
class CMyclass
{
public:
    int n;
    CMyclass() {}
    CMyclass( CMyclass & c)
    {
        n = 3 * c.n;
    }    
};

int main()
{
    CMyclass c1, c2;
    c1.n = 5;
    c2 = c1;   //注意，这是赋值语句，拷贝构造函数此时没调用
    CMyclass c3(c1);
    cout << "c2.n = " << c2.n << ",";
    cout << "c3.n = " << c3.n << endl;
    return 0;
    
}
```
上述程序执行结果为：c2.n = 5. c3.n = 10


## 拷贝构造函数已定义
```CPP
class Complex
{
private:
    double real, imag;    
    Complex() {}
    Complex(const Complex &c) 
    {
        real = c.real;//把real初始化成和c一样
        imag = c.imag;
        cout << "已调用拷贝构造函数" << endl;
    }
};

Complex c1;  //
Complex c2(c1);  //调用自己定义的拷贝构造函数，输出"已调用拷贝构造函数"。
Complex c3 = c2; //这条语句和上一条完全等价。
```
# 类型转换构造函数

* 定义转换构造函数的目的当然是为了实现类型的自动转换。
* 只有一个参数，而且不是拷贝构造函数的构造函数，一般就可以看成转换构造函数；
* 如需要，编译系统会自动调用转换构造函数，建立一个无名的临时对象/临时变量。

# 析构函数

* 名字与类名相同，在前面加"~"即可。没有参数和返回值。
* 一个类最多只能有一个析构函数。
* 
