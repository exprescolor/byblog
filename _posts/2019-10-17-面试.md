---
layout:     post 
title:      杂谈
subtitle:   面试
date:       2019-10-17
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.被static修饰的语句或者变量有哪些特点？

1. 随着类的加载而加载
2. 优先于对象存在
3. 被所有对象共享
4. 可以直接被类名所调用
5. 静态方法只能访问静态成员
6. 静态方法中不可以写this、super关键字
7. 主函数是静态的

#### 2.关于Java的垃圾回收机制，下面哪些结论是正确的？

1. 程序可以任意指定释放内存的时间
2. Java程序不能依赖于垃圾回收的时间或顺序
3. 程序可明确地标识某个局部变量的引用不再被使用
4. 程序可以显式地立即释放对象占有的内存

- 正确答案：3
- Java提供了一个系统级的线程，即垃圾回收线程，用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc();来建议执行垃圾回收器回收内存，但具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。
- 局部变量是存放在栈上的，栈上的垃圾回收，由finalize()实现

#### 3.Java中的ClassLoader（类加载器）

- ClassLoader是用来加载Class的，它负责将Class的字节码形式转换成内存形式的Class对象。字节码可以来自于磁盘文件.class，也可以是jar包里的.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组[]byte，它有特定的复杂的内部格式。
- 每个Class对象的内部都有一个ClassLoader字段来标识自己是由哪个ClassLoader加载的。ClassLoader就像一个容器，里面装了很多已经加载的Class对象。
- 延迟加载：也是类加载的动态性的体现。JVM运行并不是一次性加载所需要的全部类的，他是按需加载，也就是延迟加载。他总是先把保证程序运行的基础类一次性加载到JVM中，程序在运行的过程中会遇到很多不认识的新类，这时候就会调用ClassLoader来加载这些类。加载完成后就会将Class对象存在ClassLoader里面。下次就不需要重新加载了，这也是Java动态性的一种体现。
- Java类加载方式有两种：
   - 隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类加载器加载对应的类到JVM中
   - 显式装载：通过class.forName()等方法，显式加载需要的类
- JDK中提供了3个ClassLoader，根据层级从高到低为：
   - Bootstrap ClassLoader：主要加载JVM自身工作需要的类
   - Extension ClassLoader：主要加载%JAVA_HOME%\lib\ext目录下的库类
   - Application ClassLoader：主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）
- JVM加载类的实现方法：双亲委托模型
   - 如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。
   - 双亲委托模型的重要用途是为了解决类载入过程中的安全性问题
   - 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM，现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类，但是双亲委托模型不会让他成功，因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入他。

#### 4.以下程序的运行结果是什么？

```java
public static void main(String[] args) {
Object o1 = true ? new Integer(1) : new Double(2.0);
Object o2;
if (true) {
             o2 = new Integer(1);
} else {
o2 = new Double(2.0);
}
System.out.print(o1);
System.out.print(" ");         
System.out.print(o2);
}
```

- 答案：1.0 1
- 三元运算符如果遇到可以转换为数字的类型，会做自动类型提升
   - 三元运算符的转换规则：
      - 若两个操作数不可转换，则不做转换，返回值为Object类型
      - 若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等
      - 若两个操作数中有一个是数字s，另一个是表达式，且其类型标识为T，那么，若数字s在T的范围内，则转换为T类型；若s超出了T类型的范围，则T转换为s类型
      - 若两个操作数都是直接量数字，则返回值类型为范围较大者。

#### 5.下列程序执行后的结果是什么？

```java
class BaseClass {
 public BaseClass() {}
 {
 System.out.println("I’m BaseClass class");
 }
 static {
 System.out.println("static BaseClass");
 }
 }
 public class Base extends BaseClass {
 public Base() {}
 {
 System.out.println("I’m Base class");
 }
 static {
 System.out.println("static Base");
 }
 public static void main(String[] args) {
 new Base();
 }
 }
```

- 结果：

```java
static BaseClass
static Base
I’m BaseClass class
I’m Base class
```

- 执行顺序：父类的静态代码块，子类的静态代码块，父类的构造方法，子类的构造方法

#### 6.以下程序的运行结果是什么？

```java
TreeSet<Integer> set = new TreeSet<Integer>();
 TreeSet<Integer> subSet = new TreeSet<Integer>();
 for(int i=606;i<613;i++){
 if(i%2==0){
 set.add(i);
 }
 }
 subSet = (TreeSet)set.subSet(608,true,611,true);
 set.add(629);
 System.out.println(set+" "+subSet);
```

- `[606, 608, 610, 612, 629] [608, 610]`
- subset方法是求set的范围内的子集，两个true是表示是否包含端点（608和611），故subSet的值为[608,610]

#### 7.下面程序的运行结果是什么？

```java
public class ThreadTest extends Thread {
public void run() {
System.out.println("In run");
yield();
System.out.println("Leaving run");
}
public static void main(String []argv) {
(new ThreadTest()).start();
}
}
```

- 程序运行输出先有In run后有Leaving run
- Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。
- yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

#### 8.对Map的用法，下面正确的是？

1. `new java.util.Map().put("key" , "value") ;`
2. `new java.util.SortedMap().put("key" , "value") ;`
3. `new java.util.HashMap().put( null , null ) ;`
4. `new java.util.TreeMap().put( 0 , null ) ;`

- 答案：3，4
- 第一个Map是接口类型，不可以用new的形式创建对象
- 第二个SortedMap是接口类型，不可以用new的形式创建对象
- 第三个HashMap基于Hash表实现Map接口的类，并允许null的值和null键
- 第四个TreeMap通过红黑树实现Map接口的类，key不可以为null，会报NullPointerException异常，value可以为null

#### 9.字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同

#### 10.SpringMVC和Struts2的区别

- 机制：SpringMVC的入口是Servlet，Struts2的入口是filter
- 性能：SpringMVC是基于方法的设计，Struts2是基于类的设计。
- 参数传递：Struts2在接受参数时，可以用属性来接受参数，这就说明参数是让多个方法共享的
- 设计思想：Struts2更加符合面向对象的编程思想，Spring就比较严谨，在Servelt上拓展
- Interceptor的实现机制：Struts2有自己的Interceptor机制，SpringMVC用的是独立的AOP方式。SpringMVC是方法级别的拦截，Struts2是类级别的拦截。SpringMVC的方法之间基本上独立，独享Request、Response数据，请求数据通过参数获取，处理结果通过Map、Model交给框架，方法之间不共享。Struts2虽然方法是独立的，但其所有Action变量是共享的。

#### 11.Servlet使用哪种方法将其会话ID放置在写入Servlet响应输出流的URL中？

- HttpServletResponse接口的encodeURL方法。
   - 1.Java Servlet API 中引用 Session 机制来追踪客户的状态。Servlet API 中定义了 javax.servlet.http.HttpSession 接口，Servlet 容器必须实现这个接口。
   - 2.当一个 Session 开始时，Servlet 容器将创建一个 HttpSession 对象，Servlet 容器为 HttpSession 分配一个唯一标识符，称为 Session ID。Servlet 容器将 Session ID 作为 Cookie 保存在客户的浏览器中。每次客户发出 HTTP 请求时，Servlet 容器可以从 HttpRequest 对象中读取 Session ID，然后根据 Session ID 找到相应的 HttpSession 对象，从而获取客户的状态信息。
   - 3.当客户端浏览器中禁止 Cookie，Servlet 容器无法从客户端浏览器中取得作为 Cookie 的 Session ID，也就无法跟踪客户状态。Java Servlet API 中提出了跟踪 Session 的另一种机制，如果客户端浏览器不支持 Cookie，Servlet 容器可以重写客户请求的 URL，把 Session ID 添加到 URL 信息中。
   - 4. HttpServletResponse 接口提供了重写 URL 的方法：public java.lang.String encodeURL(java.lang.String url) ，该方法的机制为：
      - 先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。 
      - 再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。

- 我们可以对网页中的链接稍作修改，实现重写URL

```jsp
修改前：
<a href=“maillogin.jsp“>  
修改后：  
<a href=“<%=response.encodeURL(“maillogin.jsp“)%>“>  
```

#### 12.Spring的框架模块有哪些？

1. Spring Core： Core封装包是框架的最基础部分，提供IOC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。
2. Spring Context: 构建于Core封装包基础上的 Context封装包，提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。
3. Spring DAO:  DAO (Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。
4. Spring ORM: ORM 封装包提供了常用的“对象/关系”映射APIs的集成层。 其中包括JPA、JDO、Hibernate 和 iBatis 。利用ORM封装包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。
5. Spring AOP: Spring的 AOP 封装包提供了符合AOP Alliance规范的面向方面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中。
6. Spring Web: Spring中的 Web 包提供了基础的针对Web开发的集成特性，例如多方文件上传，利用Servlet listeners进行IOC容器初始化和针对Web的ApplicationContext。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。
7. Spring Web MVC: Spring中的MVC封装包提供了Web应用的Model-View-Controller（MVC）实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性。

#### 13.spring 配置文件中就可以通过lazy-init 设置延迟加载；Spring 属性注入只关注名称不关注类型，对象和基本数据都可以注入；spring 配置文件中就可以设置构造函数和消亡函数

#### 14.面向对象的六大原则是什么？

1. 单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。
2. 里式替换原则：子类只能去扩展基类，而不是隐藏或覆盖基类
3. 依赖倒置原则：模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的
4. 接口隔离原则：客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上
5. 开闭原则：开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。
6. 迪米特法则：一个对象应该对其他对象保持最小的了解。

#### 15.ER图中四种基本成分:实体（矩形框），关系（菱形框），属性（椭圆形框），连接（直线）

#### 16.视图设计的方法有哪些？

1. 自顶向下。先全局框架，然后逐步细化 
2. 自底向上。先局部概念结构，再集成为全局结构 
3. 由里向外。先核心结构，再向外扩张
4. 混合策略。1与2相结合，先自顶向下设计一个概念结构的框架，再自底向上为框架设计局部概念结构