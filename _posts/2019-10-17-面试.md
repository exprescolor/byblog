---
layout:     post 
title:      杂谈
subtitle:   面试
date:       2019-10-17
author:     张鹏
header-img: img/home-bg.jpg
catalog: true   
tags:                         
    - 题库
---

#### 1.被static修饰的语句或者变量有哪些特点？

1. 随着类的加载而加载
2. 优先于对象存在
3. 被所有对象共享
4. 可以直接被类名所调用
5. 静态方法只能访问静态成员
6. 静态方法中不可以写this、super关键字
7. 主函数是静态的

#### 2.关于Java的垃圾回收机制，下面哪些结论是正确的？

1. 程序可以任意指定释放内存的时间
2. Java程序不能依赖于垃圾回收的时间或顺序
3. 程序可明确地标识某个局部变量的引用不再被使用
4. 程序可以显式地立即释放对象占有的内存

- 正确答案：3
- Java提供了一个系统级的线程，即垃圾回收线程，用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc();来建议执行垃圾回收器回收内存，但具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。
- 局部变量是存放在栈上的，栈上的垃圾回收，由finalize()实现

#### 3.Java中的ClassLoader（类加载器）

- ClassLoader是用来加载Class的，它负责将Class的字节码形式转换成内存形式的Class对象。字节码可以来自于磁盘文件.class，也可以是jar包里的.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组[]byte，它有特定的复杂的内部格式。
- 每个Class对象的内部都有一个ClassLoader字段来标识自己是由哪个ClassLoader加载的。ClassLoader就像一个容器，里面装了很多已经加载的Class对象。
- 延迟加载：也是类加载的动态性的体现。JVM运行并不是一次性加载所需要的全部类的，他是按需加载，也就是延迟加载。他总是先把保证程序运行的基础类一次性加载到JVM中，程序在运行的过程中会遇到很多不认识的新类，这时候就会调用ClassLoader来加载这些类。加载完成后就会将Class对象存在ClassLoader里面。下次就不需要重新加载了，这也是Java动态性的一种体现。
- Java类加载方式有两种：
   - 隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类加载器加载对应的类到JVM中
   - 显式装载：通过class.forName()等方法，显式加载需要的类
- JDK中提供了3个ClassLoader，根据层级从高到低为：
   - Bootstrap ClassLoader：主要加载JVM自身工作需要的类
   - Extension ClassLoader：主要加载%JAVA_HOME%\lib\ext目录下的库类
   - Application ClassLoader：主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）
- JVM加载类的实现方法：双亲委托模型
   - 如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。
   - 双亲委托模型的重要用途是为了解决类载入过程中的安全性问题
   - 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM，现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类，但是双亲委托模型不会让他成功，因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入他。

#### 4.以下程序的运行结果是什么？

```java
public static void main(String[] args) {
Object o1 = true ? new Integer(1) : new Double(2.0);
Object o2;
if (true) {
             o2 = new Integer(1);
} else {
o2 = new Double(2.0);
}
System.out.print(o1);
System.out.print(" ");         
System.out.print(o2);
}
```

- 答案：1.0 1
- 三元运算符如果遇到可以转换为数字的类型，会做自动类型提升
   - 三元运算符的转换规则：
      - 若两个操作数不可转换，则不做转换，返回值为Object类型
      - 若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等
      - 若两个操作数中有一个是数字s，另一个是表达式，且其类型标识为T，那么，若数字s在T的范围内，则转换为T类型；若s超出了T类型的范围，则T转换为s类型
      - 若两个操作数都是直接量数字，则返回值类型为范围较大者。