---
layout:     post   				    # 使用的布局（不需要改）
title:      bomb 1-3			# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-20 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 基础知识
---

gdb调试教程：

> https://www.cnblogs.com/arnoldlu/p/9633254.html

汇编忘得差不多了hhh，边做题边复习吧，遇到不会的就查

这是一个32位的elf格式的文件，放在虚拟机打开，用gdb调试，可以先将汇编导出

`objdump -d bomb > asm.txt  `

然后一个个关卡来看

# phase_1(字符串比较)

先看汇编指令：

```汇编
08048b90 <phase_1>:
 8048b90:	83 ec 1c             	sub    $0x1c,%esp
 //把内存地址0x804a124中的内容赋给*（esp+4)
 8048b93:	c7 44 24 04 24 a1 04 	movl $0x804a124,0x4(%esp) 
 8048b9a:	08 
 //将输入的字符串赋给eax
 8048b9b:	8b 44 24 20          	mov    0x20(%esp),%eax
 //eax的值赋给*esp
 8048b9f:	89 04 24             	mov    %eax,(%esp)
 //比较两字符串是否相等，相等则eax的值为0
 8048ba2:	e8 53 04 00 00       	call   8048ffa <strings_not_equal>
 8048ba7:	85 c0                	test   %eax,%eax
 //如果eax=0，则进入phase_2，否则爆炸
 8048ba9:	74 05                	je     8048bb0 <phase_1+0x20>
 8048bab:	e8 55 05 00 00       	call   8049105 <explode_bomb>
 8048bb0:	83 c4 1c             	add    $0x1c,%esp
 8048bb3:	c3                   	ret    
```

由此我们可以知道，这个函数是判断你的输入和0x804a124的内容是否相等，相等进入下一关，不相等则爆炸

![1.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd05s1c6w8j30op0dhmzn.jpg)

使用

`x/s 0x804a124`

来获得该地址的内存数据  When I get angry, Mr. Bigglesworth gets upset.

![11.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd05uj0n87j30ix03ldg5.jpg)

运行程序，输入该字符串，过关

## phase_2（循环）

汇编指令：

```assembly
08048bb4 <phase_2>:
 8048bb4:	56                   	push   %esi
 8048bb5:	53                   	push   %ebx
 8048bb6:	83 ec 34             	sub    $0x34,%esp
 8048bb9:	8d 44 24 18          	lea    0x18(%esp),%eax
 8048bbd:	89 44 24 04          	mov    %eax,0x4(%esp)
 //下面两句将输入的数据赋值给*esp
 8048bc1:	8b 44 24 40          	mov    0x40(%esp),%eax
 8048bc5:	89 04 24             	mov    %eax,(%esp)
 8048bc8:	e8 5f 05 00 00       	call   804912c <read_six_numbers>  //读取六个数据
 8048bcd:	83 7c 24 18 01       	cmpl   $0x1,0x18(%esp)   //第一个数字为1则跳转，否则爆炸
 8048bd2:	74 1e                	je     8048bf2 <phase_2+0x3e>  //je相等则跳转
 8048bd4:	e8 2c 05 00 00       	call   8049105 <explode_bomb>
 8048bd9:	eb 17                	jmp    8048bf2 <phase_2+0x3e>
 8048bdb:	8b 43 fc             	mov    -0x4(%ebx),%eax  //下一位数字值赋给eax
 8048bde:	01 c0                	add    %eax,%eax     //eax=eax+eax
 8048be0:	39 03                	cmp    %eax,(%ebx)  //相等则跳转，不相等则爆炸
 8048be2:	74 05                	je     8048be9 <phase_2+0x35>
 8048be4:	e8 1c 05 00 00       	call   8049105 <explode_bomb>
 8048be9:	83 c3 04             	add    $0x4,%ebx   //ebx向后移动一位
 8048bec:	39 f3                	cmp    %esi,%ebx      //还未超过第六位数字，则跳转至<phase_2+0x27>即8048bdb，循环
 8048bee:	75 eb                	jne    8048bdb <phase_2+0x27>
 
 8048bf0:	eb 0a                	jmp    8048bfc <phase_2+0x48>
 8048bf2:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
 8048bf6:	8d 74 24 30          	lea    0x30(%esp),%esi
 8048bfa:	eb df                	jmp    8048bdb <phase_2+0x27>
 8048bfc:	83 c4 34             	add    $0x34,%esp
 8048bff:	5b                   	pop    %ebx
 8048c00:	5e                   	pop    %esi
 8048c01:	c3                   	ret 
```

这一关的难点在于找到循环是怎么进行的，比较第一个数字之后进入循环，循环的操作是mov    -0x4(%ebx),%eax，也就是数字*2，当循环次数足够时退出循环。

由此可得，这个函数实现了一个循环比较六位数字，其中第一位数字是1，后面每一位数字依次是前面数字的两倍，所以我们输入的数字为1 2 4 8 16 32

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd079l8r4mj30ew01rjrb.jpg)

# phase_3（条件/分支：含switch语句）

同样看汇编：

```asm
08048c02 <phase_3>:
 8048c02:	83 ec 2c             	sub    $0x2c,%esp
 8048c05:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 8048c09:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048c0d:	8d 44 24 18          	lea    0x18(%esp),%eax
 8048c11:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048c15:	c7 44 24 04 ef a2 04 	movl   $0x804a2ef,0x4(%esp)  //查看内存发现是%d %d，两个整数
 8048c1c:	08 
 8048c1d:	8b 44 24 30          	mov    0x30(%esp),%eax
 8048c21:	89 04 24             	mov    %eax,(%esp)
 8048c24:	e8 37 fc ff ff       	call   8048860 <__isoc99_sscanf@plt>
 8048c29:	83 f8 01             	cmp    $0x1,%eax
 8048c2c:	7f 05                	jg     8048c33 <phase_3+0x31>  //大于转移指令，即输入要大于1个
 8048c2e:	e8 d2 04 00 00       	call   8049105 <explode_bomb>
 8048c33:	83 7c 24 18 07       	cmpl   $0x7,0x18(%esp)  //第一个数和7比较，大于则引爆
 8048c38:	77 3c                	ja     8048c76 <phase_3+0x74>
 8048c3a:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048c3e:	ff 24 85 80 a1 04 08 	jmp    *0x804a180(,%eax,4)
 8048c45:	b8 7f 01 00 00       	mov    $0x17f,%eax
 8048c4a:	eb 3b                	jmp    8048c87 <phase_3+0x85>
 8048c4c:	b8 ff 01 00 00       	mov    $0x1ff,%eax  //输入2，转到*(0x804a180+2*4)也就是此处，1ff=511,eax被赋值为511
 8048c51:	eb 34                	jmp    8048c87 <phase_3+0x85>
 8048c53:	b8 78 00 00 00       	mov    $0x78,%eax
 8048c58:	eb 2d                	jmp    8048c87 <phase_3+0x85>
 8048c5a:	b8 bf 02 00 00       	mov    $0x2bf,%eax
 8048c5f:	eb 26                	jmp    8048c87 <phase_3+0x85>
 8048c61:	b8 08 03 00 00       	mov    $0x308,%eax
 8048c66:	eb 1f                	jmp    8048c87 <phase_3+0x85>
 8048c68:	b8 49 01 00 00       	mov    $0x149,%eax
 8048c6d:	eb 18                	jmp    8048c87 <phase_3+0x85>
 8048c6f:	b8 43 02 00 00       	mov    $0x243,%eax
 8048c74:	eb 11                	jmp    8048c87 <phase_3+0x85>
 8048c76:	e8 8a 04 00 00       	call   8049105 <explode_bomb>
 8048c7b:	b8 00 00 00 00       	mov    $0x0,%eax
 8048c80:	eb 05                	jmp    8048c87 <phase_3+0x85>
 8048c82:	b8 b2 00 00 00       	mov    $0xb2,%eax
 8048c87:	3b 44 24 1c          	cmp    0x1c(%esp),%eax  //比较第二个数字和eax，eax已经被赋值为511，所以第二个数应该输511
 8048c8b:	74 05                	je     8048c92 <phase_3+0x90>
 8048c8d:	e8 73 04 00 00       	call   8049105 <explode_bomb>
 8048c92:	83 c4 2c             	add    $0x2c,%esp
 8048c95:	c3                   	ret    
```

开始查看0x804a2ef的内存发现，指定输入的格式为两个整数，接下来判断第一个数字，要比7小，根据输入的数据跳转不同的地址，即switch语句

`jmp    *0x804a180(,%eax,4)`

这一句是判断的难点，一开始我没有搞懂这一句是怎么实现的，一直没拿到跳转的地址，后来知道这句话是这么给意思，要读取0x804a180+4*eax地址处的内存得到要跳转的地址，

我第一个数字输入了2，通过0x804a180+4*2=0x804a188，得到

` x/s *(0x804a188)`

得到要跳转的地址，发现是给寄存器赋值，然后跳转，这里的赋值根据跳转的地址不同，寄存器的赋值也就不同，跳转后

`cmp    0x1c(%esp),%eax`

比较第二个数字和寄存器的值是否相等，我跳转之后语句`mov    $0x1ff,%eax`将寄存器赋值为155也即十进制的511，得到第二个数字。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd08ybg23cj3064016dfm.jpg)

# 总结

今天主要是借着这个机会复习了一下汇编语言，之前见到汇编就往ida拖，真正读汇编指令的时候并不多，咋一看还有点头疼，很多指令特别是涉及到寄存器偏移的指令，以及一些比较和跳转指令，要边读边查，由于今天的时间关系没有对这些指令进行整理，明天在做题之前要先整理一下汇编指令