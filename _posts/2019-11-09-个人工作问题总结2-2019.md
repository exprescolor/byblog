---
layout:     post                        # 使用的布局（不需要改）
title:      个人工作问题总结2             # 标题 
subtitle:                               # 副标题
date:       2019-11-09                  # 时间
author:     AhogeK                      # 作者
header-img: img/post-bg-alibaba.jpg     # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - 工作
    - 问题总结
    - Spring Boot
    - Excel
    - ZIP
---

### Spring Boot Poi Excel的导入导出
#### Excel导入
**导入需要注意导入的是2003还是2007**<br>
首先 2003 在 poi 中使用的是 *HSSFWorkbook* 而 2007 使用的是 *XSSFWorkbook*
下面是普通的导入代码：

```java
    // @描述：是否是2003的excel，返回true是2003   
    public static boolean isExcel2003(String filePath)  {    
        return filePath.matches("^.+\\.(?i)(xls)$");    
    }    
    
    //@描述：是否是2007的excel，返回true是2007   
    public static boolean isExcel2007(String filePath)  {    
        return filePath.matches("^.+\\.(?i)(xlsx)$");    
    }    
    
    /**
    * check Excel
    * @param filePath
    * @return
    */
    public static boolean validateExcel(String filePath){  
        if (filePath == null || !(isExcel2003(filePath) || isExcel2007(filePath))){    
            return false;    
        }    
        return true;  
    }  


	void importExcel() throws IOException {
		File file = new File("C:\\Users\\11027\\Desktop\\工作簿1.xlsx");
		if(!file.exists()) {  
	        System.out.println("文件为空");
	    } else {
	    	InputStream is = new FileInputStream(file);
	    	// 获取文件名
	    	String fileName = file.getName();
	    	System.out.println(fileName);
	    	//根据版本选择创建Workbook的方式  
	        Workbook wb = null;
	        Sheet sheetAt = null;
	         
	        // 根据文件名判断文件是2003版本还是2007版本  
	        if(ExcelImportUtils.isExcel2007(fileName)){  
	           wb = new XSSFWorkbook(is);
	           sheetAt = wb.getSheetAt(0);
	        }else{  
	           wb = new HSSFWorkbook(is);  
	           sheetAt = wb.getSheetAt(0);
	        }
	        
	        List<User> userlist = new ArrayList<User>();
	        
	        for (Row row : sheetAt) {
	        	int rowNum = row.getRowNum();
	        	if (rowNum == 0) {
	        		continue;
	        	}
	        	
	        	String name = row.getCell(0).getStringCellValue();
	        	Integer age = (int) row.getCell(1).getNumericCellValue();
	        	String email = row.getCell(2).getStringCellValue();
	        	User user = new User();
	        	user.setName(name);
	        	user.setAge(age);
	        	user.setEmail(email);
	        	
	        	int result = userMapper.insert(user);
	        	System.out.println("************************"+result);
	        }
	    }
	}
```

工作中普遍公司的工具类中都会有 EXCEL 导入导出的专用工具类可以帮助我们省下很多代码

像导出代码，会先去查数据库拿到我们需要的数据，在利用 EXCEL 工具类将导出的数据逐一赋值新建Sheet表中的各个栏，这里会需要常量数据，即模板的表头和对应属性

### 文件的压缩导出
假如有这样的一个需求，上面的Excel进行批量导出，需要将批量导出的Excel进行压缩导出，这时我们就需要 *ZipStream* 这个类。但同样就要注意一些问题。<br>
往往我们在网上看到的代码如下：

```java
XSSFWorkbook workbook = new XSSFWorkbook();
//add some data
Zipoutputstream zipstream=new Zipoutputstream(//destination outputstream);
workbook.write(zipstream);
```
上一个导出中可以知道XSSFWorkbook是用于 2007 版的 EXCLE，因此，如果像这样直接写入到传参输出流的 zipstream 虽然可以压缩成功，但打开文件会注意到里面的 EXCEL文件就是个空文件，数据内容写在了zip里没写在 excel 文件里。

但仔细看其实这样的写法是适用于 **HSSFWorkbook** 但如果是 **XSSFWorkbook** 就需要 **ByteArrayOutputStream** 需要先将 workbook 写道 byteArray 输出流，再将 byteArray 输出流传到 zip流就可以拿到正常压缩 .xlsx 文件集。

```java
ZipOutputStream zos = new ZipOutputStream(//destination outputstream);
zos.putNextEntry(new ZipEntry("AnExcelFile.xlsx"));
ByteArrayOutputStream bos = new ByteArrayOutputStream();
workbook.write(bos);
bos.writeTo(zos);
zos.closeEntry();
// Add other entries as needed
zos.close();
```

### 关于 Spring Boot AOP 相关的一些问题
> 先提下，环绕通知 ProceedingJoinPoint 执行proceed方法的作用是让目标方法执行，这也是环绕通知和前置、后置通知方法的一个最大区别。Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法。

使用AOP需要在application.yml中加入

```yml
spring:
  aop:
    proxy-target-class: true
```

1. @Pointcut 切入点
> 定义一个切点例如我们要在一个方法加上切入点，根据方法的返回的对象，方法名，修饰词来写成一个表达式或者是具体的名字

```java
package com.example.aop;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * 类定义为切面类
 */
@Aspect
@Component
public class AopTestController {
    private static final Logger logger = LoggerFactory.getLogger(AopTestController.class);
    /**
     * 定义一个切点
     */
    @Pointcut(value = "execution(public String test (..))")
    public void cutOffPoint() {
    }
}
```

切入点方法：

``` java
    @GetMapping("hello")
    public String test(){
        logger.info("hello world");
        return "i love java";
    }
```

如果想写个切入点在所有返回一个实体对象的方法
@Pointcut("execution(public com.example.entity.User (..))")
等很多写法，也可以直接作用在某些包下
*注意：private修饰的无法拦截*

现在主要将一个环绕通知
**环绕通知=前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的**

```java
@Around("exportCutOfPoint()")
    public Object exportLog(ProceedingJoinPoint proceedingJoinPoint){
        // 目标方法执行前创建导出中心记录表并向数据库导入日志
        Object[] itemCodes = (Object[]) proceedingJoinPoint.getArgs()[0];
        ZwbkExportLog zwbkExportLog = new ZwbkExportLog();
        String exportLogId = UUID.randomUUID().toString().replace(AffairCommonConstants.MINUS, "");
        zwbkExportLog.setId(exportLogId);
        zwbkExportLog.setDerivedName(UserUtil.getUser().getUserName());
        zwbkExportLog.setDerivedType((String)proceedingJoinPoint.getArgs()[1]);
        zwbkExportLogMapper.insert(zwbkExportLog);
        Object obj;
        try{
            // 执行目标方法
            obj = proceedingJoinPoint.proceed();
            // 查询所有导出事项的事项信息
            QueryWrapper<ZwbkItemDirectory> queryWrapper = new QueryWrapper<>();
            queryWrapper.in("item_code", itemCodes);
            List<ZwbkItemDirectory> zwbkItemDirectoryList =  zwbkItemDirectoryMapper.selectList(queryWrapper);
            // 创建详细表中心并记录日志
            ZwbkExportLogDetails zwbkExportLogDetails = new ZwbkExportLogDetails();
            zwbkItemDirectoryList.forEach(zwbkItemDirectory -> {
                zwbkExportLogDetails.setExportCenterLogId(exportLogId);
                zwbkExportLogDetails.setItemCodeProd(zwbkItemDirectory.getItemCodeProd());
                zwbkExportLogDetails.setItemName(zwbkItemDirectory.getItemName());
                zwbkExportLogDetails.setAreaId(zwbkItemDirectory.getAreaId());
                zwbkExportLogDetails.setAreaCode(zwbkItemDirectory.getAreaCode());
                zwbkExportLogDetails.setAreaName(zwbkItemDirectory.getAreaName());
                zwbkExportLogDetails.setItemDeptId(zwbkItemDirectory.getItemDeptId());
                zwbkExportLogDetails.setItemDeptCode(zwbkItemDirectory.getItemDeptCode());
                zwbkExportLogDetails.setItemDeptName(zwbkItemDirectory.getItemDeptName());
                zwbkExportLogDetails.setItemNature(zwbkItemDirectory.getItemNature());
                zwbkExportLogDetailsMapper.insert(zwbkExportLogDetails);
            });
        } catch (Throwable throwable) {
            obj=throwable.toString();
        }
        return obj;
    }
```

>1.环绕通知可以项目做全局异常处理
>2.日志记录
>3.用来做数据全局缓存
>4.全局的事物处理 等