---
layout:     post   				    # 使用的布局（不需要改）
title:      828-lab2		# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-04-01 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 6828
---

# Lab2:内存管理

在这个实验中，我们将为操作系统编写内存管理代码。内存管理有两个组件。
第一个组件是内核的物理内存分配器，以便内核可以分配内存并在以后释放它。分配器将以4096字节为单位进行操作，称为页。我们需要维护数据结构，记录哪些物理页面是空闲的，哪些是已分配的，以及有多少进程共享每个已分配的页面。还需要编写分配和释放内存页的例程。
内存管理的第二个组成部分是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86硬件的内存管理单元(MMU)在指令使用内存时执行映射，参考一组页表。我们要根据提供的规范修改JOS以设置MMU的页表。

Lab 2包含以下新的源文件:

- `inc/memlayout.h`
- `kern/pmap.c`
- `kern/pmap.h`
- `kern/kclock.h`
- `kern/kclock.c`

memlayout.h描述了虚拟地址空间的结构，我们需要通过修改pmap.c文件来实现这个结构。memlayout.h和pmap.h文件定义了一个PageInfo结构，利用这个结构可以记录有哪些物理页是空闲的。kclock.c和kclock.h文件中操作的是用电池充电的时钟，以及CMOS RAM设备。在这个设备中记录着PC机拥有的物理内存的数量。在pmap.c中的代码必须读取这个设备中的信息才能弄清楚到底有多少内存。

## Part 1：物理页管理

操作系统必须跟踪哪些物理RAM是空闲的，哪些是当前正在使用的。JOS以页面粒度管理PC的物理内存，这样它就可以使用MMU来映射和保护每一块分配的内存。

现在，我们要编写物理页面分配器。它通过struct PageInfo对象的链接列表(与xv6不同，这些对象没有嵌入到空闲页面本身中)跟踪哪些页面是空闲的，每个对象对应一个物理页面。在编写其余的虚拟内存实现之前，我们要先编写物理页分配程序，因为页表管理代码将需要分配物理内存来存储页表。

### 练习1

在kern/pmap.c文件中，你必须实现以下功能的代码(可能按给出的顺序)。

boot_alloc ()

mem_init()(仅在调用check_page_free_list(1)时有效)

page_init ()

page_alloc ()

page_free ()

check_page_free_list()和check_page_alloc()会检查页分配代码是否正确。

我们打开pmap.c文件，在内核刚开始运行的时候会调用mem_init()这个函数，对内存进行一些初始化的设置，然后这个函数会调用i386_detect_memory ()来检测现在系统中有多少可用的内存空间。然后是一条我们需要改的代码：

```c
// Remove this line when you're ready to test this function.
//panic("mem_init: This function is not finished\n");
pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
memset(pages, 0, npages * sizeof(struct PageInfo));
```

用boot_alloc来进行分配内存，这是一个仅用于 JOS 设置自身虚拟内存系统时使用的物理内存分配器，仅用于 mem_init 函数。当初始化页面以及空闲内存列表后，不再使用 boot_alloc，而使用 page_alloc。

执行完这个函数，下一条指令为：

`kern_pgdir = (pde_t *) boot_alloc(PGSIZE);`

`memset(kern_pgdir, 0, PGSIZE);`

其中kern_pgdir是一个指针，pde_t *kern_pgdir，它是指向操作系统的页目录表的指针，操作系统之后工作在虚拟内存模式下时，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存大小空间为PGSIZE，即一个页的大小。并且首先把这部分内存清0。

然后调用boot_alloc函数，来看这个函数：

这个简单的物理内存分配器仅在JOS设置其虚拟内存系统时使用。page_alloc()是真正的分配器。

如果n&gt;0，分配足够的连续物理内存页来容纳“n”字节。不初始化内存。返回内核虚拟地址。

如果n==0，则返回下一个空闲页的地址，而不分配任何内容。

这个函数只能在初始化过程中使用，在page_free_list列表被设置之前。

而这个函数的核心思想就是维护一个静态变量nextfree，里面存放着下一个可以使用的空闲内存空间的虚拟地址，所以每次当我们想要分配n个字节的内存时，我们都需要修改这个变量的值。

```c
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// 空闲内存的下一个字节的虚拟地址
	char *result;

	// 如果这是第一次，初始化nextfree。“end”是链接器自动生成的符号，它指向内核的bss段的末尾:链接器没有分配给任何内核代g码或全局变量的第一个虚拟地址。
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// 分配一个大到足以容纳“n”字节的块，然后更新nextfree。确保nextfree与多个PGSIZE保持对齐。
	//
	// LAB 2: Your code here.
	cprintf("boot_alloc, nextfree:%x\n", nextfree);
   	result = nextfree;
    	if (n != 0) {
        	nextfree = ROUNDUP(nextfree + n, PGSIZE);
    	}   

      	return result;
	//return NULL;
}
```

回到刚刚的mem_init()函数往下走，到了`kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;·`这条指令，这一条指令就是再为页目录表添加第一个页目录表项。

然后调用需要我们修改的函数page_init()：

```c
void
page_init(void)
{
// NB: 不实际接触物理内存对应的空闲页面
    size_t i;

    //  1)将物理页面0标记为使用中。这样我们就保留了实际模式的IDT和BIOS结构，以备需要时使用。
    pages[0].pp_ref = 1;

    //  2) 剩余的基本内存[PGSIZE, npages_basemem * PGSIZE]是空闲的
    //把页面设为空闲，并插入链表头
    for (i = 1; i < npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }

    //  3) 然后是IO的[IOPHYSMEM, EXTPHYSMEM]，永远不能分配它。
    for (i = IOPHYSMEM/PGSIZE; i < EXTPHYSMEM/PGSIZE; i++) {
        pages[i].pp_ref = 1;
    }

    //  4) 然后[EXTPHYSMEM，…]。有些是在用的，有些是空闲的。物理内存中的内核在哪里?哪些页已经用于页表和其他数据结构
    size_t first_free_address = PADDR(boot_alloc(0));  //转为物理地址
    for (i = EXTPHYSMEM/PGSIZE; i < first_free_address/PGSIZE; i++) {
        pages[i].pp_ref = 1;
    }
    for (i = first_free_address/PGSIZE; i < npages; i++) {  
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
}

```

初始化关于所有物理内存页的相关数据结构后，进入check_page_free_list(1)函数，这个函数的功能就是检查page_free_list链表的所谓空闲页，是否真的都是合法的，空闲的。当输入参数为1时，这个函数要在检查前先进行一步额外的操作，对空闲页链表free_page_list进行修改，经过page_init，free_page_list中已经存放了所有的空闲页表，但是他们的顺序是按照页表的编号从大到小排列的。当前操作系统所采用的页目录表entry_pgdir中，并没有对大编号的页表进行映射，所以这部分页表我们还不能操作。但是小编号的页表，即从0号页表开始到1023号页表，已经映射过了，所以可以对这部分页表进行操作。那么check_page_free_list(1)要完成的就是把这部分页表对应的PageInfo结构体移动到free_page_list的前端，供操作系统现在使用。

然后先实现page_alloc（）：

这个函数实现的是分配一个物理页，函数的返回值就是这个物理页所对应的结构体

```c
//分配物理页面。如果(alloc_flags & ALLOC_ZERO)，则用“\0”字节填充整个返回的物理页。不增加页的引用计数—调用者必须在必要时执行这些操作(显式地或通过page_insert)。
//请确保将已分配页面的pp_link字段设置为NULL，以便page_free可以检查无双重错误。
//如果内存不足，则返回NULL。
//提示:使用page2kva和memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
   	 if (page_free_list == NULL) {
        return NULL;
    }
    struct PageInfo *allocated_page = page_free_list;  //取出空闲页的结构体
    page_free_list = page_free_list->pp_link;   //修改相关信息
    allocated_page->pp_link = NULL;  
    if (alloc_flags & ALLOC_ZERO) {
        memset(page2kva(allocated_page), '\0', PGSIZE);  //初始化内存
    }
    return allocated_page;
}
```

然后是page_free()函数：

这个方法的功能就是把一个页的PageInfo结构体再返回给page_free_list空闲页链表，代表回收了这个页。

```c
void
page_free(struct PageInfo *pp)page_free(struct PageInfo *pp)

{
    //修改被回收的页的结构体信息，释放后需要加入空闲页列表之中
    assert(pp->pp_ref == 0 && pp->pp_link == NULL); 
    pp->pp_link = page_free_list;
    page_free_list = pp; 
}
```

需要完善的几个函数都已经补充好了，make grade查看结果：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdenh5cn0hj30as01awec.jpg)

# part2：虚拟内存

## 虚拟地址，线性地址和物理地址

​		在x86中，虚拟地址由段选择器和段内的偏移量组成。线性地址是在段转换之后，页面转换之前得到的地址。物理地址是在段和页转换之后最终得到的地址，也是最终在硬件总线上输出到RAM的地址。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfj7ouv3mj30i804vq31.jpg)

​		C指针是虚拟地址的“偏移量”组件。在boot/boot.S，我们安装了一个全局描述符表(GDT)，它通过将所有段的基本地址设置为0并限制为0xffffffff来有效地禁用段转换。因此，“选择器”没有效果，线性地址总是等于虚拟地址的偏移量。在lab 3中，我们将不得不与分段进行更多的交互以设置特权级别，但是对于内存翻译，我们可以忽略整个JOS实验室中的分段，而只关注页面翻译。

​		还记得在lab 1的第3部分中，我们安装了一个简单的page表，这样内核就可以在它的链接地址0xf0100000处运行，即使它实际上是装载在物理内存中，就在ROM BIOS的上面0x00100000处。该页表仅映射了4MB的内存。在您将在这个实验室为JOS设置的虚拟地址空间布局中，我们将扩展它，以映射从虚拟地址0xf0000000开始的第一个256MB物理内存，并映射虚拟地址空间的许多其他区域。

### 练习3

虽然GDB只能通过虚拟地址访问QEMU的内存，但在设置虚拟内存时检查物理内存通常是有用的。查看来自实验室工具指南的QEMU监视器命令，特别是xp命令，它允许您检查物理内存。要访问QEMU监视器，请在终端中按Ctrl-a - c(相同的绑定返回到串行控制台)。

使用QEMU监视器中的xp命令和GDB中的x命令检查相应物理地址和虚拟地址的内存，确保看到相同的数据。

我们的QEMU补丁版本提供了一个info pg命令，它可能也很有用:它显示了当前页表的紧凑但详细的表示，包括所有映射的内存范围、权限和标志。Stock QEMU还提供了一个info mem命令，该命令显示了被映射的虚拟地址范围和权限的概述。

题目中提供的命令好像不行，我在网上找了另一个打开monitor的指令：

`qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log `

打开monitor之后，我们可以输入info registers指令来查看寄存器状态：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfjibuid9j30ny0gqadt.jpg)

输入info mem指令 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。

输入info pg指令 展示当前页表的结构。

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfjixu3drj30k60gqn03.jpg)

​		

​		从在CPU上执行的代码来看，一旦我们进入保护模式(我们在boot/boot. s中输入的第一件事)，就无法直接使用线性或物理地址。所有内存引用都被解释为虚拟地址，并由MMU进行翻译，这意味着C中的所有指针都是虚拟地址。

​		JOS内核经常需要将地址作为不透明的值或整数进行操作，而不取消对它们的引用，例如在物理内存分配器中。有时是虚拟地址，有时是物理地址。为了帮助记录代码，JOS源代码区分了两种情况:uintptr_t类型表示不透明的虚拟地址，而physaddr_t类型表示物理地址。这两种类型实际上都是32位整数(uint32_t)的同义词，因此编译器不会阻止您将一种类型分配给另一种类型!由于它们是整数类型(而不是指针)，如果您试图取消对它们的引用，编译器将会发出警告。

​		JOS内核可以通过首先将uintptr_t转换为指针类型来取消对它的引用。相反，内核不能理智地取消对物理地址的引用，因为MMU转换所有内存引用。如果您将一个physaddr_t转换为一个指针并取消引用它，您可能能够加载并存储到结果地址(硬件将把它解释为一个虚拟地址)，但是您可能不会得到您想要的内存位置。

总结：

| C type       | Address type |
| ------------ | ------------ |
| `T*`         | Virtual      |
| `uintptr_t`  | Virtual      |
| `physaddr_t` | Physical     |

​		JOS内核有时需要读取或修改它只知道物理地址的内存。例如，将映射添加到页表可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接加载和存储到物理地址。JOS从虚拟地址0xf0000000处的物理地址0开始重新映射所有物理内存的原因之一是，帮助内核读写它只知道物理地址的内存。为了将物理地址转换成内核实际上可以读写的虚拟地址，内核必须向物理地址添加0xf0000000，以便在重新映射的区域中找到它对应的虚拟地址。我们应该使用KADDR(pa)来进行添加。

​		JOS内核有时还需要根据存储内核数据结构的内存的虚拟地址查找物理地址。内核全局变量和由boot_alloc()分配的内存位于加载内核的区域，从0xf0000000开始，这正是我们映射所有物理内存的区域。因此，要将这个区域中的虚拟地址转换为物理地址，内核只需减去0xf0000000。我们应该用PADDR(va)来做减法。

## 引用计数

在未来的实验中，我们将经常在多个虚拟地址(或多个环境的地址空间)上同时映射相同的物理页面。我们将在struct PageInfo对应于物理页面的pp_ref字段中保留对每个物理页面的引用数量的计数。当一个物理页面的这个计数变为0时，该页面可以被释放，因为它不再被使用。通常，这个计数应该等于在所有页表中物理页出现在UTOP之下的次数(UTOP之上的映射大部分是在启动时由内核设置的，并且不应该被释放，因此不需要引用计数)。我们还将使用它来跟踪保存到页目录页的指针数量，进而跟踪页目录对页表页的引用数量。

使用page_alloc时要小心。它返回的页面的引用计数总是0，因此，一旦我们对返回的页面做了一些操作(比如将其插入到页表中)，pp_ref就应该增加。有时这是由其他函数处理的(例如，page_insert)，有时调用page_alloc的函数必须直接执行。

## 页表管理

现在，我们要编写一组管理页表的例程:插入和删除线性到物理的映射，以及在需要时创建页表页。

### 练习4

在kern/pmap文件中实现下列函数的代码：

```
pgdir_walk()
boot_map_region()
page_lookup()
page_remove()
page_insert()
```

从mem_init()调用check_page()，测试页表管理例程。

pgdir_walk()函数：

给定'pgdir'，一个指向页面目录的指针，pgdir_walk返回一个指向线性地址'va'的页表条目(PTE)的指针。这需要遍历两级页面表结构。相关页表页可能还不存在。如果这是真的，并且create == false，那么pgdir_walk返NULL。否则，pgdir_walk使用page_alloc分配一个新的页表页。

-如果分配失败，pgdir_walk返回NULL。

-否则，新页的引用计数将增加，该页将被清除，pgdir_walk将返回一个指向新页表页的指针。

提示1:您可以使用kern/pmap.h中的page2pa()将PageInfo *转换为它所引用的页面的物理地址。

提示2:x86 MMU同时检查页面目录和页面表中的权限位，因此将页面目录中的权限保留为比严格必要的权限更宽松是安全的。

提示3:在inc/mmu.h中查找操作页表和页目录条目的有用宏。

```c
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	unsigned int page_off;
       pte_t * page_base = NULL;
       struct PageInfo* new_page = NULL;
       //通过页目录表求得这个虚拟地址所在的页表页对于与页目录中的页目录项地址 dic_entry_ptr
       unsigned int dic_off = PDX(va);
       pde_t * dic_entry_ptr = pgdir + dic_off;
 		//判断这个页目录项对应的页表页是否已经在内存中
       if(!(*dic_entry_ptr & PTE_P))
       {
           //如果不在且create为true则分配新的页，并且把这个页的信息添加到页目录项dic_entry_ptr中
             if(create)
             {
                    new_page = page_alloc(1);
                    if(new_page == NULL) return NULL;
                    new_page->pp_ref++;
                    *dic_entry_ptr = (page2pa(new_page) | PTE_P | PTE_W | PTE_U);
             }
            else
                return NULL;      
       }  
    	//如果在，计算这个页表页的基地址page_base，然后返回va所对应页表项的地址 &page_base[page_off]
       page_off = PTX(va);
       page_base = KADDR(PTE_ADDR(*dic_entry_ptr));
       return &page_base[page_off];
	//return NULL;
}
```

然后再看boot_map_region()函数

在以pgdir为根的页表中，将虚拟地址空间的[va, va+size]映射到物理[pa, pa+size]。Size是PGSIZE的倍数，va和pa都是页面对齐的。

对条目使用perm|PTE_P权限位。

此函数仅用于设置UTOP之上的“静态”映射。因此，它应该“不”更改映射页面上的pp_ref字段。

提示:TA解决方案使用pgdir_walk

```c
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
 int nadd;
     pte_t *entry = NULL;
   //把一个虚拟页和物理页的映射关系存放到响应的页表项中。直到把size个字节的内存都分配完。
     for(nadd = 0; nadd < size; nadd += PGSIZE)
     {
         entry = pgdir_walk(pgdir,(void *)va, 1);    //Get the table entry of this page.
         *entry = (pa | perm | PTE_P);
        
         pa += PGSIZE;
         va += PGSIZE;
         
     }
}
```

page_insert()函数：

实现将物理页面“pp”映射到虚拟地址“va”。

页表条目的权限(最低12位)应该设置为“perm|PTE_P”。

要求：

-如果已经有一个页面映射在'va'，它应该是page_remove()d。

-如有需要，应根据需要分配一个页表并将其插入“pgdir”。

如果插入成功，pp-&gt;pp_ref应该增加。

-如果以前在“va”上有一个页面，则TLB必须无效。

大小写提示:确保考虑在相同的pgdir中的相同虚拟地址重新插入相同的pp时会发生什么。

但是，尽量不要在代码中区分这种情况，因为这经常会导致一些细微的bug;有一种优雅的方法可以在一个代码路径中处理所有内容。

```c
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
    //通过pgdir_walk函数求出虚拟地址va所对应的页表项
	pte_t *entry = NULL;
    entry =  pgdir_walk(pgdir, va, 1);    
    if(entry == NULL) return -E_NO_MEM;
 	//修改pp_ref的值
    pp->pp_ref++;
    //查看这个页表项，确定va是否已经被映射，如果被映射，则删除这个映射
    if((*entry) & PTE_P)            
    {
        tlb_invalidate(pgdir, va);
        page_remove(pgdir, va);
    }
    //把va和pp之间的映射关系加入到页表项中
    *entry = (page2pa(pp) | perm | PTE_P);
    pgdir[PDX(va)] |= perm;                 
	return 0;
}
```

page_lookup函数：

返回映射到虚拟地址'va'的页面。

如果pte_store不为零，则在其中存储此页的pte地址。这是page_remove使用的，可以用来验证syscall参数的页面权限，但是不应该被大多数调用者使用。

如果在va没有映射页面，则返回NULL。

提示:TA解决方案使用pgdir_walk和pa2page。

```c
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	 pte_t *entry = NULL;
     struct PageInfo *ret = NULL;
 	//调用pgdir_walk函数获取这个va对应的页表项
     entry = pgdir_walk(pgdir, va, 0);
     if(entry == NULL)
         return NULL;
     if(!(*entry & PTE_P))
         return NULL;
     //把这个页表项的内容存放到pte_store中
     ret = pa2page(PTE_ADDR(*entry));
     if(pte_store != NULL)
     {
         *pte_store = entry;
     }
    //返回结构体
     return ret;

}
```

page_remove函数：

在虚拟地址“va”处取消对物理页面的映射。

如果该地址没有物理页面，则不执行任何操作。

细节:

-物理页上的参考计数pp_ref应该递减。

-如果refcount为0，则释放物理页。

\- pg表中“va”对应的条目应设置为0。

(如有PTE)

-如果从页表中删除一个条目，则TLB必须无效。

提示:TA解决方案是使用page_lookup、tlb_invalidate和page_decf实现的。

```c
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t *pte = NULL;
     struct PageInfo *page = page_lookup(pgdir, va, &pte);
     if(page == NULL) return ;    
     
     page_decref(page);
     tlb_invalidate(pgdir, va);
     *pte = 0;
}
```

然后make一下：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdfteu0n4dj30ar021wee.jpg)

## part3：内核地址空间

​		JOS将处理器的32位线性地址空间分成两部分。我们将在lab 3中开始加载和运行的用户环境(进程)将控制下面部分的布局和内容，而内核始终保持对上面部分的完全控制。在inc/memlayout.h中，分界线是由符号ULIM任意定义的。为内核保留大约256MB的虚拟地址空间。这解释了为什么我们需要在lab 1中为内核提供如此高的链接地址:否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境中。

### 权限和故障隔离

​		因为内核和用户内存都存在于每个环境的地址空间中，所以我们必须在x86页面表中使用权限位来允许用户代码只访问地址空间的用户部分。否则，用户代码中的错误可能会覆盖内核数据，导致崩溃或更细微的故障;用户代码还可以窃取其他环境的私有数据。注意，可写权限位(PTE_W)同时影响用户和内核代码!

​		用户环境将不允许访问ULIM之上的任何内存，而内核将能够读写这些内存。对于地址范围[UTOP,ULIM]，内核和用户环境具有相同的权限:它们可以读取但不能写入这个地址范围。此地址范围用于向用户环境公开某些只读的内核数据结构。最后，UTOP下的地址空间供用户环境使用;用户环境将设置访问此内存的权限。

### 初始化内核地址空间

​		现在，我们要设置UTOP上面的地址空间:地址空间的内核部分。inc/memlayout.h显示了我们应该使用的布局。我们要使用刚才编写的函数来设置适当的线性到物理映射。

### 练习5

在调用check_page()之后，填充mem_init()中缺少的代码。

通过check_kern_pgdir()和check_page_installed_pgdir()检查代码。

题目要完成的是映射 UPAGES, KSTACK, KERNBASE虚拟地址空间到kern_pgdir。利用的是前面定义的 boot_map_region 这个函数。

1. UPAGES

这是记录物理页面使用情况的数据结构。由于用户空间同样需要访问这个数据结构，我们将用户空间的一块内存映射到存储该数据结构的物理内存上。

我们要映射的范围是把pages数组映射到线性地址UPAGES（第二个参数），大小为一个PTSIZE（第三个参数）。第四个参数是映射到的物理地址，取pages的物理地址。第五关参数perm变量设置为PTE_U，是因为这部分空间是kernel space和user space中的代码都能访问的，所以要设置PTE_U，用户有权限读取。所以代码是：

`boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);`

2. 内核栈

bootstack 表示的是栈地最低地址，由于栈向低地址生长，实际是栈顶。映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：

* [KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。

* [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。

KSTACKTOP = 0xf0000000，KSTKSIZE = 32kB。

对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：

` boot_map_region(kernel_pgdir, (uintptr_t) (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);	`

3. 内核

虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。映射全部 0xf0000000 至 0xffffffff 共 256MB 的内存地址。

访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：

` boot_map_region(kern_pgdir, (uintptr_t) KERNBASE, ROUNDUP(0xffffffff - KERNBASE, PGSIZE), 0, PTE_W | PTE_P);`

然后make一下：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gdj87l8kavj30cc04gmxc.jpg)

###地址空间布局方案

我们在JOS中使用的地址空间布局并不是惟一可能的。操作系统可能将内核映射到较低的线性地址，而将线性地址空间的上部留给用户进程。x86内核一般不采取这种方法,然而,因为一个x86的向后兼容模式,称为虚拟8086模式。

