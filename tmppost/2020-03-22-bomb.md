---
layout:     post   				    # 使用的布局（不需要改）
title:      bomb 6			# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-22 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - bomb
---

# phase_6

```assembly
08048da5 <phase_6>:
 8048da5:	56                   	push   %esi
 8048da6:	53                   	push   %ebx
 8048da7:	83 ec 44             	sub    $0x44,%esp
 8048daa:	8d 44 24 10          	lea    0x10(%esp),%eax
 8048dae:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048db2:	8b 44 24 50          	mov    0x50(%esp),%eax
 8048db6:	89 04 24             	mov    %eax,(%esp)
 8048db9:	e8 6e 03 00 00       	call   804912c <read_six_numbers> ;读入6个数字
 8048dbe:	be 00 00 00 00       	mov    $0x0,%esi
 8048dc3:	8b 44 b4 10          	mov    0x10(%esp,%esi,4),%eax  ;依次赋值开始外层循环
 8048dc7:	83 e8 01             	sub    $0x1,%eax
 8048dca:	83 f8 05             	cmp    $0x5,%eax  ;eax-1与5比较
 8048dcd:	76 05                	jbe    8048dd4 <phase_6+0x2f>   ;小于等于5则跳转，输入要小于6    跳转①
 8048dcf:	e8 31 03 00 00       	call   8049105 <explode_bomb>
 8048dd4:	83 c6 01             	add    $0x1,%esi  ;跳转①   计数器+1，六次循环
 8048dd7:	83 fe 06             	cmp    $0x6,%esi
 8048dda:	74 1b                	je     8048df7 <phase_6+0x52>  ;六次循环后退出
 8048ddc:	89 f3                	mov    %esi,%ebx   ;从1开始
 8048dde:	8b 44 9c 10          	mov    0x10(%esp,%ebx,4),%eax  ;跳转②   从第二个数字开始，取数组中的下一个，开始内层循环值
 8048de2:	39 44 b4 0c          	cmp    %eax,0xc(%esp,%esi,4)  ;比较
 8048de6:	75 05                	jne    8048ded <phase_6+0x48>  ;六个数字不相等，跳转②
 8048de8:	e8 18 03 00 00       	call   8049105 <explode_bomb>
 8048ded:	83 c3 01             	add    $0x1,%ebx   ;内循环开始  跳转②
 8048df0:	83 fb 05             	cmp    $0x5,%ebx
 8048df3:	7e e9                	jle    8048dde <phase_6+0x39>  ;小于等于则跳转
 8048df5:	eb cc                	jmp    8048dc3 <phase_6+0x1e>
 8048df7:	8d 44 24 10          	lea    0x10(%esp),%eax   ;六次循环后到这来
 8048dfb:	8d 5c 24 28          	lea    0x28(%esp),%ebx
 8048dff:	b9 07 00 00 00       	mov    $0x7,%ecx
 8048e04:	89 ca                	mov    %ecx,%edx   ;此时edx=7
 8048e06:	2b 10                	sub    (%eax),%edx
 8048e08:	89 10                	mov    %edx,(%eax)
 8048e0a:	83 c0 04             	add    $0x4,%eax
 8048e0d:	39 d8                	cmp    %ebx,%eax
 8048e0f:	75 f3                	jne    8048e04 <phase_6+0x5f>  ;这一块循环用7依次减去我们输入的数组的每一位，形成一个新的数组，仍由1-6不重复组成
 8048e11:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048e16:	eb 1d                	jmp    8048e35 <phase_6+0x90>
 8048e18:	8b 52 08             	mov    0x8(%edx),%edx
 8048e1b:	83 c0 01             	add    $0x1,%eax
 8048e1e:	39 c8                	cmp    %ecx,%eax
 8048e20:	75 f6                	jne    8048e18 <phase_6+0x73>
 8048e22:	eb 05                	jmp    8048e29 <phase_6+0x84>
 8048e24:	ba 3c c1 04 08       	mov    $0x804c13c,%edx  ;把一个地址赋给edx
 8048e29:	89 54 b4 28          	mov    %edx,0x28(%esp,%esi,4)  ;把下一个的地址放到栈里
 8048e2d:	83 c3 01             	add    $0x1,%ebx  
 8048e30:	83 fb 06             	cmp    $0x6,%ebx   ;循环6次
 8048e33:	74 17                	je     8048e4c <phase_6+0xa7>  ;六次之后跳转
 8048e35:	89 de                	mov    %ebx,%esi
 8048e37:	8b 4c 9c 10          	mov    0x10(%esp,%ebx,4),%ecx  ;依次取出输入的数
 8048e3b:	83 f9 01             	cmp    $0x1,%ecx
 8048e3e:	7e e4                	jle    8048e24 <phase_6+0x7f>  ;等于1则跳转
 8048e40:	b8 01 00 00 00       	mov    $0x1,%eax
 8048e45:	ba 3c c1 04 08       	mov    $0x804c13c,%edx    ;将第一个元素的下标放到edx里
 8048e4a:	eb cc                	jmp    8048e18 <phase_6+0x73>  ;这个循环串起一段链表
 8048e4c:	8b 5c 24 28          	mov    0x28(%esp),%ebx   ;取出下一个地址
 8048e50:	8d 44 24 2c          	lea    0x2c(%esp),%eax
 8048e54:	8d 74 24 40          	lea    0x40(%esp),%esi
 8048e58:	89 d9                	mov    %ebx,%ecx
 8048e5a:	8b 10                	mov    (%eax),%edx  ;将下一个地址放到edx中
 8048e5c:	89 51 08             	mov    %edx,0x8(%ecx)   ;地址+8
 8048e5f:	83 c0 04             	add    $0x4,%eax   ;指向下一个元素
 8048e62:	39 f0                	cmp    %esi,%eax   ;最后一个跳出
 8048e64:	74 04                	je     8048e6a <phase_6+0xc5>
 8048e66:	89 d1                	mov    %edx,%ecx   ;把下一个地址给ecx
 8048e68:	eb f0                	jmp    8048e5a <phase_6+0xb5>
 8048e6a:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)   ;降序排序
 8048e71:	be 05 00 00 00       	mov    $0x5,%esi
 8048e76:	8b 43 08             	mov    0x8(%ebx),%eax   ;下一个元素地址给eax
 8048e79:	8b 00                	mov    (%eax),%eax    ;取出下个元素的地址
 8048e7b:	39 03                	cmp    %eax,(%ebx)    ;ebx大于等于eax则跳转
 8048e7d:	7d 05                	jge    8048e84 <phase_6+0xdf>
 8048e7f:	e8 81 02 00 00       	call   8049105 <explode_bomb>
 8048e84:	8b 5b 08             	mov    0x8(%ebx),%ebx   ;读入下一个地址
 8048e87:	83 ee 01             	sub    $0x1,%esi
 8048e8a:	75 ea                	jne    8048e76 <phase_6+0xd1>   ;esi不等于1时跳转
 8048e8c:	83 c4 44             	add    $0x44,%esp
 8048e8f:	5b                   	pop    %ebx
 8048e90:	5e                   	pop    %esi
 8048e91:	c3                   	ret    

```

这一关的循环好麻烦！

一开始先来了一段循环

{

​       六个数字小于等于6

​           {

​                 6个数字大小各不相等

​            }

}

差不多是这个样子的。循环结束后确定了我们要输入一个1-6数字的排列，每个数字都不相等

下面代码用链表串起一组数字，这组数字在内存里存放，我们需要用输入的这组数字对内存中这组数字进行从大到小排序，然后我们查看内存数据：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd1vqm1s4fj30b90dcgmd.jpg)

分别是dd 224 2f4 2f1 fc 3bb   

然后发现代码中有一句话mov    $0x7,%ecx和sub    (%eax),%edx，这上下几句代码对我们输入的数字进行了处理，分别用7减去我们输入的数字，形成了新的数组。

把上面六个数字排序是 6 3 4 2 5 1  ，用7减去之后是  1 4 3 5 2 6

所以我们的输入应该是1 4 3 5 2 6

这一关的代码多，循环量大是一个难点，另一个就是指针的运用，好多寄存器取地址串起来，一不留神脑袋就乱了，捋了好几遍才反应过来。