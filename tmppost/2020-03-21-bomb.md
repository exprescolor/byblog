---
layout:     post   				    # 使用的布局（不需要改）
title:      bomb 4-5			# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-03-21 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - bomb
---

# phase_4(递归调用和栈)

```assembly
08048c96 <func4>:
 8048c96:	56                   	push   %esi  ；0
 8048c97:	53                   	push   %ebx  ；14 
 8048c98:	83 ec 14             	sub    $0x14,%esp
 8048c9b:	8b 54 24 20          	mov    0x20(%esp),%edx  
 8048c9f:	8b 44 24 24          	mov    0x24(%esp),%eax  
 8048ca3:	8b 74 24 28          	mov    0x28(%esp),%esi
 8048ca7:	89 f1                	mov    %esi,%ecx
 8048ca9:	29 c1                	sub    %eax,%ecx
 8048cab:	89 cb                	mov    %ecx,%ebx
 8048cad:	c1 eb 1f             	shr    $0x1f,%ebx  ；逻辑右移指令，右移的时候，最高位用0填补，最低位移入CF
 8048cb0:	01 d9                	add    %ebx,%ecx
 8048cb2:	d1 f9                	sar    %ecx  ； 逻辑右移，最高位不变，最低位移入CF
 8048cb4:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
 8048cb7:	39 d3                	cmp    %edx,%ebx
 8048cb9:	7e 17                	jle    8048cd2 <func4+0x3c>  ； 小于等于则跳转
 8048cbb:	8d 4b ff             	lea    -0x1(%ebx),%ecx
 8048cbe:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8048cc2:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048cc6:	89 14 24             	mov    %edx,(%esp)
 8048cc9:	e8 c8 ff ff ff       	call   8048c96 <func4>
 8048cce:	01 d8                	add    %ebx,%eax
 8048cd0:	eb 1b                	jmp    8048ced <func4+0x57>  
 8048cd2:	89 d8                	mov    %ebx,%eax
 8048cd4:	39 d3                	cmp    %edx,%ebx
 8048cd6:	7d 15                	jge    8048ced <func4+0x57>  ； 大于等于则跳转
 8048cd8:	89 74 24 08          	mov    %esi,0x8(%esp)
 8048cdc:	8d 43 01             	lea    0x1(%ebx),%eax
 8048cdf:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048ce3:	89 14 24             	mov    %edx,(%esp)
 8048ce6:	e8 ab ff ff ff       	call   8048c96 <func4>
 8048ceb:	01 d8                	add    %ebx,%eax
 8048ced:	83 c4 14             	add    $0x14,%esp
 8048cf0:	5b                   	pop    %ebx
 8048cf1:	5e                   	pop    %esi
 8048cf2:	c3                   	ret    

08048cf3 <phase_4>:
 8048cf3:	83 ec 2c             	sub    $0x2c,%esp
 8048cf6:	8d 44 24 1c          	lea    0x1c(%esp),%eax  ； 第二个数
 8048cfa:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048cfe:	8d 44 24 18          	lea    0x18(%esp),%eax  ；第一个数
 8048d02:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048d06:	c7 44 24 04 ef a2 04 	movl   $0x804a2ef,0x4(%esp)  ；输入为两个整数
 8048d0d:	08 
 8048d0e:	8b 44 24 30          	mov    0x30(%esp),%eax
 8048d12:	89 04 24             	mov    %eax,(%esp)
 8048d15:	e8 46 fb ff ff       	call   8048860 <__isoc99_sscanf@plt>
 8048d1a:	83 f8 02             	cmp    $0x2,%eax  ；输入为两个数，否则爆炸
 8048d1d:	75 07                	jne    8048d26 <phase_4+0x33>
 8048d1f:	83 7c 24 18 0e       	cmpl   $0xe,0x18(%esp)  ；第一个数和14比较
 8048d24:	76 05                	jbe    8048d2b <phase_4+0x38>  ；jbe小于等于则跳转
 8048d26:	e8 da 03 00 00       	call   8049105 <explode_bomb>  ； 否则爆炸
 8048d2b:	c7 44 24 08 0e 00 00 	movl   $0xe,0x8(%esp) ；esp+8=14
 8048d32:	00 
 8048d33:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)  ；esp+4=0
 8048d3a:	00 
 8048d3b:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048d3f:	89 04 24             	mov    %eax,(%esp)  ；eax=第一个数
 8048d42:	e8 4f ff ff ff       	call   8048c96 <func4>  ； 递归函数
 8048d47:	83 f8 13             	cmp    $0x13,%eax
 8048d4a:	75 07                	jne    8048d53 <phase_4+0x60>    ；eax(func返回值)不等于19则爆炸
 8048d4c:	83 7c 24 1c 13       	cmpl   $0x13,0x1c(%esp)
 8048d51:	74 05                	je     8048d58 <phase_4+0x65>   ； 第2个数等于19，否则爆炸
 8048d53:	e8 ad 03 00 00       	call   8049105 <explode_bomb>
 8048d58:	83 c4 2c             	add    $0x2c,%esp
 8048d5b:	c3                   	ret    
```

第四关解读：要求输入两个数，其中第一个数要小于等于14，第二个数要求是19，把第一个数作为func4的第一个参数，再加上0和14两个参数，执行函数func4，要求是当函数返回值为19的时候符合要求，所以我们要找这个满足条件的数字。

关于func4,我没太看明白，拖到ida里面反汇编了一下，得到了函数，因为上面已经规定了第一个数小于14，我就一个个试了一下，写了个c++的函数来遍历1-14这几个数字，发现输入4的时候返回值是19

```c++
#include <iostream>
using namespace std;
int __cdecl func4(int a1, int a2, int a3)   //cdecl是函数调用约定，从右到左压栈
{
    int v3; // ecx
    int v4; // ebx
    int result; // eax

    v3 = (a3 - a2) / 2;
    v4 = v3 + a2;
    if (v3 + a2 > a1)
        return v4 + func4(a1, a2, v4 - 1);
    result = v3 + a2;
    if (v4 < a1)
        result = v4 + func4(a1, v4 + 1, a3);
    return result;
}
int main()
{
    for (int i = 1; i < 14; i++)
    {
        cout << func4(i, 0, 14) << endl;;
    }
    return 0;
}
```

最后得到这组数为4，19,进入下一关

## 函数调用约定

数调用约定规定了执行过程中函数的调用者和被调用者之间如何传递参数以及如何恢复栈平衡。

**__cdecl**：

参数入栈顺序： 从右到左
堆栈平衡：调用者修改栈
函数名：前加下划线
由于每次函数调用都要由编译器产生还原栈的代码，所以使用__cdecl__编译的程序比stdcall编译的程序大很多。
但是__cdecl调用方式是由函数调用者负责清除栈中的函数参数，所以这种方式支持可变参数，比如printf()和Windows API的wsprintf

**__stdcall:   **

   windows API默认方式，参数从右向左入栈，被调函数负责栈平衡。

**__fastcall:__　**

参数入栈顺序：函数的第一个和第二个参数通过ecx和edx传递，剩余参数从右到左入栈

堆栈平衡：被调用者修改栈

函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸

以fastcall声明执行的函数，具有较快的执行速度，因为函数的前二个参数通过寄存器来传递的。

# phase_5(指针)

```assembly
08048d5c <phase_5>:
 8048d5c:	53                   	push   %ebx
 8048d5d:	83 ec 18             	sub    $0x18,%esp
 8048d60:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 8048d64:	89 1c 24             	mov    %ebx,(%esp)
 8048d67:	e8 6f 02 00 00       	call   8048fdb <string_length>
 8048d6c:	83 f8 06             	cmp    $0x6,%eax  ；输入字符串长度为6
 8048d6f:	74 05                	je     8048d76 <phase_5+0x1a>
 8048d71:	e8 8f 03 00 00       	call   8049105 <explode_bomb>
 8048d76:	ba 00 00 00 00       	mov    $0x0,%edx
 8048d7b:	b8 00 00 00 00       	mov    $0x0,%eax
 ；这一部分是一个循环
 8048d80:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx  ；依次取出字符串的一位字符
 8048d84:	83 e1 0f             	and    $0xf,%ecx   ；ecx和0xf按位与，保留低四位，0xf=1111
 8048d87:	03 14 8d a0 a1 04 08 	add    0x804a1a0(,%ecx,4),%edx  ；从内存中取出相应的内容加到edx上
 8048d8e:	83 c0 01             	add    $0x1,%eax  ；计数器+
 8048d91:	83 f8 06             	cmp    $0x6,%eax  ；循环六次
 8048d94:	75 ea                	jne    8048d80 <phase_5+0x24>  
 
 8048d96:	83 fa 3d             	cmp    $0x3d,%edx  ；最后edx要和3d也就是61相等
 8048d99:	74 05                	je     8048da0 <phase_5+0x44>
 8048d9b:	e8 65 03 00 00       	call   8049105 <explode_bomb>
 8048da0:	83 c4 18             	add    $0x18,%esp
 8048da3:	5b                   	pop    %ebx
 8048da4:	c3                   	ret   
```

第五关解读：我们要输入一个六位长的字符串，函数会一位一位与0xf进行或运算，并从相应地址中取出一个数加到edx上，遍历六位字符之后判断寄存器edx的值，等于61则过关。

先看一下0x804a1a0附近的内存：

![屏幕截图.jpg](http://ww1.sinaimg.cn/large/005KQQDely1gd1d52lsowj30js01eq2w.jpg)

让edx最后的结果为61，我们就需要从上面内存中找到六个可以重复的数字，使他们相加为61，

找到10+10+10+10+10+11=61，也就是1,1,1,1,1,12处的数字

把六个数字+16的倍数之后不影响与0xf与之后的结果，所以可以找97和108的ASCII码

得到字符串aaaaal

# 几个汇编指令

```
JE   ;等于则跳转
JNE  ;不等于则跳转
JZ   ;为 0 则跳转
JNZ  ;不为 0 则跳转
JS   ;为负则跳转
JNS  ;不为负则跳转
JC   ;进位则跳转
JNC  ;不进位则跳转
JO   ;溢出则跳转
JNO  ;不溢出则跳转

JA   ;无符号大于则跳转
JNA  ;无符号不大于则跳转
JAE  ;无符号大于等于则跳转
JNAE ;无符号不大于等于则跳转

JG   ;有符号大于则跳转
JNG  ;有符号不大于则跳转
JGE  ;有符号大于等于则跳转
JNGE ;有符号不大于等于则跳转

JB   ;无符号小于则跳转
JNB  ;无符号不小于则跳转
JBE  ;无符号小于等于则跳转
JNBE ;无符号不小于等于则跳转

JL   ;有符号小于则跳转
JNL  ;有符号不小于则跳转
JLE  ;有符号小于等于则跳转
```