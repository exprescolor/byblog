---
layout:     post   				    # 使用的布局（不需要改）
title:      深入理解计算机系统(CSAPP)_data lab	# 标题 
#subtitle:   脚本，xss #副标题
date:       2020-06-28 				# 时间
author:     s-seven 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - CSAPP
---



# 深入理解计算机系统—data lab

这本书的官方课程在>http://csapp.cs.cmu.edu/3e/labs.html上面可以找到，自学者可以下载self-study handout部分完成课后练习，同时配合CSAPP第三版课本使用

把handout下载之后在虚拟机打开这个文件夹，输入以下命令：

```
cd datalab-handout
./dlc bits.c
make btest
make
./btest
```

这几个命令就可以进行测试了

下面是data lab的课后题和一些笔记

- bitand  （只用~ |实现x&y）

   操作符限制：~ |

​		操作符使用数量限制：8

``int bitAnd(int x, int y) { return ~((~x) | (~y)); }``

- getbyte (取出x中的n号字节)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：6

```c
将x右移n*8位之后取出低8位的值
int getByte(int x, int n) { return (x >> (n << 3)) & 0xff; }
```

[![UJUjgJ.png](https://s1.ax1x.com/2020/07/13/UJUjgJ.png)](https://imgchr.com/i/UJUjgJ)

![UJyTbQ.png](https://s1.ax1x.com/2020/07/13/UJyTbQ.png)

- logicalshift (将x逻辑右移n位（0<=n<=31))

   操作符限制：! ~ & ^ | + << >>

   操作符使用数量限制：20

```c
将x的最高位除去后右移n位（保证高位补0），然后使用|操作符手动将最高位移动到的位置置上x的最高位。
int logicalShift(int x, int n) {
    int a = 1 << 31; //左移31位，二进制最左一位是1，其余是0
    return ((x & ~a) >> n) | ((!!(x & a)) << (32 + ~n));
}
```

- bitcount (统计x的二进制表示中1的数量)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：40

  这道题目的原回答在这里>https://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators

  使用了分治的思想，把所有位分成32组，然后相邻两两相加，直到得到一组数字，得到的值即为1的数量

  ```c
  int bitCount(int x) {
      int mask1 = 0x55;
      int mask2 = 0x33;
      int mask3 = 0x0F;
      int result = 0;
      mask1 = mask1 | (mask1 << 8);
      mask1 = mask1 | (mask1 << 16);
      mask2 = mask2 | (mask2 << 8);
      mask2 = mask2 | (mask2 << 16);
      mask3 = mask3 | (mask3 << 8);
      mask3 = mask3 | (mask3 << 16);
  
      result = (x & mask1) + ((x >> 1) & mask1);
      result = (result & mask2) + ((result >> 2) & mask2);
      result = (result & mask3) + ((result >> 4) & mask3);
      return (result + (result >> 8) + (result >> 16) + (result >> 24)) & 0xff;
  }
  ```

- bang (不使用！实现！操作符)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：16

```c
//非零数与它的相反数进行|运算后符号位一定为1
int bang(int x) { return 1 & (1 ^ ((x | (~x + 1)) >> 31)); }
```

- tmin (返回补码表示的整型的最小值)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：4

```C
//补码最小值就是符号位为1，其余全为0，对0x1进行移位运算即得
int tmin(void) { return 1 << 31; }
```

- fitbits (如果x可以只用n位补码表示则返回1，否则返回0)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：15

```C
int fitsBits(int x, int n) {
    int a = 33 + ~n;
    return !((x << a >> a) ^ x);
}
```

- divpwr2  (计算x/2^n，结果向下取整)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：15

```C
int divpwr2(int x, int n) {
    int a = 1 << 31;
    int isALessThanZero = !!(x & a);
    int isXHasMoreBit = (!!((~(a >> (32 + ~n))) & x));
    return (x >> n) + (isXHasMoreBit & isALessThanZero);
}
```

- negate (计算-x)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：5

  补码实际是是一个阿贝尔群，对于x，-x是其补码，可以通过对x取反加1得到。

  ``int negate(int x) { return ~x + 1; }``

- ispositive (如果x大于0返回1，否则返回0)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：15

  ``int isPositive(int x) { return !((x & (1 << 31)) | !x); }``

- islessorequal (如果x小于等于y则返回1，否则返回0)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：24

  进行x-y运算需要考虑到溢出带来的影响，先判断符号，符号不同正数大，符号相同看差值符号

```C
int isLessOrEqual(int x, int y) {
  int negX=~x+1;//-x
  int addX=negX+y;//y-x
  int checkSign = addX>>31&1; //y-x的符号
  int leftBit = 1<<31;//最大位为1的32位有符号数
  int xLeft = x&leftBit;//x的符号
  int yLeft = y&leftBit;//y的符号
  int bitXor = xLeft ^ yLeft;//x和y符号相同标志位，相同为0不同为1
  bitXor = (bitXor>>31)&1;//符号相同标志位格式化为0或1
  return ((!bitXor)&(!checkSign))|(bitXor&(xLeft>>31));
  //返回1有两种情况：符号相同标志位为0（相同）位与 y-x 的符号为0（y-x>=0）结果为1；符号相同标志位为1（不同）位与x的符号位为1（x<0）
}
```

- ilog2 (返回x求以2为底的对数的结果 向下取整)

  操作符限制：! ~ & ^ | + << >>

  操作符使用数量限制：90

  这题没做出来。。。

- float_neg (返回-f的位级表示)

  ```C
  unsigned float_neg(unsigned uf)
  {
    // 符号位取反
    unsigned neg = uf ^ 0x80000000;
    // 判断指数位 1~9 位是否全为 1，并且尾数位不为 0
    unsigned nan = uf & 0x7fffffff;
    if (nan > 0x7f800000) // 0x7f800000: 1~9位为 1
    {
      neg = uf;
    }
    return neg;
  }
  ```

- float_i2f (实现由int到float的类型转换)

  参考>https://github.com/imageslr/CSAPP-Labs/blob/master/data-lab/datalab-handout-my-solution/bits.c

  ```C
  unsigned float_i2f(int x)
  {
    int pos = 31;                               // 左侧第一个 1 的位置，从左到右为 31~0
    int signx = x & 0x80000000;                 // 符号位
    int exp;                                    // 指数位
    int t, tt, shifted_bits, shifted_len, mask; // 临时变量
  
    // 特殊情况，直接返回
    if (x == 0)
    {
      return 0;
    }
  
    // 如果 x 为负数，将其取反
    // 注意这里一定要取反，并且 x 取反后位级表示会发生改变，
    // 第一个 1 的位置会改变，不仅仅只有符号位取反
    if (signx)
    {
      x = -x;
    }
  
    // 找左侧第一个 1 的位置
    // 能用 while，就不需要用 11 题的分治的方法了
    while (!((1 << pos) & x))
    {
      pos -= 1;
    }
  
    // 尾数部分：把左侧第一个 1 移动到倒数第 24 位，需要根据 pos 对 x 左移或右移
    if (pos < 23)
    {
      // 向左移位，不需要考虑舍入的问题
      x <<= (23 - pos);
    }
    else
    {
      /**
       * 向右移位，需要舍入
       * 共分为 3 种情况：进一、舍去、向偶数舍入
       * （这部分内容在书的第 86 页）
       * 
       * 假设最后几位为 XYYY...，要舍入到 X 这一位：
       * 
       * 1. 如果 YYY... == 100...，即等于中间值，需要向偶数舍入
       *   向偶数舍入分为两种情况：
       *   1.1 如果 X 是 1，说明舍入后是奇数，因此要进一
       *   1.2 如果 X 是 0，说明舍入后是偶数，直接舍去 YYY...
       * 
       * 其他情况就是向上或向下舍入：
       * 2. 如果 YYY... > 100...，即大于中间值，要进一
       * 3. 如果 YYY... < 100...，即小于中间值，要舍去
       * 
       * 进一的时候可能溢出，因此要按照这个顺序：
       * ① 先舍入
       * ② 再判断是否溢出，如果溢出，pos + 1
       * ③ 最后再移位 / 计算指数部分
       */
      // 比较 YYY... 与 100...，YYY...是要被舍掉的位
      shifted_len = pos - 23;
      tt = 1 << shifted_len; // 00..1000..0
      t = tt >> 1;           // 00...100..0
      mask = tt - 1;         // 00...111..1
      shifted_bits = x & mask;
      // 向偶数舍入，且需要进 1
      if (shifted_bits == t)
      {
        if (x & tt)
          x += t;
      }
      // 向上舍入
      if (shifted_bits > t)
      {
        x += t;
      }
      // 判断是否因为进一而溢出
      if (x & (1 << (pos + 1)))
      {
        pos++;
      }
      // 移位
      x = x >> shifted_len;
    }
    x &= 0x7fffff; // x 只保留尾数部分
    // 指数部分：e = E + 2^7-1
    exp = (pos + 127) << 23;
    return x | signx | exp;
  }
  ```

- float_twice (返回2*f的位级表示)

  ```C
  unsigned float_twice(unsigned uf)
  {
    int _exp = uf & 0x7f800000;
    int exp = _exp >> 23;
    int frac = uf & 0x7fffff;
    int sign = (uf >> 31) & 1;
    // 0
    if (uf == 0 || uf == 0x80000000)
    {
      return uf;
    }
    // 无穷大、NaN
    if (exp == 0xff)
    {
      return uf;
    }
    // 规格化的
    if (exp > 0)
    {
      exp += 1;
    }
    else
    {
      // 非规格化的，其实这种情况就相当于指数位和尾数位整体左移 1 位
      return ((uf & (1 << 31)) | (uf << 1));
    }
    return (sign << 31) | (exp << 23) | frac;
  }
  ```

  